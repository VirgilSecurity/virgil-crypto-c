.template 0
#   Copyright (C) 2015-2020 Virgil Security, Inc.
#
#   All rights reserved.
#
#   Redistribution and use in source and binary forms, with or without
#   modification, are permitted provided that the following conditions are
#   met:
#
#       (1) Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#
#       (2) Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in
#       the documentation and/or other materials provided with the
#       distribution.
#
#       (3) Neither the name of the copyright holder nor the names of its
#       contributors may be used to endorse or promote products derived from
#       this software without specific prior written permission.
#
#   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR
#   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#   DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
#   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
#   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
#   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
#   STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
#   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#   POSSIBILITY OF SUCH DAMAGE.
#
#   Lead Maintainer: Virgil Security Inc. <support@virgilsecurity.com>

gsl from "common.gsl"
gsl from "wasm_format.gsl"
gsl from "wasm_derive.gsl"
gsl from "wasm_codegen.gsl"
gsl from "cmake_format.gsl"


# ===========================================================================
#   Helpers.
# ===========================================================================
function wasm_module_is_not_helper(wasm_module)
    check_arguments(my, "wasm_module", my)

    return !string_in(my.wasm_module.name, "asmjs, index, precondition")
endfunction

# ===========================================================================
#   Map types.
# ===========================================================================

# ---------------------------------------------------------------------------
#   Derive Swift type from the <instance/> type attributes.
# ---------------------------------------------------------------------------
function wasm_derive_instance_type(instance)
    check_arguments(my, "instance", my)

    if defined(my.instance.type)
        if my.instance.type = "nothing"
            my.primitive_type = "undefined"

        elsif my.instance.type = "boolean"
            my.primitive_type = "boolean"

        elsif my.instance.type = "char"
            my.primitive_type = "string"

        else
            my.primitive_type = "number"
        endif

        if count(my.instance.array)
            my.primitive_type = "object"
        endif

        return my.primitive_type

    elsif defined(my.instance.class)

        if my.instance.class = "data" | my.instance.class = "buffer"
            return "Uint8Array"
        else
            return "function"
        endif

    elsif defined(my.instance.impl)
            return "function"

    elsif defined(my.instance.interface)
            return "function"

    elsif defined(my.instance.enum)
            return "function"

    else
        my.instance_dump = component_instance_dump(my.instance)
        echo_warning("Unreachable code, component_resolve_instance() must handle this. $(my.instance_dump:)", my)
        return "Unknown"
    endif
endfunction

# ---------------------------------------------------------------------------
#   Map <instance/> attributes to the <wasm_instance type=""/> attributes.
# ---------------------------------------------------------------------------
function wasm_map_instance_type(instance, wasm_instance)
    check_arguments(my, "instance, wasm_instance", my)

    my.wasm_instance.type = wasm_derive_instance_type(my.instance)
    wrapper_map_instance_type_info(my.instance, my.wasm_instance)
endfunction


# ===========================================================================
#   Component creation.
# ===========================================================================

# ---------------------------------------------------------------------------
#   Create class <wasm_constant/> from the entity <constant/>.
# ---------------------------------------------------------------------------
function wasm_create_class_constant(constant, wasm_class)
    check_arguments(my, "constant, wasm_class", my)

    assert_attributes(my.constant, "name, value", my)

    new wasm_constant to my.wasm_class
        . = wasm_format_description(my.constant) ?
        .name = wasm_derive_constant_name(my.constant)
        .value = my.constant.value
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create enumeration <wasm_constant/> from the entity <constant/>
# ---------------------------------------------------------------------------
function wasm_create_enum_constant(constant, constant_value, wasm_enum)
    check_arguments(my, "constant, constant_value, wasm_enum", my)

    assert_attribute(my.constant, "name", my)

    new wasm_constant to my.wasm_enum
        . = wasm_format_description(my.constant) ?
        .name = wasm_derive_constant_name(my.constant)
        .value = my.constant_value
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create enumeration <wasm_precondition/>
# ---------------------------------------------------------------------------
function wasm_create_instance_precondition(instance, wasm_argument, wasm_project)
    check_arguments(my, "instance, wasm_argument, wasm_project", my)

    my.basic_precondition = wasm_derive_instance_precondition(my.instance, my.wasm_argument, my.wasm_project) ?
    if defined(my.basic_precondition)
        new wasm_precondition to my.wasm_argument
            . = my.basic_precondition
        endnew
    endif
endfunction

# ---------------------------------------------------------------------------
#   Create class default constructor.
# ---------------------------------------------------------------------------
function wasm_create_class_default_constructor(class, wasm_class)
    check_arguments(my, "class, wasm_class", my)

    new wasm_constructor to my.wasm_class
        . = "
            /**
             * Create object with underlying C context.
             *
             * Note. Parameter 'ctxPtr' SHOULD be passed from the generated code only.
             */
        "

        new wasm_argument to wasm_constructor
            .name = "ctxPtr"

            new wasm_precondition to wasm_argument
                . = wasm_derive_ctx_precondition(wasm_argument.name)
            endnew
        endnew

        new wasm_code to wasm_constructor
            . = "
                this.name = '$(my.wasm_class.name:)';

                if (typeof ctxPtr === 'undefined') {
                    this.ctxPtr = Module._$(class_derive_c_constructor(my.class))();
                } else {
                    this.ctxPtr = ctxPtr;
                }
            "
        endnew
    endnew

    new wasm_imported_function to my.wasm_class
        .name = class_derive_c_constructor(my.class)
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create class constructors with given C context.
# ---------------------------------------------------------------------------
function wasm_create_class_constructors_with_c_context(class, wasm_class)
    check_arguments(my, "class, wasm_class", my)

    new wasm_method to my.wasm_class
        . = "
            /**
             * Acquire C context by making it's shallow copy.
             *
             * Note. This method is used in generated code only, and SHOULD NOT be used in another way.
             */
        "
        .name = "newAndUseCContext"
        .is_static = "1"

        new wasm_argument to wasm_method
            .name = "ctxPtr"
        endnew

        new wasm_code to wasm_method
            . = "
                // assert(typeof ctxPtr === 'number');
                return new $(my.wasm_class.name:)(Module._$(class_derive_c_method_shallow_copy(my.class))(ctxPtr));
            "
        endnew
    endnew

    new wasm_method to my.wasm_class
        . = "
            /**
             * Acquire C context by taking it ownership.
             *
             * Note. This method is used in generated code only, and SHOULD NOT be used in another way.
             */
        "
        .name = "newAndTakeCContext"
        .is_static = "1"

        new wasm_argument to wasm_method
            .name = "ctxPtr"
        endnew

        new wasm_code to wasm_method
            . = "
                // assert(typeof ctxPtr === 'number');
                return new $(my.wasm_class.name:)(ctxPtr);
            "
        endnew
    endnew

    new wasm_imported_function to my.wasm_class
        .name = class_derive_c_method_shallow_copy(my.class)
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create factory methods that create specific implementation class from
#   the generic interface type, aka vscf_impl_t.
# ---------------------------------------------------------------------------
function wasm_create_custom_interface_class_constructors(source, wasm_class, wasm_project)
    check_arguments(my, "source, wasm_class, wasm_project", my)

    new wasm_method to my.wasm_class
        . = "
            /**
             * Acquire C context by taking it ownership.
             *
             * Note. This method is used in generated code only, and SHOULD NOT be used in another way.
             */
        "
        .name = "newAndTakeCContext"
        .is_static = "1"

        new wasm_argument to wasm_method
            .name = "ctxPtr"

            new wasm_precondition to wasm_argument
                . = wasm_derive_ctx_precondition(wasm_argument.name)
            endnew
        endnew

        my.code_switch_statement_begin = format_left("
            const implTag = Module._$(impl_derive_c_method_tag())(ctxPtr);
            switch(implTag) {
        ")

        my.code_switch_statement_end = terminator + format_left("
                default:
                    throw new Error('Unexpected implementation tag found: ' + implTag);
            }
        ")

        for my.source.implementation as impl
            my.code_switch_statement_cases ?= ""
            my.code_switch_statement_cases += terminator + format_left("
                case modules.$(my.wasm_project.impl_tag_enum_name:).$(wasm_derive_constant_name_str(impl.name)):
                    return modules.$(wasm_derive_class_name(impl)).newAndTakeCContext(ctxPtr);
            ", 1)
        endfor

        new wasm_code to wasm_method
            . = my.code_switch_statement_begin + my.code_switch_statement_cases + my.code_switch_statement_end
        endnew
    endnew

    new wasm_method to my.wasm_class
        . = "
            /**
             * Acquire C context by making it's shallow copy.
             *
             * Note. This method is used in generated code only, and SHOULD NOT be used in another way.
             */
        "
        .name = "newAndUseCContext"
        .is_static = "1"

        new wasm_argument to wasm_method
            .name = "ctxPtr"

            new wasm_precondition to wasm_argument
                . = wasm_derive_ctx_precondition(wasm_argument.name)
            endnew
        endnew

        new wasm_code to wasm_method
            . = "
                return new modules.$(my.wasm_class.name:).newAndTakeCContext(Module._$(impl_derive_c_method_shallow_copy())(ctxPtr));
            "
        endnew
    endnew

    new wasm_imported_function to my.wasm_class
        .name = impl_derive_c_method_shallow_copy()
    endnew

    new wasm_imported_function to my.wasm_class
        .name = impl_derive_c_method_tag()
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create helper methods:
#       - that checks that interface is implemented within a given class.
# ---------------------------------------------------------------------------
function wasm_create_custom_interface_class_helpers(source, wasm_class, wasm_project)
    check_arguments(my, "source, wasm_class, wasm_project", my)

    new wasm_method to my.wasm_class
        . = "
            /**
             * Return true if given class implements C interface with a given tag.
             *
             * Note. This method is used in generated code only, and SHOULD NOT be used in another way.
             */
        "
        .name = "isImplemented"
        .is_static = "1"

        new wasm_argument to wasm_method
            .name = "ctxPtr"

            new wasm_precondition to wasm_argument
                . = wasm_derive_ctx_precondition(wasm_argument.name)
            endnew
        endnew

        new wasm_argument to wasm_method
            .name = "interfaceTag"

            new wasm_precondition to wasm_argument
                . = wasm_derive_number_precondition(wasm_argument.name)
            endnew
        endnew

        new wasm_code to wasm_method
            . = "return Module._$(impl_derive_c_method_api())(ctxPtr, interfaceTag) != 0;"
        endnew
    endnew

    new wasm_imported_function to my.wasm_class
        .name = impl_derive_c_method_api()
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create class default destructor.
# ---------------------------------------------------------------------------
function wasm_create_class_destructor(class, wasm_class)
    check_arguments(my, "class, wasm_class", my)

    new wasm_method to my.wasm_class
        . = "
            /**
             * Release underlying C context.
             */
        "
        .name = "delete"

        new wasm_code to wasm_method
            . = "
                if (typeof this.ctxPtr !== 'undefined' && this.ctxPtr !== null) {
                    Module._$(class_derive_c_destructor(my.class))(this.ctxPtr);
                    this.ctxPtr = null;
                }
            "
        endnew
    endnew

    new wasm_imported_function to my.wasm_class
        .name = class_derive_c_destructor(my.class)
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Add dependency setter as <wasm_method/>.
# ---------------------------------------------------------------------------
function wasm_create_class_dependency_method(dependency, class, wasm_class, wasm_project)
    check_arguments(my, "dependency, class, wasm_class, wasm_project", my)

    new wasm_method to my.wasm_class
        . = wasm_format_description(my.dependency) ?
        .name = wasm_derive_method_name_str(my.dependency.name)
        .is_setter = "1"

        my.arg_name = wasm_derive_method_argument_name(my.dependency)

        new wasm_precondition to wasm_method
            . = wasm_derive_ctx_precondition("this.ctxPtr")
        endnew

        new wasm_argument to wasm_method
            .name = my.arg_name

            wasm_map_instance_type(my.dependency, wasm_argument)
            wasm_create_instance_precondition(my.dependency, wasm_argument, my.wasm_project)
        endnew

        new wasm_code to wasm_method
            my.code = ""

            my.code += wasm_format_prconditions(wasm_method) ? ""

            if my.dependency.has_observers & my.dependency.is_observers_return_status
                my.result_var = "const proxyStatus = "
                my.impl_handle_status = "modules.$(my.wasm_project.error_class_name:).handleStatusCode(proxyStatus)"
            endif

            my.code += format_left("
                Module._$(class_derive_c_method_release_dependency(my.class, my.dependency))(this.ctxPtr)
                $(my.result_var?:)Module._$(class_derive_c_method_use_dependency(my.class, my.dependency))(this.ctxPtr,\
                        $(my.arg_name:).ctxPtr)
                $(my.impl_handle_status?:)
            ")

            . = my.code
        endnew
    endnew

    new wasm_imported_function to my.wasm_class
        .name = class_derive_c_method_release_dependency(my.class, my.dependency)
    endnew

    new wasm_imported_function to my.wasm_class
        .name = class_derive_c_method_use_dependency(my.class, my.dependency)
    endnew
endfunction


# ---------------------------------------------------------------------------
function wasm_create_method_argument_for_primitive_type(argument, wasm_method, wasm_class, wasm_project)
    check_arguments(my, "argument, wasm_method, wasm_class, wasm_project", my)

    new wasm_argument to my.wasm_method
        .name = wasm_derive_method_argument_name(my.argument)

        wasm_map_instance_type(my.argument, wasm_argument)
        wasm_create_instance_precondition(my.argument, wasm_argument, my.wasm_project)

        my.wasm_method.c_arg_list += 0.name + ", "
    endnew
endfunction

# ---------------------------------------------------------------------------
function wasm_create_method_argument_for_data(argument, wasm_method, wasm_class, wasm_project)
    check_arguments(my, "argument, wasm_method, wasm_class, wasm_project", my)

    new wasm_argument to my.wasm_method
        .name = wasm_derive_method_argument_name(my.argument)

        wasm_map_instance_type(my.argument, wasm_argument)
        wasm_create_instance_precondition(my.argument, wasm_argument, my.wasm_project)

        .code_on_initialize = "
            //  Copy bytes from JS memory to the WASM memory.
            const $(0.name:)Size = $(0.name:).length * $(0.name:).BYTES_PER_ELEMENT;
            const $(0.name:)Ptr = Module._malloc($(0.name:)Size);
            Module.HEAP8.set($(0.name:), $(0.name:)Ptr);

            //  Create C structure vsc_data_t.
            const $(0.name:)CtxSize = Module._vsc_data_ctx_size();
            const $(0.name:)CtxPtr = Module._malloc($(0.name:)CtxSize);

            //  Point created vsc_data_t object to the copied bytes.
            Module._vsc_data($(0.name:)CtxPtr, $(0.name:)Ptr, $(0.name:)Size);
        "

        .code_on_finalize = "
            Module._free($(0.name:)Ptr);
            Module._free($(0.name:)CtxPtr);
        "

        my.wasm_method.c_arg_list += "$(0.name:)CtxPtr" + ", "
    endnew
endfunction

# ---------------------------------------------------------------------------
function wasm_create_method_return_for_writeonly_buffer(argument, wasm_method, wasm_class, wasm_project)
    check_arguments(my, "argument, wasm_method, wasm_class, wasm_project", my)

    new wasm_return to my.wasm_method
        .name = wasm_derive_method_argument_name(my.argument)

        wasm_map_instance_type(my.argument, wasm_return)

        .code_on_initialize = "
            const $(0.name:)Capacity = $(wasm_derive_buffer_length_getter(my.argument, my.wasm_class));
            const $(0.name:)CtxPtr = Module._vsc_buffer_new_with_capacity($(0.name:)Capacity);
        "

        .code_on_success = "
            const $(0.name:)Ptr = Module._vsc_buffer_bytes($(0.name:)CtxPtr);
            const $(0.name:)PtrLen = Module._vsc_buffer_len($(0.name:)CtxPtr);
            const $(0.name:) = Module.HEAPU8.slice($(0.name:)Ptr, $(0.name:)Ptr + $(0.name:)PtrLen);
        "

        .code_on_finalize = "
            Module._vsc_buffer_delete($(0.name:)CtxPtr);
        "

        my.wasm_method.c_arg_list += "$(0.name:)CtxPtr" + ", "
    endnew
endfunction

# ---------------------------------------------------------------------------
function wasm_create_method_argument_for_readwrite_buffer(argument, wasm_method, wasm_class, wasm_project)
    check_arguments(my, "argument, wasm_method, wasm_class, wasm_project", my)

    new wasm_argument to my.wasm_method
        .name = wasm_derive_method_argument_name(my.argument)

        wasm_map_instance_type(my.argument, wasm_argument)
        wasm_create_instance_precondition(my.argument, wasm_argument, my.wasm_project)

        .code_on_initialize = "
            //  Copy bytes from JS memory to the WASM memory.
            const $(0.name:)Capacity = $(0.name:).length * $(0.name:).BYTES_PER_ELEMENT;
            const $(0.name:)Ptr = Module._malloc($(0.name:)Capacity);
            Module.HEAP8.set($(0.name:), $(0.name:)Ptr);

            //  Create C structure vsc_buffer_t.
            const $(0.name:)CtxPtr = Module._vsc_buffer_new();

            //  Point created vsc_buffer_t object to the copied bytes.
            Module._vsc_buffer_use($(0.name:)CtxPtr, $(0.name:)Ptr, $(0.name:)Capacity);
        "

        .code_on_finalize = "
            Module._vsc_buffer_delete($(0.name:)CtxPtr);
        "

        my.wasm_method.c_arg_list += "$(0.name:)CtxPtr" + ", "
    endnew

    new wasm_return to my.wasm_method
        .name = "$(wasm_derive_method_argument_name(my.argument))Result"

        wasm_map_instance_type(my.argument, wasm_return)

        .code_on_success = "
            const $(0.name:)Ptr = Module._vsc_buffer_bytes($(0.name:)CtxPtr);
            const $(0.name:)PtrLen = Module._vsc_buffer_len($(0.name:)CtxPtr);
            const $(0.name:)Result = Module.HEAPU8.slice($(0.name:)Ptr, $(0.name:)Ptr + $(0.name:)PtrLen);
        "
    endnew
endfunction

# ---------------------------------------------------------------------------
function wasm_create_method_argument_for_class(argument, wasm_method, wasm_class, wasm_project)
    check_arguments(my, "argument, wasm_method, wasm_class, wasm_project", my)

    new wasm_argument to my.wasm_method
        .name = wasm_derive_method_argument_name(my.argument)

        wasm_map_instance_type(my.argument, wasm_argument)
        wasm_create_instance_precondition(my.argument, wasm_argument, my.wasm_project)

        my.wasm_method.c_arg_list += "$(0.name:).ctxPtr" + ", "
    endnew
endfunction

# ---------------------------------------------------------------------------
function wasm_create_method_argument_for_interface(argument, wasm_method, wasm_class, wasm_project)
    check_arguments(my, "argument, wasm_method, wasm_class, wasm_project", my)

    new wasm_argument to my.wasm_method
        .name = wasm_derive_method_argument_name(my.argument)

        wasm_map_instance_type(my.argument, wasm_argument)
        wasm_create_instance_precondition(my.argument, wasm_argument, my.wasm_project)

        my.wasm_method.c_arg_list += "$(0.name:).ctxPtr" + ", "
    endnew
endfunction

# ---------------------------------------------------------------------------
function wasm_create_method_argument_for_enum(argument, wasm_method, wasm_class, wasm_project)
    check_arguments(my, "argument, wasm_method, wasm_class, wasm_project", my)

    new wasm_argument to my.wasm_method
        .name = wasm_derive_method_argument_name(my.argument)

        wasm_map_instance_type(my.argument, wasm_argument)
        wasm_create_instance_precondition(my.argument, wasm_argument, my.wasm_project)

        my.wasm_method.c_arg_list += "$(0.name:)" + ", "
    endnew
endfunction

# ---------------------------------------------------------------------------
function wasm_create_method_argument_for_class_error(argument, wasm_method, wasm_class, wasm_project)
    check_arguments(my, "argument, wasm_method, wasm_class, wasm_project", my)

    new wasm_argument to my.wasm_method
        .name = wasm_derive_method_argument_name(my.argument)
        .is_local = "1"

        .code_on_initialize = "
            const $(0.name:)CtxSize = Module._$(class_error_derive_c_method_ctx_size())();
            const $(0.name:)CtxPtr = Module._malloc($(0.name:)CtxSize);
            Module._$(class_error_derive_c_method_reset())($(0.name:)CtxPtr);
        "

        .code_on_success = "
            const $(0.name:)Status = Module._$(class_error_derive_c_method_status())($(0.name:)CtxPtr);
            modules.$(my.wasm_project.error_class_name:).handleStatusCode($(0.name:)Status);
        "
        .code_on_finalize = "
            Module._free($(0.name:)CtxPtr);
        "
        my.wasm_method.c_arg_list += "$(0.name:)CtxPtr" + ", "
    endnew
endfunction

# ---------------------------------------------------------------------------
function wasm_create_method_return_for_primitive_type(return, wasm_method, wasm_class)
    check_arguments(my, "return, wasm_method, wasm_class", my)

    new wasm_return to my.wasm_method
        .name = "proxyResult"

        wasm_map_instance_type(my.return, wasm_return)

        wasm_return.code_on_initialize = "
            let proxyResult;
        "

        if wasm_return.type = "boolean"
            wasm_return.name = "booleanResult"
            wasm_return.code_on_success = "
                const booleanResult = !!proxyResult;
            "
        endif
    endnew
endfunction

# ---------------------------------------------------------------------------
function wasm_create_method_return_for_data(return, wasm_method, wasm_class)
    check_arguments(my, "return, wasm_method, wasm_class", my)

    new wasm_return to my.wasm_method
        .name = "dataResult"

        wasm_map_instance_type(my.return, wasm_return)

        wasm_return.code_on_initialize = "
            //  Create C structure vsc_data_t.
            const dataResultCtxSize = Module._vsc_data_ctx_size();
            const dataResultCtxPtr = Module._malloc(dataResultCtxSize);
        "

        wasm_return.code_on_success = "
            const dataResultSize = Module._vsc_data_len(dataResultCtxPtr);
            const dataResultPtr = Module._vsc_data_bytes(dataResultCtxPtr);
            const dataResult = Module.HEAPU8.slice(dataResultPtr, dataResultPtr + dataResultSize);
        "

        wasm_return.code_on_finalize = "
            Module._free(dataResultCtxPtr);
        "

        my.wasm_method.c_arg_list += "dataResultCtxPtr" + ", "
    endnew
endfunction

# ---------------------------------------------------------------------------
function wasm_create_method_return_for_disown_buffer(return, wasm_method, wasm_class)
    check_arguments(my, "return, wasm_method, wasm_class", my)
    .name = "bufferResult"

    new wasm_return to my.wasm_method
        .name = "bufferResult"

        wasm_map_instance_type(my.return, wasm_return)

        wasm_return.code_on_initialize = "
            let proxyResult;
        "

        wasm_return.code_on_success = "
            const bufferResultLen = Module._vsc_buffer_len(proxyResult);
            const bufferResultPtr = Module._vsc_buffer_bytes(proxyResult);
            const bufferResult = Module.HEAPU8.slice(bufferResultPtr, bufferResultPtr + bufferResultLen);
        "

        wasm_return.code_on_finalize = "
            Module._vsc_buffer_delete(proxyResult);
        "
    endnew
endfunction

# ---------------------------------------------------------------------------
function wasm_create_method_return_for_class(return, wasm_method, wasm_class)
    check_arguments(my, "return, wasm_method, wasm_class", my)

    new wasm_return to my.wasm_method
        .name = "jsResult"

        wasm_map_instance_type(my.return, wasm_return)

        wasm_return.code_on_initialize = "
            let proxyResult;
        "

        my.instance_class = wasm_derive_instance_class(my.return)
        my.instance_modules = (my.instance_class <> my.wasm_class.name) ?? "modules." ?
        if string_in(my.return.access, "disown, retain")
            wasm_return.code_on_success = "
                const jsResult = $(my.instance_modules?:)$(my.instance_class:).newAndTakeCContext(proxyResult);
            "
        else
            wasm_return.code_on_success = "
                const jsResult = $(my.instance_modules?:)$(my.instance_class:).newAndUseCContext(proxyResult);
            "
        endif
    endnew
endfunction

# ---------------------------------------------------------------------------
function wasm_create_method_return_for_interface(return, wasm_method, wasm_class, wasm_project)
    check_arguments(my, "return, wasm_method, wasm_class, wasm_project", my)

    new wasm_return to my.wasm_method
        .name = "jsResult"

        wasm_map_instance_type(my.return, wasm_return)

        wasm_return.code_on_initialize = "
            let proxyResult;
        "

        my.instance_class = wasm_derive_interface_wrapper_class_name(my.return, my.wasm_project)
        if string_in(my.return.access, "disown, retain")
            wasm_return.code_on_success = "
                const jsResult = modules.$(my.instance_class:).newAndTakeCContext(proxyResult);
            "
        else
            wasm_return.code_on_success = "
                const jsResult = modules.$(my.instance_class:).newAndUseCContext(proxyResult);
            "
        endif
    endnew
endfunction

# ---------------------------------------------------------------------------
function wasm_create_method_return_for_enum(return, wasm_method, wasm_class)
    check_arguments(my, "return, wasm_method, wasm_class", my)

    new wasm_return to my.wasm_method
        .name = "proxyResult"

        wasm_map_instance_type(my.return, wasm_return)

        wasm_return.code_on_initialize = "
            let proxyResult;
        "
    endnew
endfunction


# ---------------------------------------------------------------------------
#   Create class method as <wasm_method/>.
# ---------------------------------------------------------------------------
function wasm_create_class_method(method, class, wasm_class, wasm_project)
    check_arguments(my, "method, class, wasm_class, wasm_project", my)

    new wasm_method to my.wasm_class
        . = wasm_format_description(my.method) ?
        .name = wasm_derive_method_name(my.method)
        .interface = my.method.interface ? #   When method comes from an interface.

        .c_method = "Module._$(class_derive_c_method(my.class, my.method))"
        .c_arg_list = ""

        if ! defined(my.method.interface)
            #   Method can be static only if it doesn't come from an interface.
            .is_static = my.method.is_static ?
        endif

        #
        #   Return values SHOULD be proceeded first to be able pass
        #   pointer to vsc_data_t as first argument to a proxy call.
        #
        #   Wrap return:
        #       - [x] Wrap primitive type
        #       - [x] Wrap class "data"
        #       - [x] Wrap class "buffer"
        #           - [x] disown
        #       - [x] Wrap class
        #           - [x] readonly
        #           - [x] readwrite
        #           - [x] disown
        #           - [x] retain
        #       - [x] Wrap impl
        #           - [x] readonly
        #           - [x] readwrite
        #           - [x] disown
        #           - [x] retain
        #       - [x] Wrap interface
        #           - [x] readonly
        #           - [x] readwrite
        #           - [x] disown
        #           - [x] retain
        #       - [x] Wrap enum "status"
        #
        for my.method.return where ! wrapper_instance_is_status(return)
            if defined(return.type)
                wasm_create_method_return_for_primitive_type(return, wasm_method, my.wasm_class)

            elsif string_equal(return.class, "data")
                wasm_create_method_return_for_data(return, wasm_method, my.wasm_class)

            elsif string_equal(return.class, "buffer") & return.access = "disown"
                wasm_create_method_return_for_disown_buffer(return, wasm_method, my.wasm_class)

            elsif defined(return.class) | defined(return.impl)
                wasm_create_method_return_for_class(return, wasm_method, my.wasm_class)

            elsif defined(return.interface)
                wasm_create_method_return_for_interface(return, wasm_method, my.wasm_class, my.wasm_project)

            elsif defined(return.enum)
                wasm_create_method_return_for_enum(return, wasm_method, my.wasm_class)
            else
                my.return_dump = component_instance_dump(return)
                echo_fatal("Unexpected return:  $(my.return_dump:)", my)
            endif
        endfor

        #
        #   Add this context.
        #
        if is_false(my.method.is_static)
            wasm_method.c_arg_list += "this.ctxPtr, "

            new wasm_precondition to wasm_method
                . = wasm_derive_ctx_precondition("this.ctxPtr")
            endnew
        endif

        #
        #   Wrap arguments:
        #       - [x] Wrap primitive types.
        #       - [x] Wrap class "data"
        #       - [x] Wrap class "buffer"
        #           - [x] writeonly
        #           - [x] readwrite
        #       - [x] Wrap class
        #           - [x] readonly
        #           - [x] readwrite
        #           - [x] retain
        #           - [x] disown (not supported)
        #       - [x] Wrap impl
        #           - [x] readonly
        #           - [x] readwrite
        #           - [x] retain
        #           - [x] disown (not supported)
        #       - [x] Wrap interface
        #           - [x] readonly
        #           - [x] readwrite
        #           - [x] retain
        #           - [x] disown (not supported)
        #       - [x] Wrap enum
        #           - [x] readonly
        #       - [x] Wrap class "error"
        #           - [x] readwrite
        #
        for my.method.argument
            if defined(argument.type) & is_false(argument.is_reference)
                wasm_create_method_argument_for_primitive_type(argument, wasm_method, my.wasm_class, my.wasm_project)

            elsif string_equal(argument.class, "data")
                wasm_create_method_argument_for_data(argument, wasm_method, my.wasm_class, my.wasm_project)

            elsif string_equal(argument.class, "buffer") & argument.access = "writeonly"
                wasm_create_method_return_for_writeonly_buffer(argument, wasm_method, my.wasm_class, my.wasm_project)

            elsif string_equal(argument.class, "buffer") & argument.access = "readwrite"
                wasm_create_method_argument_for_readwrite_buffer(argument, wasm_method, my.wasm_class, my.wasm_project)

            elsif string_equal(argument.class, "buffer") & argument.access = "readonly"
                echo_fatal("Buffers with readonly access are prohibited.", my)

            elsif string_equal(argument.class, "error") & argument.access = "readwrite"
                wasm_create_method_argument_for_class_error(argument, wasm_method, my.wasm_class, my.wasm_project)

            elsif defined(argument.class) | defined(argument.impl)
                wasm_create_method_argument_for_class(argument, wasm_method, my.wasm_class, my.wasm_project)

            elsif defined(argument.interface)
                wasm_create_method_argument_for_interface(argument, wasm_method, my.wasm_class, my.wasm_project)

            elsif defined(argument.enum)
                wasm_create_method_argument_for_enum(argument, wasm_method, my.wasm_class, my.wasm_project)
            else
                my.argument_dump = component_instance_dump(argument)
                echo_fatal("Unexpected argument:  $(my.argument_dump:)", my)
            endif
        endfor


        #
        #   Create method body.
        #

        #   Initialize locals.
        my.code = ""
        my.code += wasm_format_prconditions(wasm_method) ? ""

        for wasm_method.wasm_argument where defined(wasm_argument.code_on_initialize)
            my.code += terminator + format_left(wasm_argument.code_on_initialize)
        endfor

        for wasm_method.wasm_return where defined(wasm_return.code_on_initialize)
            my.code += terminator + format_left(wasm_return.code_on_initialize)
        endfor

        my.c_arg_list = string_rtrim_symbol(wasm_method.c_arg_list, ",")

        if wrapper_is_method_return_status(my.method)
            my.return_statement = "const proxyResult = "
        elsif count(my.method.return, !wrapper_is_class_returned_by_value(return))
            my.return_statement = "proxyResult = "
        endif

        #   Proxy invocation.
        my.has_finalizer = count(wasm_method.wasm_argument, defined(wasm_argument.code_on_finalize)) + \
                           count(wasm_method.wasm_return, defined(wasm_return.code_on_finalize))

        my.proxy_indent = my.has_finalizer ?? 1 ? 0

        if my.has_finalizer
            my.code += terminator + format_left("try {")
        endif
        my.code += format_left("
            $(my.return_statement?:)$(wasm_method.c_method:)($(my.c_arg_list:));
        ", my.proxy_indent)

        #   Handle errors.
        my.status_return = my.method->return(string_equal(return.enum, "status")) ?
        if defined(my.status_return)
            my.class_error_name = wasm_derive_error_class_name_from_instance(my.status_return, my.wasm_project)
            my.code += format_left("
                modules.$(my.class_error_name:).handleStatusCode(proxyResult);
            ", my.proxy_indent)
        endif

        for wasm_method.wasm_argument where defined(wasm_argument.code_on_success)
            my.code += terminator + format_left(wasm_argument.code_on_success, my.proxy_indent)
        endfor

        for wasm_method.wasm_return where defined(wasm_return.code_on_success)
            my.code += terminator + format_left(wasm_return.code_on_success, my.proxy_indent)
        endfor

        #   Return result.
        for wasm_method.wasm_return
            my.return_list ?= ""
            my.return_list += wasm_return.name ? "proxyResult"
            if ! last()
                my.return_list += ", "
            endif
        endfor

        if count(wasm_method.wasm_return) = 1
            my.code += format_left("return $(my.return_list:);", my.proxy_indent)
        elsif count(wasm_method.wasm_return) > 1
            my.code += format_left("return { $(my.return_list:) };", my.proxy_indent)
        endif

        #   Cleanup.
        if my.has_finalizer
            my.code += format_left("} finally {")

            for wasm_method.wasm_argument where defined(wasm_argument.code_on_finalize)
                my.code += format_left(wasm_argument.code_on_finalize, my.proxy_indent)
            endfor

            for wasm_method.wasm_return where defined(wasm_return.code_on_finalize)
                my.code += format_left(wasm_return.code_on_finalize, my.proxy_indent)
            endfor

            my.code += format_left("}")
        endif

        #   Assign code.
        new wasm_code to wasm_method
            . = (my.code = "") ?? "//  TODO: Implement me." ? my.code
        endnew
    endnew

    new wasm_imported_function to my.wasm_class
        .name = class_derive_c_method(my.class, my.method)
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create class custom constructor.
# ---------------------------------------------------------------------------
function wasm_create_class_constructor(class, constructor, wasm_class, wasm_project)
    check_arguments(my, "class, constructor, wasm_class, wasm_project", my)

    my.method = item_copy_to(my.constructor, my.wasm_class, "method")
    my.method.name = "new $(my.method.name:)"
    my.method.is_static = "1"
    new return to my.method
        .class = my.class.name
        .access = "disown"
        .is_reference = "1"
    endnew

    wasm_create_class_method(my.method, my.class, my.wasm_class, my.wasm_project)

    delete my.method
endfunction

# ---------------------------------------------------------------------------
#   Create single <wasm_imported_module/> entry.
# ---------------------------------------------------------------------------
function wasm_create_imported_module(ext_wasm_module, ext_wasm_project, wasm_project)
    check_arguments(my, "ext_wasm_module, ext_wasm_project, wasm_project", my)

    new wasm_imported_module to my.wasm_project
        .name = my.ext_wasm_module.name
        .source_dir = cat_path("..", my.ext_wasm_project.name)

        for my.ext_wasm_module.wasm_class
            for wasm_class.wasm_imported_function
                copy wasm_imported_function to wasm_imported_module
            endfor
        endfor
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create <wasm_imported_module/> entries.
# ---------------------------------------------------------------------------
function wasm_create_project_imported_classes(project, wasm_project, wrapper)
    check_arguments(my, "project, wasm_project, wrapper", my)

    for my.project.require where defined(0.project) & 0.project <> "common" & 0.feature = "library"
        my.imported_wasm_project = wrapper_find_project(my.wrapper, require.project)

        if count(require.require)
            #   Import helper modules as well.
            if defined(my.imported_wasm_project.error_class_name)
                my.name = my.imported_wasm_project.error_class_name
                my.imported_module = my.imported_wasm_project->wasm_module(name = my.name)
                wasm_create_imported_module(my.imported_module, my.imported_wasm_project, my.wasm_project)
            endif

            if defined(my.imported_wasm_project.interface_class_name)
                my.name = my.imported_wasm_project.interface_class_name
                my.imported_module = my.imported_wasm_project->wasm_module(name = my.name)
                wasm_create_imported_module(my.imported_module, my.imported_wasm_project, my.wasm_project)
            endif

            if defined(my.imported_wasm_project.interface_enum_tag_name)
                my.name = my.imported_wasm_project.interface_enum_tag_name
                my.imported_module = my.imported_wasm_project->wasm_module(name = my.name)
                wasm_create_imported_module(my.imported_module, my.imported_wasm_project, my.wasm_project)
            endif

            if defined(my.imported_wasm_project.impl_tag_enum_name)
                my.name = my.imported_wasm_project.impl_tag_enum_name
                my.imported_module = my.imported_wasm_project->wasm_module(name = my.name)
                wasm_create_imported_module(my.imported_module, my.imported_wasm_project, my.wasm_project)
            endif

            #   Import only specified classes.
            for require.require as inner_require where defined(inner_require.impl)
                my.name = wasm_derive_class_name_str(inner_require.impl)
                my.imported_module = my.imported_wasm_project->wasm_module(name = my.name)
                wasm_create_imported_module(my.imported_module, my.imported_wasm_project, my.wasm_project)
            endfor

            for require.require as inner_require where defined(inner_require.class)
                my.name = wasm_derive_class_name_str(inner_require.class)
                my.imported_module = my.imported_wasm_project->wasm_module(name = my.name)
                wasm_create_imported_module(my.imported_module, my.imported_wasm_project, my.wasm_project)
            endfor

            for require.require as inner_require where defined(inner_require.enum)
                my.name = wasm_derive_enum_name_str(inner_require.enum)
                my.imported_module = my.imported_wasm_project->wasm_module(name = my.name)
                wasm_create_imported_module(my.imported_module, my.imported_wasm_project, my.wasm_project)
            endfor
        else
            #   Import all.
            for my.imported_wasm_project.wasm_module
                wasm_create_imported_module(wasm_module, my.imported_wasm_project, my.wasm_project)
            endfor
        endif

        for my.imported_wasm_project.wasm_imported_function
            copy wasm_imported_function to my.wasm_project
        endfor
    endfor
endfunction


# ===========================================================================
#   Module creation.
# ===========================================================================

#  --------------------------------------------------------------------------
function wasm_resolve_wrapper(wrapper)
    check_arguments(my, "wrapper", my)

endfunction

#  --------------------------------------------------------------------------
function wasm_create_project_module(project, wrapper)
    check_arguments(my, "project, wrapper", my)

    new wasm_project to my.wrapper
        . = my.project. ? "Project $(my.project.name:)."
        .name = my.project.name
        .prefix = my.project.prefix
        .lib_name = "lib$(0.name:c)"
        .asmjs_lib_name = "lib$(0.name:c).asmjs"
        .module_name = "$(0.name:Pascal)Module"
        .description = string_to_singleline(wasm_project)
        .source_dir = cat_path(my.wrapper.source_dir, 0.name)
        .src_source_dir = cat_path(my.wrapper.source_dir, 0.name, "src")
        if count(my.project.enum, name = "status")
            .error_class_name = wasm_derive_error_class_name(wasm_project)
        endif
        if count(my.project.interface)
            .interface_class_name = wasm_derive_class_name_str(cat(wasm_project.name, "interface"))
            .interface_enum_tag_name = wasm_derive_class_name_str(cat(wasm_project.name, "interface tag"))
        endif
        if count(my.project.implementor)
            .impl_tag_enum_name = wasm_derive_class_name_str(cat(wasm_project.name, "impl tag"))
        endif
        .cmake_wasm_target = 0.lib_name
        .cmake_c_target = my.project.cmake_target
        .cmake_c_export_target = my.project.cmake_export_target
        .cmake_c_enable_option = my.project.cmake_enable_option

        copy my.project->license to wasm_project

        wasm_create_project_imported_classes(my.project, wasm_project, my.wrapper)

        return wasm_project
    endnew
endfunction

#  --------------------------------------------------------------------------
function wasm_create_interface_module(interface, wasm_project, meta)
    check_arguments(my, "interface, wasm_project, meta", my)

    #   Nothing to do here.
endfunction

# ---------------------------------------------------------------------------
#   Create language specific module that will represent implementation.
# ---------------------------------------------------------------------------
function wasm_create_implementation_module(impl, wasm_project, meta)
    check_arguments(my, "impl, wasm_project, meta", my)

    assert_attribute(my.impl, "name", my)

    echo_info("Create <wasm_module/> from implementation: '$(my.impl.name:)'", my)

    new wasm_module to my.wasm_project
        .name = wasm_derive_module_name(my.impl)
        .source_file_name = 0.name + ".js"
        .source_file_path = cat_path(my.wasm_project.src_source_dir, 0.source_file_name)

        new wasm_license to wasm_module
            . = wasm_format_license(my.wasm_project->license) ?
        endnew

        new wasm_require to wasm_module
            .name = "precondition"
            .require = "./precondition"
        endnew

        new wasm_class to wasm_module
            . = wasm_format_description(my.impl) ?
            .name = wasm_derive_class_name(my.impl)

            for my.impl.constant where wrapper_should_wrap_class_constant(constant)
                wasm_create_class_constant(constant, wasm_class)
            endfor

            if my.impl.context <> "none" & my.impl.lifecycle <> "none"
                wasm_create_class_default_constructor(my.impl, wasm_class)
                wasm_create_class_constructors_with_c_context(my.impl, wasm_class)
                wasm_create_class_destructor(my.impl, wasm_class)

                for my.impl.constructor where wrapper_should_wrap_method(constructor)
                    wasm_create_class_constructor(my.impl, constructor, wasm_class, my.wasm_project)
                endfor
            endif

            for my.impl.dependency
                wasm_create_class_dependency_method(dependency, my.impl, wasm_class, my.wasm_project)
            endfor

            for my.impl.interface
                for interface.constant
                    wasm_create_class_constant(constant, wasm_class)
                endfor

                for interface.method
                    wasm_create_class_method(method, my.impl, wasm_class, my.wasm_project)
                endfor
            endfor

            for my.impl.method where wrapper_should_wrap_method(method)
                wasm_create_class_method(method, my.impl, wasm_class, my.wasm_project)
            endfor
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create language specific module that will represent class.
# ---------------------------------------------------------------------------
function wasm_create_class_module(class, wasm_project, meta)
    check_arguments(my, "class, wasm_project, meta", my)

    assert_attribute(my.class, "name", my)

    if my.class.name = "error"
        #
        #   Do not generate classes that can be mapped to the built-in types.
        #   Just add imported functions.
        new wasm_imported_function to my.wasm_project
            .name = class_error_derive_c_method_ctx_size()
        endnew

        new wasm_imported_function to my.wasm_project
            .name = class_error_derive_c_method_status()
        endnew

        new wasm_imported_function to my.wasm_project
            .name = class_error_derive_c_method_reset()
        endnew

        return
    endif

    echo_info("Create <wasm_module/> from class: '$(my.class.name:)'", my)

    new wasm_module to my.wasm_project
        .name = wasm_derive_module_name(my.class)
        .source_file_name = 0.name + ".js"
        .source_file_path = cat_path(my.wasm_project.src_source_dir, 0.source_file_name)

        new wasm_license to wasm_module
            . = wasm_format_license(my.wasm_project->license) ?
        endnew

        new wasm_require to wasm_module
            .name = "precondition"
            .require = "./precondition"
        endnew

        new wasm_class to wasm_module
            . = wasm_format_description(my.class) ?
            .name = wasm_derive_class_name(my.class)

            for my.class.constant where wrapper_should_wrap_class_constant(constant)
                wasm_create_class_constant(constant, wasm_class)
            endfor

            if my.class.context <> "none" & my.class.lifecycle <> "none"
                wasm_create_class_default_constructor(my.class, wasm_class)
                wasm_create_class_constructors_with_c_context(my.class, wasm_class)
                wasm_create_class_destructor(my.class, wasm_class)

                for my.class.constructor where wrapper_should_wrap_method(constructor)
                    wasm_create_class_constructor(my.class, constructor, wasm_class, my.wasm_project)
                endfor
            endif

            for my.class.dependency
                wasm_create_class_dependency_method(dependency, my.class, wasm_class, my.wasm_project)
            endfor

            for my.class.method where wrapper_should_wrap_method(method)
                wasm_create_class_method(method, my.class, wasm_class, my.wasm_project)
            endfor
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create module with WebAssembly error from the "status" enum.
# ---------------------------------------------------------------------------
function wasm_create_error_module(enum, wasm_project, meta)
    check_arguments(my, "enum, wasm_project, meta", my)

    echo_info("Create <wasm_module/> with errors from enum: '$(my.enum.name:)'", my)

    assert_attribute(my.enum, "name", my)

    new wasm_module to my.wasm_project
        .name = my.wasm_project.error_class_name
        .source_file_name = 0.name + ".js"
        .source_file_path = cat_path(my.wasm_project.src_source_dir, 0.source_file_name)

        new wasm_license to wasm_module
            . = wasm_format_license(my.wasm_project->license) ?
        endnew

        new wasm_class to wasm_module
            . = wasm_format_description(my.enum) ?
            .name = my.wasm_project.error_class_name
            .extends = "Error"

            new wasm_constructor to wasm_class
                new wasm_argument to wasm_constructor
                    .name = "message"
                endnew

                new wasm_code to wasm_constructor
                    . = "
                        super(message);
                        this.name = '$(wasm_class.name:)';
                        this.message = message;
                    "
                endnew
            endnew

            new wasm_method to wasm_class
                . = "
                    /**
                     * Throw exception of this class with a message that corresponds to the given status code.
                     */
                "
                .name = "handleStatusCode"
                .is_static = "1"

                new wasm_argument to wasm_method
                    .name = "statusCode"
                endnew

                new wasm_code to wasm_method
                    for my.enum.constant
                        my.status_check ?= ""
                        if constant.name = "success"
                            my.status_check += terminator + format_left("
                                if (statusCode == $(constant.value:)) {
                                    return;
                                }
                            ")
                        else
                            my.status_check += terminator + format_left("
                                if (statusCode == $(constant.value:)) {
                                    throw new $(wasm_class.name:)(\"$(enum_constant_format_oneline_description(constant))\");
                                }
                            ")
                        endif
                    endfor
                    my.status_check += terminator + format_left("
                        throw new $(wasm_class.name:)(\"Unexpected status code:\" + statusCode);
                    ")
                    . = my.status_check
                endnew
            endnew
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create module with WebAssembly enum from the abstract 'enum' notion.
# ---------------------------------------------------------------------------
function wasm_create_enum_module(enum, wasm_project, meta)
    check_arguments(my, "enum, wasm_project, meta", my)

    echo_info("Create <wasm_module/> from enum: '$(my.enum.name:)'", my)

    assert_attribute(my.enum, "name", my)

    if my.enum.name = "status"
        wasm_create_error_module(my.enum, my.wasm_project, my.meta)
        return
    endif

    new wasm_module to my.wasm_project
        .name = wasm_derive_module_name(my.enum)
        .source_file_name = 0.name + ".js"
        .source_file_path = cat_path(my.wasm_project.src_source_dir, 0.source_file_name)

        new wasm_license to wasm_module
            . = wasm_format_license(my.wasm_project->license) ?
        endnew

        new wasm_enum to wasm_module
            . = wasm_format_description(my.enum) ?
            .name = wasm_derive_enum_name(my.enum)

            for my.enum.constant
                my.constant_value ?= "0"
                if defined(my.constant.value)
                    my.constant_value = my.constant.value
                endif

                wasm_create_enum_constant(constant, my.constant_value, wasm_enum)

                if ! defined(my.constant.value)
                    my.constant_value += 1
                endif
            endfor
        endnew
    endnew
endfunction

#  --------------------------------------------------------------------------
function wasm_module_resolve(wasm_module, wasm_project)
    check_arguments(my, "wasm_module, wasm_project", my)

endfunction

#  --------------------------------------------------------------------------
function wasm_create_toplevel_modules(wrapper)
    check_arguments(my, "wrapper", my)

endfunction


# ===========================================================================
#   Custom module creation.
# ===========================================================================

# ---------------------------------------------------------------------------
#   Create module describing "index.js".
# ---------------------------------------------------------------------------
function wasm_create_entrypoint_module(wasm_project)
    check_arguments(my, "wasm_project", my)

    echo_info("Create custom <wasm_module/>: 'index'", my)

    new wasm_module to my.wasm_project
        .name = "index"
        .source_file_name = "$(0.name).js"
        .source_file_path = cat_path(my.wasm_project.src_source_dir, 0.source_file_name)

        new wasm_license to wasm_module
            . = wasm_format_license(my.wasm_project->license) ?
        endnew

        my.module_inst = "$(my.wasm_project.name:Camel)Module"

        my.code = ""
        my.code += format_left("
            const $(my.wasm_project.module_name:) = require(process.env.PROJECT_MODULE);
        ")

        my.code += terminator

        for my.wasm_project.wasm_imported_module
            my.code += format_left("
                const init$(wasm_imported_module.name:Pascal) = \
                        require('$(wasm_imported_module.source_dir)/$(wasm_imported_module.name:)');
            ")

            my.init_code ?= ""
            my.init_code += format_left("
                  modules.$(wasm_imported_module.name:Pascal) =\
                        init$(wasm_imported_module.name:Pascal)($(my.module_inst:), modules);
            ")
        endfor

        for my.wasm_project.wasm_module where wasm_module_is_not_helper(wasm_module)
            my.code += format_left("
                const init$(wasm_module.name:Pascal) = require('./$(wasm_module.name:)');
            ")

            my.init_code ?= ""
            my.init_code += format_left("
                  modules.$(wasm_module.name:Pascal) = init$(wasm_module.name:Pascal)($(my.module_inst:), modules);
            ")
        endfor

        my.code += terminator + format_left("
            const initProject = options => {
                return new Promise((resolve, reject) => {

                    $(my.wasm_project.module_name:)(options).then($(my.module_inst:) => {
                        const modules = {};
                        $(format_left(my.init_code, 6))
                        resolve(modules);
                    }).catch(error => {
                        reject(error);
                    });

                });
            };
            module.exports = initProject;
        ")

        new wasm_code to wasm_module
            . = my.code
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create a class that takes a generic C interface type, aka vscf_impl_t,
#   and create correspond specific JS class.
# ---------------------------------------------------------------------------
function wasm_create_interface_wrapper_module(source, wasm_project)
    check_arguments(my, "source, wasm_project", my)

    new wasm_module to my.wasm_project
        .name = my.wasm_project.interface_class_name
        .source_file_name = 0.name + ".js"
        .source_file_path = cat_path(my.wasm_project.src_source_dir, 0.source_file_name)

        new wasm_license to wasm_module
            . = wasm_format_license(my.wasm_project->license) ?
        endnew

        new wasm_class to wasm_module
            .name = my.wasm_project.interface_class_name

            wasm_create_custom_interface_class_constructors(my.source, wasm_class, my.wasm_project)
            wasm_create_custom_interface_class_helpers(my.source, wasm_class, my.wasm_project)
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create an enumeration with available interfaces.
# ---------------------------------------------------------------------------
function wasm_create_interface_tag_module(source, wasm_project)
    check_arguments(my, "source, wasm_project", my)

    new wasm_module to my.wasm_project
        .name = my.wasm_project.interface_enum_tag_name
        .source_file_name = 0.name + ".js"
        .source_file_path = cat_path(my.wasm_project.src_source_dir, 0.source_file_name)

        new wasm_license to wasm_module
            . = wasm_format_license(my.wasm_project->license) ?
        endnew

        new wasm_enum to wasm_module
            .name = my.wasm_project.interface_enum_tag_name

            for my.source.interface by name
                my.interface_tag_value ?= "1"
                new wasm_constant to wasm_enum
                    .name = wasm_derive_constant_name(interface)
                    .value = my.interface_tag_value
                endnew
                my.interface_tag_value += 1
            endfor
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create an enumeration with all possibles implementation tags.
#   JS representation of the enum "impl tag", aka vscf_impl_tag_t.
# ---------------------------------------------------------------------------
function wasm_create_impl_tag_module(source, wasm_project)
    check_arguments(my, "source, wasm_project", my)

    new wasm_module to my.wasm_project
        .name = my.wasm_project.impl_tag_enum_name
        .source_file_name = 0.name + ".js"
        .source_file_path = cat_path(my.wasm_project.src_source_dir, 0.source_file_name)

        new wasm_license to wasm_module
            . = wasm_format_license(my.wasm_project->license) ?
        endnew

        new wasm_enum to wasm_module
            .name = my.wasm_project.impl_tag_enum_name

            for my.source.implementation as impl by impl.name
                my.counter ?= 1
                if impl.scope = "public"
                    new wasm_constant to wasm_enum
                        .name = wasm_derive_constant_name_str(impl.name)
                        .value = my.counter
                    endnew
                endif
                my.counter += 1
            endfor
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create module with JSON array of exported functions.
# ---------------------------------------------------------------------------
function wasm_create_exported_functions_module(wasm_project)
    check_arguments(my, "wasm_project", my)

    echo_info("Create custom <json_module/>: 'exported functions'", my)

    new json_module to my.wasm_project
        .name = "exported_functions"
        .source_file_name = 0.name + ".json"
        .source_file_path = cat_path(my.wasm_project.source_dir, 0.source_file_name)

        my.code = ""
        my.code += format_left('
            [
                "_malloc",
                "_free",
                "_vsc_data",
                "_vsc_data_ctx_size",
                "_vsc_data_bytes",
                "_vsc_data_len",
                "_vsc_buffer_new",
                "_vsc_buffer_new_with_capacity",
                "_vsc_buffer_delete",
                "_vsc_buffer_make_secure",
                "_vsc_buffer_bytes",
                "_vsc_buffer_data",
                "_vsc_buffer_len",
        ')

        my.container = XML.new("container")

        for my.wasm_project.wasm_imported_module
            for wasm_imported_module.wasm_imported_function
                copy wasm_imported_function to my.container
            endfor
        endfor

        for my.wasm_project.wasm_imported_function
            copy wasm_imported_function to my.container
        endfor

        for my.wasm_project.wasm_module
            for wasm_module.wasm_class
                for wasm_class.wasm_imported_function
                    copy wasm_imported_function to my.container
                endfor
            endfor
        endfor

        for my.container.wasm_imported_function
            my.sep = !last() ?? "," ?
            my.code += format_left('
                "_$(wasm_imported_function.name:)"$(my.sep?)
            ', 1)
        endfor

        delete my.container

        my.code += format_left(']')

        new json_code to json_module
            . = my.code
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create project CMakeLists.txt file.
# ---------------------------------------------------------------------------
function wasm_create_project_cmake_module(wasm_project)
    check_arguments(my, "wasm_project", my)

    new cmake_module to my.wasm_project
        .name = "CMakeLists"
        .source_file_name = 0.name + ".txt"
        .source_file_path = cat_path(my.wasm_project.source_dir, 0.source_file_name)

        new cmake_license to cmake_module
            . = cmake_format_license(my.wasm_project->license)
        endnew

        new cmake_code
            . = format_left('
                cmake_minimum_required(VERSION 3.12 FATAL_ERROR)

                project(virgil_crypto_$(my.wasm_project.cmake_c_target:)_wasm \
                        VERSION ${virgil_crypto_VERSION} LANGUAGES C)

                # ---------------------------------------------------------------------------
                #   Check dependencies
                # ---------------------------------------------------------------------------
                if(NOT $(my.wasm_project.cmake_c_enable_option:))
                    message(STATUS "Skip building the WebAssembly wrapper for \
                            library $(my.wasm_project.cmake_c_target:), which is not built.")
                    return()
                endif()

                # ---------------------------------------------------------------------------
                #   Find utils
                # ---------------------------------------------------------------------------
                find_host_program(WASM2WAT wasm2wat)

                # ---------------------------------------------------------------------------
                #   Common steps for all WebAssembly libraries.
                # ---------------------------------------------------------------------------
                file(WRITE "${CMAKE_CURRENT_BINARY_DIR}/fake.c" "")

                function(wasm_add_common_wasm_options target)
                    target_sources(${target} PRIVATE "${CMAKE_CURRENT_BINARY_DIR}/fake.c")
                    target_sources(${target} PRIVATE "${CMAKE_CURRENT_LIST_DIR}/exported_functions.json")
                    target_link_libraries(${target}
                            "-s WASM=1"
                            "-s ALLOW_MEMORY_GROWTH=1"
                            "-s EXPORTED_FUNCTIONS=\\\\"@${CMAKE_CURRENT_LIST_DIR}/exported_functions.json\\\\""
                            "-s MODULARIZE=1"
                            "-s EXPORT_NAME=$(my.wasm_project.module_name:)"
                            "$<$<CONFIG:Release>:--llvm-lto 1 -Os --closure 1>"
                            "$<$<CONFIG:Debug>:--emrun>"
                            $(my.wasm_project.cmake_c_export_target:)
                            )
                endfunction()

                function(wasm_add_common_asmjs_options target)
                    target_sources(${target} PRIVATE "${CMAKE_CURRENT_BINARY_DIR}/fake.c")
                    target_sources(${target} PRIVATE "${CMAKE_CURRENT_LIST_DIR}/exported_functions.json")
                    target_link_libraries(${target}
                            "-s WASM=0"
                            "-s SINGLE_FILE=1"
                            "-s EXPORTED_FUNCTIONS=\\\\"@${CMAKE_CURRENT_LIST_DIR}/exported_functions.json\\\\""
                            "-s MODULARIZE=1"
                            "-s EXPORT_NAME=$(my.wasm_project.module_name:)"
                            "$<$<CONFIG:Release>:--llvm-lto 1 -O0>"
                            "$<$<CONFIG:Debug>:--emrun>"
                            $(my.wasm_project.cmake_c_export_target:)
                            )
                endfunction()

                # ---------------------------------------------------------------------------
                #   Create WebAssembly library
                # ---------------------------------------------------------------------------
                add_executable($(my.wasm_project.cmake_wasm_target:))
                wasm_add_common_wasm_options($(my.wasm_project.cmake_wasm_target:))
                target_link_libraries($(my.wasm_project.cmake_wasm_target:)
                        "-s ENVIRONMENT=node"
                        )

                add_executable($(my.wasm_project.cmake_wasm_target:).browser)
                wasm_add_common_wasm_options($(my.wasm_project.cmake_wasm_target:).browser)
                target_link_libraries($(my.wasm_project.cmake_wasm_target:).browser
                        "-s ENVIRONMENT=web"
                        )

                add_executable($(my.wasm_project.cmake_wasm_target:).worker)
                wasm_add_common_wasm_options($(my.wasm_project.cmake_wasm_target:).worker)
                target_link_libraries($(my.wasm_project.cmake_wasm_target:).worker
                        "-s ENVIRONMENT=worker"
                        )

                add_executable($(my.wasm_project.cmake_wasm_target:).asmjs)
                wasm_add_common_asmjs_options($(my.wasm_project.cmake_wasm_target:).asmjs)
                target_link_libraries($(my.wasm_project.cmake_wasm_target:).asmjs
                        "-s ENVIRONMENT=node"
                        )

                add_executable($(my.wasm_project.cmake_wasm_target:).browser.asmjs)
                wasm_add_common_asmjs_options($(my.wasm_project.cmake_wasm_target:).browser.asmjs)
                target_link_libraries($(my.wasm_project.cmake_wasm_target:).browser.asmjs
                        "-s ENVIRONMENT=web"
                        )

                add_executable($(my.wasm_project.cmake_wasm_target:).worker.asmjs)
                wasm_add_common_asmjs_options($(my.wasm_project.cmake_wasm_target:).worker.asmjs)
                target_link_libraries($(my.wasm_project.cmake_wasm_target:).worker.asmjs
                        "-s ENVIRONMENT=worker"
                        )

                add_custom_command(TARGET $(my.wasm_project.cmake_wasm_target:) POST_BUILD
                        COMMAND ${CMAKE_COMMAND} -E copy_directory
                                "${CMAKE_CURRENT_LIST_DIR}/src" "${CMAKE_CURRENT_BINARY_DIR}"
                        )

                if(WASM2WAT)
                    add_custom_command(TARGET $(my.wasm_project.cmake_wasm_target:) POST_BUILD
                            COMMAND "${WASM2WAT}"
                                    $(my.wasm_project.cmake_wasm_target:).wasm
                                    -o $(my.wasm_project.cmake_wasm_target:).wat
                            COMMENT "Create WAT from $(my.wasm_project.cmake_wasm_target:).wasm"
                            )
                endif()
            ')
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create JS with precondition check helpers.
# ---------------------------------------------------------------------------
function wasm_create_precondition_module(wasm_project)
    check_arguments(my, "wasm_project", my)

    new wasm_module to my.wasm_project
        .name = "precondition"
        .source_file_name = 0.name + ".js"
        .source_file_path = cat_path(my.wasm_project.src_source_dir, 0.source_file_name)

        new wasm_license to wasm_module
            . = wasm_format_license(my.wasm_project->license) ?
        endnew

        new wasm_code to wasm_module
            . = "
                function ensureNumber(arg, value) {
                    if (!(typeof value === 'number' || value instanceof Number)) {
                        throw new TypeError(`'${arg}' is not a number`);
                    }
                    if (Number.isNaN(value)) {
                        throw new TypeError(`'${arg}' is NaN`);
                    }
                    if (value === Infinity) {
                        throw new TypeError(`'${arg}' is Infinity`);
                    }
                    if (value === -Infinity) {
                        throw new TypeError(`'${arg}' is -Infinity`);
                    }
                }

                function ensureNotNull(arg, value) {
                    ensureNumber(arg, value);

                    if (value == 0) {
                        throw new TypeError(`'${arg}' is NULL`);
                    }
                }

                function ensureString(arg, value) {
                    if (!(typeof value === 'string' || value instanceof String)) {
                        throw new TypeError(`'${arg}' is not a string`);
                    }
                }

                function ensureBoolean(arg, value) {
                    if (typeof value !== 'boolean') {
                        throw new TypeError(`'${arg}' is not a boolean`);
                    }
                }

                function ensureByteArray(arg, value) {
                    if (!(value instanceof Uint8Array)) {
                        throw new TypeError(`'${arg}' is not an Uint8Array`);
                    }
                }

                function ensureClass(arg, value, cls) {
                    if (!(value instanceof cls)) {
                        throw new TypeError(`'${arg}' is not an instance of the class ${cls.name}`);
                    }
                    ensureNotNull(arg, value.ctxPtr);
                }

                function ensureImplementInterface(arg, value, interfaceName, interfaceTag, interfaceChecker) {
                    ensureNotNull(arg, value.ctxPtr);
                    if (!interfaceChecker.isImplemented(value.ctxPtr, interfaceTag)) {
                        throw new TypeError(`'${arg}' does not implement interface '${interfaceName}'`);
                    }
                }

                module.exports.ensureNumber = ensureNumber;
                module.exports.ensureString = ensureString;
                module.exports.ensureBoolean = ensureBoolean;
                module.exports.ensureByteArray = ensureByteArray;
                module.exports.ensureClass = ensureClass;
                module.exports.ensureNotNull = ensureNotNull;
                module.exports.ensureImplementInterface = ensureImplementInterface;
            "
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create a bunch of custom modules that are not related to the existing
#   high-level models.
# ---------------------------------------------------------------------------
function wasm_create_custom_modules(source, wasm_project, meta)
    check_arguments(my, "source, wasm_project, meta", my)

    wasm_create_project_cmake_module(my.wasm_project)
    wasm_create_precondition_module(my.wasm_project)

    if count(my.source.implementation)
        wasm_create_interface_tag_module(my.source, my.wasm_project)
        wasm_create_interface_wrapper_module(my.source, my.wasm_project)
        wasm_create_impl_tag_module(my.source, my.wasm_project)
    endif
endfunction

# ---------------------------------------------------------------------------
#   Create a bunch of custom modules that are not related to the existing
#   high-level models.
# ---------------------------------------------------------------------------
function wasm_finalize_custom_modules(source, wasm_project, meta)
    check_arguments(my, "source, wasm_project, meta", my)

    wasm_create_exported_functions_module(my.wasm_project)
    wasm_create_entrypoint_module(my.wasm_project)
endfunction

# ---------------------------------------------------------------------------
#   Create toplevel modules:
#       - CMake project files.
# ---------------------------------------------------------------------------
function wasm_create_toplevel_modules(wrapper)
    check_arguments(my, "wrapper", my)

    for my.wrapper.cmake_module
        delete cmake_module
    endfor

    new cmake_module to my.wrapper
        .name = "CMakeLists"
        .source_file_name = 0.name + ".txt"
        .source_file_path = cat_path(my.wrapper.source_dir, 0.source_file_name)

        new cmake_license to cmake_module
            . = cmake_format_license(my.wrapper->license)
        endnew

        my.code = format_left('
            cmake_minimum_required(VERSION 3.12 FATAL_ERROR)

            project(virgil_crypto_wasm VERSION ${virgil_crypto_VERSION} LANGUAGES C)

            # ---------------------------------------------------------------------------
            #   Check Emscripten environment.
            # ---------------------------------------------------------------------------

            if(NOT CMAKE_SYSTEM_NAME STREQUAL "Emscripten")
                message(FATAL_ERROR "Attempt to build WebAssembly without Emscripten toolchain.")
            endif()

            # ---------------------------------------------------------------------------
            #   Configure
            # ---------------------------------------------------------------------------
            configure_file(
                    "${CMAKE_CURRENT_LIST_DIR}/rollup.config.js"
                    "${CMAKE_CURRENT_BINARY_DIR}/rollup.config.js"
                    COPYONLY
                    )

            configure_file(
                    "${CMAKE_CURRENT_LIST_DIR}/package.json"
                    "${CMAKE_CURRENT_BINARY_DIR}/package.json"
                    COPYONLY
                    )

            configure_file(
                    "${CMAKE_CURRENT_LIST_DIR}/jest.config.js"
                    "${CMAKE_CURRENT_BINARY_DIR}/jest.config.js"
                    COPYONLY
                    )

            add_custom_target(copy_wasm_tests ALL
                    COMMAND ${CMAKE_COMMAND} -E copy_directory
                            "${CMAKE_CURRENT_LIST_DIR}/tests" "${CMAKE_CURRENT_BINARY_DIR}/tests"
                    )

            # ---------------------------------------------------------------------------
            #   Add per project wrapper build
            # ---------------------------------------------------------------------------
        ')

        for my.wrapper.wasm_project
            my.code +=format_left('
                add_subdirectory("$(wasm_project.name:)")
            ')
        endfor

        new cmake_code to cmake_module
            . = my.code
        endnew
    endnew
endfunction

.endtemplate
