.template 0
#   Copyright (C) 2015-2021 Virgil Security, Inc.
#
#   All rights reserved.
#
#   Redistribution and use in source and binary forms, with or without
#   modification, are permitted provided that the following conditions are
#   met:
#
#       (1) Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#
#       (2) Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in
#       the documentation and/or other materials provided with the
#       distribution.
#
#       (3) Neither the name of the copyright holder nor the names of its
#       contributors may be used to endorse or promote products derived from
#       this software without specific prior written permission.
#
#   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR
#   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#   DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
#   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
#   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
#   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
#   STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
#   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#   POSSIBILITY OF SUCH DAMAGE.
#
#   Lead Maintainer: Virgil Security Inc. <support@virgilsecurity.com>

# ---------------------------------------------------------------------------
#   This module provides functionality, that transforms 'component' models to
#   the 'c_component' models.
#
#   Note, all 'component' passed models mused be already resolved.
#
#   Private function prefix is: X11.
# ---------------------------------------------------------------------------
#   This is a code generator built using the iMatix GSL code generation
#   language. See https://github.com/zeromq/gsl for details.
# ---------------------------------------------------------------------------


gsl from "common.gsl"
gsl from "component.gsl"
gsl from "c_formatter.gsl"


# ###########################################################################
#   Attribute derivation functions
# ###########################################################################

# ---------------------------------------------------------------------------
#   If attribute 'project' is defined within <instance/> then return project
#   prefix, otherwise return empty string.
# ---------------------------------------------------------------------------
function c_component_derive_instance_project_uid (instance)
    check_arguments (my, "instance", my)

    return defined (my.instance.project) ?? make_id ("project", my.instance.project) ? ""
endfunction

# ---------------------------------------------------------------------------
#   Crate uid based on the given options.
#   Examples:
#       {struct, buffer, buffer} - returns "class_buffer_struct_buffer"
#       {struct, inner/buffer, buffer} - returns "class_inner_struct_buffer"
#       {enum, api/tag,} - returns "class_api_enum_tag"
#       {struct, codes,} - returns "global_struct_codes"
# ---------------------------------------------------------------------------
function c_component_derive_instance_type_uid (type_id, type_value, of_class)
    check_arguments (my, "type_id, type_value", my)

    if regexp.match ("([^\/]+)\/(.+)", my.type_value, my.group1, my.group2)
        my.of_class = my.group1
        my.type_value = my.group2
    endif

    if defined (my.of_class)
        return make_id ("class", my.of_class, my.type_id, my.type_value)

    else
        return make_id ("global", my.type_id, my.type_value)
    endif
endfunction

# ---------------------------------------------------------------------------
#   Derive C style in-project constant full name.
# ---------------------------------------------------------------------------
function c_derive_constant_name (constant)
    check_argument (my, "constant", my)

    component_require_lineage (my.constant, my)
    component_require_attr_c_prefix (my.constant, my)

    return c_format_constant_name (my.constant.c_prefix, component_derive_name_prefix (my.constant), my.constant.name)
endfunction

# ---------------------------------------------------------------------------
#   Derive C style in-project global variable full name.
# ---------------------------------------------------------------------------
function c_derive_variable_name (variable)
    check_argument (my, "variable", my)

    component_require_lineage (my.variable, my)
    component_require_attr_c_prefix (my.variable, my)

    if my.variable.declaration = "public" | my.variable.definition = "external"
        return c_format_name (my.variable.c_prefix, component_derive_full_name (my.variable))
    else
        return c_format_name (my.variable.name)
    endif
endfunction

# ---------------------------------------------------------------------------
#   Derive C style in-project enum full name.
# ---------------------------------------------------------------------------
function c_derive_enum_name (enum)
    check_argument (my, "enum", my)

    component_require_lineage (my.enum, my)
    component_require_attr_c_prefix (my.enum, my)

    return c_format_name (my.enum.c_prefix, component_derive_full_name (my.enum), "t")
endfunction

# ---------------------------------------------------------------------------
#   Derive C style in-project method full name.
# ---------------------------------------------------------------------------
function c_derive_method_name (method)
    check_argument (my, "method", my)

    component_require_lineage (my.method, my)
    component_require_attr_c_prefix (my.method, my)

    return c_format_name (my.method.c_prefix, component_derive_full_name (my.method))
endfunction

# ---------------------------------------------------------------------------
#   Derive C style in-project struct full name.
# ---------------------------------------------------------------------------
function c_derive_struct_name (struct)
    check_argument (my, "struct", my)

    component_require_lineage (my.struct, my)
    component_require_attr_c_prefix (my.struct, my)

    return c_format_name (my.struct.c_prefix, component_derive_full_name (my.struct), "t")
endfunction

# ---------------------------------------------------------------------------
#   Derive C style in-project full name of the argument, property, variable.
# ---------------------------------------------------------------------------
function c_derive_instance_name (instance)
    check_argument (my, "instance", my)

    component_require_lineage (my.instance, my)
    component_require_attr_name (my.instance, my)

    if defined (my.instance.callback)
        my.name = c_format_name (my.instance.name, "cb")
    else
        my.name = c_format_name (my.instance.name)
    endif

    if my.instance.access = "disown"
        my.name += "_ref"
    endif

    return my.name
endfunction

# ---------------------------------------------------------------------------
#   Derive C style in-project macros full name.
# ---------------------------------------------------------------------------
function c_derive_macros_name (macros)
    check_argument (my, "macros", my)

    component_require_lineage (my.macros, my)
    component_require_attr_c_prefix (my.macros, my)

    return c_format_macros_name (my.macros.c_prefix, component_derive_full_name (my.macros))
endfunction

# ---------------------------------------------------------------------------
#   Derive C style in-project callback full name.
# ---------------------------------------------------------------------------
function c_derive_callback_name (callback)
    check_argument (my, "callback", my)

    component_require_lineage (my.callback, my)
    component_require_attr_c_prefix (my.callback, my)

    return c_format_name (my.callback.c_prefix, component_derive_full_name (my.callback), "fn")
endfunction

# ---------------------------------------------------------------------------
#   Derive C integer type correspond to it's size.
#   Size: {1, 2, 4, 8}.
# ---------------------------------------------------------------------------
function c_component_derive_integer_type (size)
    if defined (my.size)
        if my.size = "1"
            return "int8_t"

        elsif my.size = "2"
            return "int16_t"

        elsif my.size = "4"
            return "int32_t"

        elsif my.size = "8"
            return "int64_t"
        else
            echo_fatal ("Unsupported size 'my.size' for C integers", my)
        endif
    else
        return "int"
    endif
endfunction

# ---------------------------------------------------------------------------
#   Derive C unsigned integer type correspond to it's size.
#   Size: {1, 2, 4, 8}.
# ---------------------------------------------------------------------------
function c_component_derive_unsigned_type (size)
    if defined (my.size)
        if my.size = "1"
            return "uint8_t"

        elsif my.size = "2"
            return "uint16_t"

        elsif my.size = "4"
            return "uint32_t"

        elsif my.size = "8"
            return "uint64_t"
        else
            echo_fatal ("Unsupported size 'my.size' for C unsigned integers", my)
        endif
    else
        return "unsigned int"
    endif
endfunction

# ---------------------------------------------------------------------------
#   Return .(c_<uid>) if given value in a format .(<uid>), else return as-is.
# ---------------------------------------------------------------------------
function c_component_wrap_uid (value)
    check_argument (my, "value", my)

    return c_lang_ref (my.value)
endfunction

# ###########################################################################
#   Validate or check attribute
# ###########################################################################

# ---------------------------------------------------------------------------
#   Check required attribute: file.
# ---------------------------------------------------------------------------
function c_component_require_attr_file (c_component, caller)
    check_argument (my, "c_component", my)

    assert_attribute (my.c_component, "file", my.caller ? my)
endfunction

# ---------------------------------------------------------------------------
#   Check required attribute: name.
# ---------------------------------------------------------------------------
function c_component_require_attr_name (c_component, caller)
    check_argument (my, "c_component", my)

    assert_attribute (my.c_component, "name", my.caller ? my)
endfunction

# ---------------------------------------------------------------------------
#   Check required attribute: type.
# ---------------------------------------------------------------------------
function c_component_require_attr_type (c_component, caller)
    check_argument (my, "c_component", my)

    assert_attribute (my.c_component, "type", my.caller ? my)
endfunction

# ---------------------------------------------------------------------------
#   Check required attribute: value.
# ---------------------------------------------------------------------------
function c_component_require_attr_value (c_component, caller)
    check_argument (my, "c_component", my)

    assert_attribute (my.c_component, "value", my.caller ? my)
endfunction


# ###########################################################################
#   Attribute resolution functions
# ###########################################################################

# ---------------------------------------------------------------------------
#   Resolve attribute: scope.
# ---------------------------------------------------------------------------
function c_component_resolve_attr_scope (c_component)
    check_argument (my, "c_component", my)

    my.c_component.scope ?= "public"
endfunction

# ---------------------------------------------------------------------------
#   Resolve attribute: visibility.
# ---------------------------------------------------------------------------
function c_component_resolve_attr_visibility (c_component)
    check_argument (my, "c_component", my)

    my.c_component.visibility ?= "public"
endfunction

# ---------------------------------------------------------------------------
#   Resolve attribute: declaration.
# ---------------------------------------------------------------------------
function c_component_resolve_attr_declaration (c_component)
    check_argument (my, "c_component", my)

    my.c_component.declaration ?= "public"
endfunction

# ---------------------------------------------------------------------------
#   Resolve attribute: definition.
# ---------------------------------------------------------------------------
function c_component_resolve_attr_definition (c_component)
    check_argument (my, "c_component", my)

    my.c_component.definition ?= "private"
endfunction

# ---------------------------------------------------------------------------
#   Resolve attribute: is_system.
# ---------------------------------------------------------------------------
function c_component_resolve_attr_is_system (c_component)
    check_argument (my, "c_component", my)

    my.c_component.is_system ?= "0"
endfunction


# ###########################################################################
#   Item resolution functions
# ###########################################################################

# ---------------------------------------------------------------------------
#   Resolve component: c_include.
# ---------------------------------------------------------------------------
function c_component_resolve_include (c_include)
    check_argument (my, "c_include", my)

    c_component_require_attr_file (my.c_include, my)
    c_component_resolve_attr_definition (my.c_include)
    c_component_resolve_attr_is_system (my.c_include)
endfunction

# ---------------------------------------------------------------------------
#   Resolve component: c_alias.
# ---------------------------------------------------------------------------
function c_component_resolve_alias (c_alias)
    check_argument (my, "c_alias", my)

    c_component_require_attr_name (my.c_alias, my)
    c_component_require_attr_type (my.c_alias, my)
    c_component_resolve_attr_declaration (my.c_alias)
endfunction

# ---------------------------------------------------------------------------
#   Resolve component: c_constant.
# ---------------------------------------------------------------------------
function c_component_resolve_constant (c_constant)
    check_argument (my, "c_constant", my)

    c_component_require_attr_name (my.c_constant, my)
    c_component_resolve_attr_definition (my.c_constant)
endfunction

# ---------------------------------------------------------------------------
#   Resolve component: c_enum.
# ---------------------------------------------------------------------------
function c_component_resolve_enum (c_enum)
    check_argument (my, "c_enum", my)

    c_component_resolve_attr_visibility (my.c_enum)
    c_component_resolve_attr_declaration (my.c_enum)
    c_component_resolve_attr_definition (my.c_enum)

    for my.c_enum.c_constant
        c_component_resolve_constant (c_constant)
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Copy attribute 'scope' from 'component' to 'c_component'.
# ---------------------------------------------------------------------------
function c_component_map_attr_scope (c_component, component)
    check_arguments (my, "c_component, component", my)

    component_require_attr_scope (my.component, my)

    my.c_component.scope = my.component.scope
endfunction

# ---------------------------------------------------------------------------
#   Copy attribute 'visibility' from 'component' to 'c_component'.
# ---------------------------------------------------------------------------
function c_component_map_attr_visibility (c_component, component)
    check_arguments (my, "c_component, component", my)

    component_require_attr_visibility (my.component, my)

    my.c_component.visibility = my.component.visibility
endfunction

# ---------------------------------------------------------------------------
#   Copy attribute 'declaration' from 'component' to 'c_component'.
# ---------------------------------------------------------------------------
function c_component_map_attr_declaration (c_component, component)
    check_arguments (my, "c_component, component", my)

    component_require_attr_declaration (my.component, my)

    my.c_component.declaration = my.component.declaration
endfunction

# ---------------------------------------------------------------------------
#   Copy attribute 'definition' from 'component' to 'c_component'.
# ---------------------------------------------------------------------------
function c_component_map_attr_definition (c_component, component)
    check_arguments (my, "c_component, component", my)

    component_require_attr_definition (my.component, my)

    my.c_component.definition = my.component.definition
endfunction

# ---------------------------------------------------------------------------
#   Copy attribute 'uid' from 'component' to 'c_component'.
# ---------------------------------------------------------------------------
function c_component_map_attr_uid (c_component, component)
    check_arguments (my, "c_component, component", my)

    component_require_attr_uid (my.component, my)

    my.c_component.uid = make_id ("c", my.component.uid)
endfunction


# ---------------------------------------------------------------------------
#   Map optional attribute 'feature' from 'component' to 'c_component'.
# ---------------------------------------------------------------------------
function c_component_map_attr_feature (c_component, component)
    check_arguments (my, "c_component, component", my)

    if ! defined (my.component.feature)
        return
    endif

    component_require_attr_c_prefix (my.component, my)

    my.c_component.feature = c_format_macros_name (my.component.c_prefix, my.component.feature)
endfunction


# ---------------------------------------------------------------------------
#   Define attribute: c_instance.type.
# ---------------------------------------------------------------------------
function c_component_map_instance_attr_type (c_instance, instance)
    check_arguments (my, "c_instance, instance", my)

    if defined (my.instance.type)
        if my.instance.type = "nothing"
            my.c_instance.type = "void"

        elsif my.instance.type = "boolean"
            my.c_instance.type = "bool"

        elsif my.instance.type = "integer"
            my.c_instance.type = c_component_derive_integer_type (my.instance.size ?)

        elsif my.instance.type = "unsigned"
            my.c_instance.type = c_component_derive_unsigned_type (my.instance.size ?)

        elsif my.instance.type = "byte"
            my.c_instance.type = "byte"

        elsif my.instance.type = "size"
            my.c_instance.type = "size_t"

        elsif my.instance.type = "char"
            my.c_instance.type = "char"

        elsif my.instance.type = "varargs"
            my.c_instance.type = "..."

        else
            echo_fatal ("Unsupported instance type '$(my.instance.type)' for C language.", my)
        endif

    elsif defined (my.instance.class)

        if my.instance.class = "any"
            my.c_instance.type = "void"

        elsif is_ref (my.instance.class) | defined (my.instance.library)
            my.c_instance.type = c_lang_ref (my.instance.class)

        else
            my.project_uid = c_component_derive_instance_project_uid (my.instance)
            my.type_uid = c_component_derive_instance_type_uid ("struct", my.instance.class, my.instance.class)
            my.c_instance.type = make_ref_c (make_id(my.project_uid, my.type_uid))
        endif

    elsif defined (my.instance.enum)
        if is_ref (my.instance.enum) | defined (my.instance.library)
            my.c_instance.type = c_lang_ref (my.instance.enum)

        else
            my.project_uid = c_component_derive_instance_project_uid (my.instance)
            my.type_uid = c_component_derive_instance_type_uid ("enum", my.instance.enum, my.instance.enum)
            my.c_instance.type = make_ref_c (make_id(my.project_uid, my.type_uid))
        endif

    elsif defined (my.instance.callback)
        if is_ref (my.instance.callback) | defined (my.instance.library)
            my.c_instance.type = c_lang_ref (my.instance.callback)

        else
            my.project_uid = c_component_derive_instance_project_uid (my.instance)
            my.type_uid = c_component_derive_instance_type_uid ("callback", my.instance.callback, my.instance.callback)
            my.c_instance.type = make_ref_c (make_id(my.project_uid, my.type_uid))
        endif

    elsif defined (my.instance.interface)
        if is_ref (my.instance.interface) | defined (my.instance.library)
            my.c_instance.type = c_lang_ref (my.instance.interface)

        else
            my.project_uid = c_component_derive_instance_project_uid (my.instance)
            my.type_uid = c_component_derive_instance_type_uid ("struct", "impl", "impl")
            my.c_instance.type = make_ref_c (make_id(my.project_uid, my.type_uid))
        endif

    elsif defined (my.instance.api)
        if is_ref (my.instance.api) | defined (my.instance.library)
            my.c_instance.type = c_lang_ref (my.instance.api)

        else
            my.project_uid = c_component_derive_instance_project_uid (my.instance)
            my.type = cat (my.instance.api, "api")
            my.type_uid = c_component_derive_instance_type_uid ("struct", my.type, my.type)
            my.c_instance.type = make_ref_c (make_id(my.project_uid, my.type_uid))
        endif

    elsif defined (my.instance.impl)
        if is_ref (my.instance.impl) | defined (my.instance.library)
            my.c_instance.type = c_lang_ref (my.instance.impl)

        else
            my.project_uid = c_component_derive_instance_project_uid (my.instance)
            my.type_uid = c_component_derive_instance_type_uid ("struct", my.instance.impl, my.instance.impl)
            my.c_instance.type = make_ref_c (make_id(my.project_uid, my.type_uid))

        endif
    else
        echo_fatal ("Unreacheable code, component_resolve_instance() must handle this.", my)
    endif

    if is_true(my.instance.is_atomic)
        my.c_instance.type = ".(c_class_atomic_macros_atomic) $(my.c_instance.type:)"
    endif
endfunction

# ---------------------------------------------------------------------------
#   Define attribute: c_instance.type_is.
# ---------------------------------------------------------------------------
function c_component_map_instance_attr_type_is (c_instance, instance)
    check_arguments (my, "c_instance, instance", my)

    if defined (my.instance.type) | defined (my.instance.enum)
        my.c_instance.type_is = "primitive"

    elsif defined (my.instance.callback)
        my.c_instance.type_is = "callback"

    elsif defined (my.instance.class) & my.instance.class = "any"
        my.c_instance.type_is = "any"

    elsif defined (my.instance.class)
        my.c_instance.type_is = "class"

    elsif defined (my.instance.interface)
        my.c_instance.type_is = "class"

    elsif defined (my.instance.api)
        my.c_instance.type_is = "class"

    elsif defined (my.instance.impl)
        my.c_instance.type_is = "class"

    else
        my.instance_dump = component_instance_dump (my.instance)
        echo_fatal ("Attribute 'type_is' can not be resolved for instance: $(my.instance_dump)", my)
    endif
endfunction

# ---------------------------------------------------------------------------
#   Define attribute: c_instance.accessed_by
# ---------------------------------------------------------------------------
function c_component_map_instance_attr_accessed_by (c_instance, instance)
    check_arguments (my, "c_instance, instance", my)

    if is_true (my.instance.is_reference)

        if my.instance.access = "disown" & name (my.instance) <> "return"
            my.c_instance.accessed_by = "reference"

        else
            my.c_instance.accessed_by = "pointer"
        endif

    else
        my.c_instance.accessed_by = "value"
    endif

endfunction

# ---------------------------------------------------------------------------
#   Define attribute: c_instance.array.
# ---------------------------------------------------------------------------
function c_component_map_instance_attr_array (c_instance, instance)
    check_arguments (my, "c_instance, instance", my)

    if count (my.instance.array)
        my.c_instance.array = my.instance->array.length

        if my.instance->array.length = "fixed"
            my.c_instance.length = c_component_wrap_uid (my.instance->array.length_constant)
        endif
    else
        my.c_instance.array = # undefined
    endif
endfunction

# ---------------------------------------------------------------------------
#   Define attribute: c_instance.string.
# ---------------------------------------------------------------------------
function c_component_map_instance_attr_string (c_instance, instance)
    check_arguments (my, "c_instance, instance", my)

    if count (my.instance.string)
        my.c_instance.string = my.instance->string.length

        if my.instance->string.length = "fixed"
            my.c_instance.length = c_component_wrap_uid (my.instance->string.length_constant)
        endif
    else
        my.c_instance.string = # undefined
    endif
endfunction

# ---------------------------------------------------------------------------
#   Define 'c_instance' attributes that are responsible for constness:
#       - is_const_type
#       - is_const_pointer
#       - is_const_reference
# ---------------------------------------------------------------------------
function c_component_map_instance_attr_is_const (c_instance, instance)
    check_arguments (my, "c_instance, instance", my)

    my.is_array = count (my.instance.array) ?? "1" ? "0"
    my.is_string = count (my.instance.string) ?? "1" ? "0"
    my.is_class = has_one_of_attribute (my.instance, "class, interface, api, impl")
    my.is_variable = item_equal (my.instance, "variable")
    my.is_property = item_equal (my.instance, "property")
    my.is_reference = is_true (my.instance.is_reference)

    if my.is_class & my.is_reference & my.is_array & my.instance->array.access = "readonly"
        my.c_instance.is_const_pointer = "1"
    endif

    if my.instance.access = "readonly"
        if my.is_variable | my.is_property | my.is_string | my.is_array | my.is_reference
            my.c_instance.is_const_type = "1"
        endif
    endif

    if my.is_variable & my.is_string & my.instance->string.access = "readonly"
        my.c_instance.is_const_string = "1"
    endif

    if my.is_variable & my.is_array & my.instance->array.access = "readonly"
        my.c_instance.is_const_array = "1"
    endif
endfunction

# ---------------------------------------------------------------------------
#   Define attribute: c_instance.require_definition.
# ---------------------------------------------------------------------------
function c_component_map_instance_attr_require_definition (c_instance, instance)
    check_arguments (my, "c_instance, instance", my)

    my.c_instance.require_definition ?= my.instance.require_definition ?
endfunction

# ---------------------------------------------------------------------------
#   Define 'c_instance' from 'instance'.
# ---------------------------------------------------------------------------
function c_component_map_instance (c_instance, instance)
    check_arguments (my, "c_instance, instance")

    c_component_map_instance_attr_accessed_by (my.c_instance, my.instance)
    c_component_map_instance_attr_type (my.c_instance, my.instance)
    c_component_map_instance_attr_type_is (my.c_instance, my.instance)
    c_component_map_instance_attr_array (my.c_instance, my.instance)
    c_component_map_instance_attr_string (my.c_instance, my.instance)
    c_component_map_instance_attr_is_const (my.c_instance, my.instance)
    c_component_map_instance_attr_require_definition (my.c_instance, my.instance)
endfunction

# ---------------------------------------------------------------------------
#   Define attribute 'bits' within 'c_property', if it is defined within
#   'property'.
# ---------------------------------------------------------------------------
function c_component_map_property_attr_bits (c_property, property)
    check_arguments (my, "c_property, property", my)

    my.c_property.bits = my.property.bits ?
endfunction

# ---------------------------------------------------------------------------
#   Map attribute 'is_method' from 'macros' to 'c_macros'.
# ---------------------------------------------------------------------------
function c_component_map_macros_attr_is_method (c_macros, macros)
    check_arguments (my, "c_macros, macros", my)

    component_require_macros_attr_is_method (my.macros, my)

    my.c_macros.is_method ?= my.macros.is_method
endfunction

# ###########################################################################
#   Functions to creation new c_component(s)
# ###########################################################################

# ---------------------------------------------------------------------------
#   Create 'c_modifiers' from component attributes:
#       - visibility
#       - declaration
#       - definition
# ---------------------------------------------------------------------------
function c_component_create_modifiers (component, destination)
    check_arguments (my, "component, destination", my)

    new c_modifier to my.destination
        if item_in (my.component, "method") & \
                my.component.declaration = "private" & my.component.definition = "private"
            .value = "static"

        elsif my.component.visibility = "public"
            .value = ".(c_global_macros_public)"
        else
            .value = ".(c_global_macros_private)"
        endif
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create 'c_attribute' for next 'method' attribues:
#       - nodiscard.
# ---------------------------------------------------------------------------
function c_component_create_method_attributes (method, c_method)
    check_arguments (my, "method, c_method", my)

    if is_true (my.method.nodiscard)
        new c_attribute to my.c_method
            .value = ".(c_global_macros_nodiscard)"
        endnew
    endif
endfunction

# ---------------------------------------------------------------------------
#   Create 'c_code' from 'code'.
# ---------------------------------------------------------------------------
function c_component_create_code (code, destination)
    check_arguments (my, "code, destination", my)

    if my.code.lang <> "c"
        echo_fatal ("Require lang=\"c\" for given code, " + \
                "but found \"$(my.code.lang:)\"", my)
    endif

    copy code to my.destination as c_code
endfunction

# ---------------------------------------------------------------------------
#   Create 'c_include' from 'require'.
# ---------------------------------------------------------------------------
function c_component_create_include (require, destination)
    check_arguments (my, "require, destination", my)

    if ! has_one_of_attribute (my.require, "header, module, interface, class, impl, enum")
        return
    endif

    new c_include to my.destination
        my.is_system = defined (my.require.project) ?? "1" ? "0"
        my.project_uid = defined (my.require.project) ?? make_id ("project", my.require.project) ?
        my.api = (defined(my.require.api) & my.require.api <> "public") ?? my.require.api ?

        if defined (my.require.header)
            .file = my.require.header
            .is_system = "1"
            .is_objc = my.require.is_objc ?

        elsif defined (my.require.module)
            .file = make_ref (make_id (my.project_uid, "header", my.require.module, my.api), "c")
            .is_system = my.is_system

        elsif defined (my.require.interface)
            .file = make_ref (make_id (my.project_uid, "header", my.require.interface, my.api), "c")
            .is_system = my.is_system

        elsif defined (my.require.class)
            .file = make_ref (make_id (my.project_uid, "header", my.require.class, my.api), "c")
            .is_system = my.is_system

        elsif defined (my.require.impl)
            .file = make_ref (make_id (my.project_uid, "header", my.require.impl, my.api), "c")
            .is_system = my.is_system

        elsif defined (my.require.enum)
            .file = make_ref (make_id (my.project_uid, "header", my.require.enum, my.api), "c")
            .is_system = my.is_system
        endif

        if is_true(my.require.is_optional)
            my.feature_name = get_one_of_attribute (my.require, "interface, class, impl") ?
            if !defined (my.feature_name)
                echo_debug_item(my.feature_name)
                echo_fatal ("<feature is_optional=\"1\"/> allowed only for {interface, class, impl}")
            endif

            .if = make_ref_c (make_id (my.project_uid, "global macros", my.feature_name))
        endif

        if defined(my.require.if_feature)
            .if = make_ref_c (make_id (my.project_uid, "global macros", my.require.if_feature))
        endif

        c_component_resolve_include (c_include)
        c_component_map_attr_definition (c_include, my.require)
        c_component_map_attr_feature (c_include, my.require)

    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create 'c_constant' from 'constant'.
#   Note, enumeration constant do not require explicit value.
# ---------------------------------------------------------------------------
function c_component_create_constant (constant, destination)
    check_arguments (my, "constant, destination", my)


    if ! item_in (my.destination ?, "c_enum")
        component_require_attr_value (my.constant, my)
    endif

    new c_constant to my.destination
        . = c_format_description (my.constant.) ?
        .name = c_derive_constant_name (my.constant)
        .value = my.constant.value ?

        c_component_map_attr_definition (c_constant, my.constant)
        c_component_map_attr_uid (c_constant, my.constant)
        c_component_map_attr_feature (c_constant, my.constant)

        c_component_resolve_constant (c_constant)
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create 'c_enum' from 'enum'.
# ---------------------------------------------------------------------------
function c_component_create_enum (enum, destination)
    check_arguments (my, "enum, destination", my)

    component_require_attr_name (my.enum)

    new c_enum to my.destination
        . = c_format_description (my.enum.) ?
        .name = c_derive_enum_name (my.enum)

        c_component_map_attr_visibility (c_enum, my.enum)
        c_component_map_attr_declaration (c_enum, my.enum)
        c_component_map_attr_definition (c_enum, my.enum)
        c_component_map_attr_uid (c_enum, my.enum)
        c_component_map_attr_feature (c_enum, my.enum)

        #   Should be before 'c_constant' to avoid double resolve processing
        c_component_resolve_enum (c_enum)

        for my.enum.constant
            c_component_create_constant (constant, c_enum)
        endfor
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create 'c_argument' from 'argument'.
# ---------------------------------------------------------------------------
function c_component_create_argument (argument, destination)
    check_arguments (my, "argument, destination", my)

    component_require_attr_name (my.argument)

    new c_argument to my.destination
        .name = c_derive_instance_name (my.argument)

        c_component_map_instance (c_argument, my.argument)
        c_component_map_attr_uid (c_argument, my.argument)
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create void 'c_argument'.
# ---------------------------------------------------------------------------
function c_component_create_void_argument (destination)
    check_arguments (my, "destination", my)

    new c_argument to my.destination
        .type = "void"
        .accessed_by = "value"
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create 'c_return' from 'return'
# ---------------------------------------------------------------------------
function c_component_create_return (return, destination)
    check_arguments (my, "return, destination", my)

    new c_return to my.destination
        c_component_map_instance (c_return, my.return)
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create void 'c_argument'.
# ---------------------------------------------------------------------------
function c_component_create_void_return (destination)
    check_arguments (my, "destination", my)

    new c_return to my.destination
        .type = "void"
        .accessed_by = "value"
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create subbed 'c_code'.
# ---------------------------------------------------------------------------
function c_component_create_stub (destination)
    check_arguments (my, "destination", my)

    new c_code to my.destination
        .lang = "c"
        .type = "stub"
        . = "\
        //  TODO: This is STUB. Implement me.
        "
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create 'c_method' from 'method'.
# ---------------------------------------------------------------------------
function c_component_create_method (method, destination)
    check_arguments (my, "method, destination", my)

    component_require_attr_name (my.method)

    new c_method to my.destination
        . = c_format_description (my.method.) ?
        .name = c_derive_method_name (my.method)

        c_component_map_attr_visibility (c_method, my.method)
        c_component_map_attr_declaration (c_method, my.method)
        c_component_map_attr_definition (c_method, my.method)
        c_component_map_attr_uid (c_method, my.method)
        c_component_map_attr_feature (c_method, my.method)

        c_component_create_method_attributes (my.method, c_method)

        for my.method.argument
            c_component_create_argument (argument, c_method)
        else
            c_component_create_void_argument (c_method)
        endfor

        if count (my.method.return)
            c_component_create_return (my.method->return, c_method)
        else
            c_component_create_void_return (c_method)
        endif

        for my.method.code where lang = "c"
            c_component_create_code (code, c_method)
        else
            c_component_create_stub (c_method)
        endfor

        c_component_create_modifiers (my.method, c_method)
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create 'c_property' from 'property'.
# ---------------------------------------------------------------------------
function c_component_create_property (property, destination)
    check_arguments (my, "property, destination", my)

    component_require_attr_name (my.property)

    new c_property to my.destination
        . = c_format_description (my.property.) ?
        .name = c_derive_instance_name (my.property)

        c_component_map_instance (c_property, my.property)
        c_component_map_attr_uid (c_property, my.property)
        c_component_map_attr_feature (c_property, my.property)
        c_component_map_property_attr_bits (c_property, my.property)
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create 'c_struct' from 'struct'.
# ---------------------------------------------------------------------------
function c_component_create_struct (struct, destination)
    check_arguments (my, "struct, destination", my)

    component_require_attr_name (my.struct)

    new c_struct to my.destination
        . = c_format_description (my.struct.) ?
        .name = c_derive_struct_name (my.struct)

        c_component_map_attr_visibility (c_struct, my.struct)
        c_component_map_attr_declaration (c_struct, my.struct)
        c_component_map_attr_definition (c_struct, my.struct)
        c_component_map_attr_uid (c_struct, my.struct)
        c_component_map_attr_feature (c_struct, my.struct)

        for my.struct.property
            c_component_create_property (property, c_struct)
        endfor
    endnew
endfunction


# ---------------------------------------------------------------------------
#   Create 'c_macros' from 'macros'.
# ---------------------------------------------------------------------------
function c_component_create_macros (macros, destination)
    check_arguments (my, "macros, destination", my)

    component_require_attr_name (my.macros)

    new c_macros to my.destination
        . = c_format_description (my.macros.) ?
        .name = c_derive_macros_name (my.macros)

        c_component_map_attr_uid (c_macros, my.macros)
        c_component_map_attr_definition (c_macros, my.macros)
        c_component_map_attr_feature (c_macros, my.macros)
        c_component_map_macros_attr_is_method (c_macros, my.macros)

        for my.macros.code where lang = "c"
            c_component_create_code (code, c_macros)
        endfor
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create 'c_macroses' from 'macroses'.
# ---------------------------------------------------------------------------
function c_component_create_macroses (macroses, destination)
    check_arguments (my, "macroses, destination", my)

    new c_macroses to my.destination
        . = c_format_description (my.macroses.) ?

        c_component_map_attr_definition (c_macroses, my.macroses)
        c_component_map_attr_feature (c_macroses, my.macroses)

        for my.macroses.macros
            c_component_create_macros (macros, c_macroses)
        endfor

        for my.macroses.code where lang = "c"
            c_component_create_code (code, c_macroses)
        endfor
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create 'c_callback' from 'callback'.
# ---------------------------------------------------------------------------
function c_component_create_callback (callback, destination)
    check_arguments (my, "callback, destination", my)

    component_require_attr_name (my.callback)

    new c_callback to my.destination
        . = c_format_description (my.callback.) ?
        .name = c_derive_callback_name (my.callback)

        c_component_map_attr_uid (c_callback, my.callback)
        c_component_map_attr_declaration (c_callback, my.callback)

        for my.callback.argument
            c_component_create_argument (argument, c_callback)
        else
            c_component_create_void_argument (c_callback)
        endfor

        if count (my.callback.return)
            c_component_create_return (my.callback->return, c_callback)
        else
            c_component_create_void_return (c_callback)
        endif
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create 'c_cast' from 'cast'
# ---------------------------------------------------------------------------
function c_component_create_cast (cast, destination)
    check_arguments (my, "cast, destination", my)

    new c_cast to my.destination
        c_component_map_instance (c_cast, my.cast)
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create 'c_value' from 'value'
# ---------------------------------------------------------------------------
function c_component_create_value (value, destination)
    check_arguments (my, "value, destination", my)

    component_require_attr_value (my.value)

    new c_value to my.destination
        . = c_format_description (my.value.) ?
        .value = c_component_wrap_uid (my.value.value)

        c_component_map_instance (c_value, my.value)

        for my.value.cast
            c_component_create_cast (cast, c_value)
        endfor
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create 'c_value' with NULL termination literal.
# ---------------------------------------------------------------------------
function c_component_create_null_value (destination)
    check_arguments (my, "destination", my)

    new c_value to my.destination
        .value = "NULL"
        .accessed_by = "pointer"
        .type = "void"
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create 'c_variable' from 'variable'
# ---------------------------------------------------------------------------
function c_component_create_variable (variable, destination)
    check_arguments (my, "variable, destination", my)

    component_require_attr_name (my.variable)

    new c_variable to my.destination
        . = c_format_description (my.variable.) ?
        .name = c_derive_variable_name (my.variable)

        c_component_map_attr_uid (c_variable, my.variable)
        c_component_map_attr_visibility (c_variable, my.variable)
        c_component_map_attr_declaration (c_variable, my.variable)
        c_component_map_attr_definition (c_variable, my.variable)
        c_component_map_attr_feature (c_variable, my.variable)
        c_component_map_instance (c_variable, my.variable)

        for my.variable.value
            c_component_create_value (value, c_variable)
        endfor

        if count (my.variable.array) & my.variable->array.length = "null_terminated"
            c_component_create_null_value (c_variable)
        endif

        c_component_create_modifiers (my.variable, c_variable)
    endnew
endfunction


.endtemplate
