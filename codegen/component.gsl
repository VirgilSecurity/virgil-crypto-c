.template 0
#   Copyright (C) 2015-2018 Virgil Security Inc.
#
#   All rights reserved.
#
#   Redistribution and use in source and binary forms, with or without
#   modification, are permitted provided that the following conditions are
#   met:
#
#       (1) Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#
#       (2) Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in
#       the documentation and/or other materials provided with the
#       distribution.
#
#       (3) Neither the name of the copyright holder nor the names of its
#       contributors may be used to endorse or promote products derived from
#       this software without specific prior written permission.
#
#   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR
#   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#   DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
#   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
#   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
#   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
#   STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
#   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#   POSSIBILITY OF SUCH DAMAGE.
#
#   Lead Maintainer: Virgil Security Inc. <support@virgilsecurity.com>

# ---------------------------------------------------------------------------
#   Perform resolution for item 'module' and all children.
#
#   Resolution includes several steps:
#       1. Validate - check that required attributes and items are defined.
#       2. Define default values to the optional component attributes.
#       3. Append optional items.
#
#    Private function prefix is: B23.
#
# ---------------------------------------------------------------------------
#   This is a code generator built using the iMatix GSL code generation
#   language. See https://github.com/imatix/gsl for details.
# ---------------------------------------------------------------------------

gsl from "common.gsl"


# ---------------------------------------------------------------------------
#   Return component as shortened XML string with required attributes.
# ---------------------------------------------------------------------------
function component_dump (component)
    check_argument (my, "component")

    my.component_info = ""
    my.component_info += " name=\"$(my.component.name)\"" ? ""
    my.component_info += " lang=\"$(my.component.lang)\"" ? ""
    my.component_info += " of_class=\"$(my.component.of_class)\"" ? ""
    my.component_info += " visibility=\"$(my.component.visibility)\"" ? ""
    my.component_info += " scope=\"$(my.component.scope)\"" ? ""
    my.component_info += " declaration=\"$(my.component.declaration)\"" ? ""
    my.component_info += " definition=\"$(my.component.definition)\"" ? ""
    my.component_dump = "<$(name (my.component))$(my.component_info)/>"

    return my.component_dump
endfunction

# ---------------------------------------------------------------------------
#   Return instance as shortened XML string with required attributes.
# ---------------------------------------------------------------------------
function component_instance_dump (instance)
    check_argument (my, "instance")

    my.instance_info = ""
    my.instance_info += " name=\"$(my.instance.name)\"" ? ""
    my.instance_info += " type=\"$(my.instance.type)\"" ? ""
    my.instance_info += " class=\"$(my.instance.class)\"" ? ""
    my.instance_info += " callback=\"$(my.instance.callback)\"" ? ""
    my.instance_info += " bits=\"$(my.instance.bits)\"" ? ""
    my.instance_info += " access=\"$(my.instance.access)\"" ? ""
    my.instance_dump = "<$(name (my.instance))$(my.instance_info)/>"

    return my.instance_dump
endfunction

# ---------------------------------------------------------------------------
#   Return new or existent item 'string' of the given instance component.
#   Note, newly created string is not resolved.
# ---------------------------------------------------------------------------
function component_get_instance_string (instance)
    check_argument (my, "instance", my)

    if count (my.instance.string)
        return my.instance->string
    else
        new string to my.instance
            return string
        endnew
    endif
endfunction

# ---------------------------------------------------------------------------
#   Return new or existent item 'array' of the given instance component.
#   Note, newly created array is not resolved.
# ---------------------------------------------------------------------------
function component_get_instance_array (instance)
    check_argument (my, "instance", my)

    if count (my.instance.array)
        return my.instance->array
    else
        new array to my.instance
            return array
        endnew
    endif
endfunction

# ###########################################################################
#   Validate or check attribute.
# ###########################################################################

# ---------------------------------------------------------------------------
#   Check required attribute: name.
# ---------------------------------------------------------------------------
function component_require_attr_name (component, caller)
    check_argument (my, "component", my)

    assert_attribute (my.component, "name", my.caller ? my)
endfunction

# ---------------------------------------------------------------------------
#   Check required attribute: of_class.
# ---------------------------------------------------------------------------
function component_require_attr_of_class (component, caller)
    check_argument (my, "component", my)

    assert_attribute (my.component, "of_class", my.caller ? my)
endfunction

# ---------------------------------------------------------------------------
#   Check required attribute: value.
# ---------------------------------------------------------------------------
function component_require_attr_value (component, caller)
    check_argument (my, "component", my)

    assert_attribute (my.component, "value", my.caller ? my)
endfunction

# ---------------------------------------------------------------------------
#   Check required attribute: type.
# ---------------------------------------------------------------------------
function component_require_attr_type (component, caller)
    check_argument (my, "component", my)

    assert_attribute (my.component, "type", my.caller ? my)
endfunction

# ---------------------------------------------------------------------------
#   Check required attribute: class.
# ---------------------------------------------------------------------------
function component_require_attr_class (component, caller)
    check_argument (my, "component", my)

    assert_attribute (my.component, "class", my.caller ? my)
endfunction

# ---------------------------------------------------------------------------
#   Check required attribute: enum.
# ---------------------------------------------------------------------------
function component_require_attr_enum (component, caller)
    check_argument (my, "component", my)

    assert_attribute (my.component, "enum", my.caller ? my)
endfunction

# ---------------------------------------------------------------------------
#   Check required attribute: callback.
# ---------------------------------------------------------------------------
function component_require_attr_callback (component, caller)
    check_argument (my, "component", my)

    assert_attribute (my.component, "callback", my.caller ? my)
endfunction

# ---------------------------------------------------------------------------
#   Check required attribute: uid.
# ---------------------------------------------------------------------------
function component_require_attr_uid (component, caller)
    check_argument (my, "component", my)

    assert_attribute (my.component, "uid", my.caller ? my)
endfunction

# ---------------------------------------------------------------------------
#   Check required attribute: declaration.
# ---------------------------------------------------------------------------
function component_require_attr_declaration (component, caller)
    check_argument (my, "component", my)

    assert_attribute (my.component, "declaration", my.caller ? my)
endfunction

# ---------------------------------------------------------------------------
#   Check required attribute: definition.
# ---------------------------------------------------------------------------
function component_require_attr_definition (component, caller)
    check_argument (my, "component", my)

    assert_attribute (my.component, "definition", my.caller ? my)
endfunction

# ---------------------------------------------------------------------------
#   Check required attribute: visibility.
# ---------------------------------------------------------------------------
function component_require_attr_visibility (component, caller)
    check_argument (my, "component", my)

    assert_attribute (my.component, "visibility", my.caller ? my)
endfunction

# ---------------------------------------------------------------------------
#   Check required attribute: scope.
# ---------------------------------------------------------------------------
function component_require_attr_scope (component, caller)
    check_argument (my, "component", my)

    assert_attribute (my.component, "scope", my.caller ? my)
endfunction

# ---------------------------------------------------------------------------
#   Check required attribute: module.
# ---------------------------------------------------------------------------
function component_require_attr_module (component, caller)
    check_argument (my, "component", my)

    assert_attribute (my.component, "module", my.caller ? my)
endfunction

# ---------------------------------------------------------------------------
#   Check required item: linage.
# ---------------------------------------------------------------------------
function component_require_lineage (component, caller)
    check_argument (my, "component", my)

    assert_item (my.component, "lineage", my.caller ? my)
endfunction

# ---------------------------------------------------------------------------
#   Check required item: implementation.
# ---------------------------------------------------------------------------
function component_require_implementation (component, caller)
    check_argument (my, "component", my)

    assert_item (my.component, "implementation", my.caller ? my)
endfunction


# ---------------------------------------------------------------------------
#   Check required attribute: macros.is_method.
# ---------------------------------------------------------------------------
function component_require_macros_attr_is_method (macros, caller)
    check_argument (my, "macros", my)

    assert_attribute (my.macros, "is_method", my.caller ? my)
endfunction


# ###########################################################################
#   Attribute resolution.
# ###########################################################################

# ---------------------------------------------------------------------------
#   Return true if given component does not belong to any class.
# ---------------------------------------------------------------------------
function component_is_global (component)
    check_argument (my, "component", my)

    return (my.component.of_class ? my.component->lineage.of_class ? "global") = "global"
endfunction

# ---------------------------------------------------------------------------
#   Derive uid for given module or it's children.
#
#   Note, given component must be resolved, it means that component contains
#   information about all ancestors within item 'lineage'.
# ---------------------------------------------------------------------------
function component_derive_uid (component)
    check_argument (my, "component", my)

    component_require_lineage (my.component, my)

    #   Define parents uid
    for my.component->lineage.ancestor
        if string_in (ancestor.id, "project, module")
            #   Skip ancestors that add excess uniqueness
            next
        endif
        my.parent_uid = make_id (my.parent_uid, ancestor.id, ancestor.name)
    endfor

    #   Define self uid
    my.self_uid = make_id (name (my.component), my.component.name)

    #   Define uid scope: class or global
    if component_is_global (my.component)
        my.uid_scope = "global"
    else
        my.uid_scope = make_id ("class", my.component.of_class ? my.component->lineage.of_class)
    endif

    #   Put it together
    return make_id (my.uid_scope, my.parent_uid, my.self_uid)
endfunction

# ---------------------------------------------------------------------------
#   Return component's name prefix: class name + ancestors.
#   Rules:
#       - class name is ommited if class is 'global';
#       - class name is ommited if component's name equals to the class name.
# ---------------------------------------------------------------------------
function component_derive_name_prefix (component)
    check_argument (my, "component", my)

    component_require_attr_name (my.component, my)
    component_require_attr_of_class (my.component, my)
    component_require_lineage (my.component, my)

    my.ancestors = ""
    for my.component->lineage.ancestor where ! string_in (id, "project, module")
        my.ancestors = cat (my.ancestors, ancestor.name)
    endfor

    if component_is_global (my.component)
        return cat (my.ancestors)

    elsif string_equal (my.component.of_class, my.component.name)
        return cat (my.ancestors)

    else
        return cat (my.component.of_class, my.ancestors)
    endif
endfunction

# ---------------------------------------------------------------------------
#   Return component's full name: class name + ancestors + self name.
#   Rules:
#       - class name is ommited if class is 'global';
#       - class name is ommited if component's name equals to the class name.
# ---------------------------------------------------------------------------
function component_derive_full_name (component)
     check_argument (my, "component", my)

     return cat (component_derive_name_prefix (my.component), my.component.name)
endfunction

# ---------------------------------------------------------------------------
#   Resolve attribute: lang.
# ---------------------------------------------------------------------------
function component_resolve_attr_lang (component, parent)
    check_argument (my, "component", my)

    my.component.lang ?= my.parent.lang ? "c"

    my.valid_langs = "c, java, csharp"

    if ! string_in (my.component.lang, my.valid_langs)
        my.component_dump = component_dump (my.component)

        echo_fatal ("Invalid component attribute lang '$(my.component_dump:)'. " + \
                    "Expected {$(my.valid_langs)}", my)
    endif
endfunction

# ---------------------------------------------------------------------------
#   Resolve attribute: scope.
# ---------------------------------------------------------------------------
function component_resolve_attr_scope (component, parent)
    check_argument (my, "component", my)

    my.component.scope ?= "public" #   must not be inherited

    my.valid_scopes = "public, private, internal"
    if ! string_in (my.component.scope, my.valid_scopes)
        my.component_dump = component_dump (my.component)

        echo_fatal ("Invalid instance scope '$(my.component_dump:)'. " + \
                    "Expected {$(my.valid_scopes)}", my)
    endif
endfunction

# ---------------------------------------------------------------------------
#   Resolve attribute: class.
# ---------------------------------------------------------------------------
function component_resolve_attr_of_class (component, parent)
    check_arguments (my, "component, parent", my)

    my.component.of_class ?= my.parent.of_class
endfunction

# ---------------------------------------------------------------------------
#   Resolve attribute: c_prefix.
# ---------------------------------------------------------------------------
function component_resolve_attr_c_prefix (component, parent)
    check_argument (my, "component", my)

    my.component.c_prefix ?= my.parent.c_prefix
endfunction

# ---------------------------------------------------------------------------
#   Resolve attribute: uid.
# ---------------------------------------------------------------------------
function component_resolve_attr_uid (component, parent)
    check_argument (my, "component", my)
    assert_item (my.component, "lineage", my)

    my.component.uid = component_derive_uid (my.component)
endfunction

# ---------------------------------------------------------------------------
#   Resolve attribute: visibility.
# ---------------------------------------------------------------------------
function component_resolve_attr_visibility (component, parent)
    check_argument (my, "component", my)

    my.component.visibility ?= "public" #   must not be inherited

    my.valid_visibilities = "public, private"
    if ! string_in (my.component.visibility, my.valid_visibilities)
        my.component_dump = component_dump (my.component)

        echo_fatal ("Invalid instance visibility '$(my.component_dump:)'. " + \
                    "Expected {$(my.valid_visibilities)}", my)
    endif
endfunction

# ---------------------------------------------------------------------------
#   Resolve attribute: declaration.
# ---------------------------------------------------------------------------
function component_resolve_attr_declaration (component, parent)
    check_argument (my, "component", my)

    my.component.declaration ?= "public" #   must not be inherited

    my.valid_declarations = "public, private, external"
    if ! string_in (my.component.declaration, my.valid_declarations)
        my.component_dump = component_dump (my.component)

        echo_fatal ("Invalid component declaration '$(my.component_dump:)'. " + \
                    "Expected {$(my.valid_declarations)}", my)
    endif
endfunction

# ---------------------------------------------------------------------------
#   Resolve attribute: definition.
# ---------------------------------------------------------------------------
function component_resolve_attr_definition (component, parent)
    check_argument (my, "component", my)

    if string_in (name (my.component), "constant, macros, macroses")
        my.component.definition ?= "public" #   must not be inherited
    else
        my.component.definition ?= "private" #   must not be inherited
    endif

    my.valid_definitions = "public, private, external"
    if ! string_in (my.component.definition, my.valid_definitions)
        my.component_dump = component_dump (my.component)

        echo_fatal ("Invalid component definition '$(my.component_dump:)'. " + \
                    "Expected {$(my.valid_definitions)}", my)
    endif
endfunction

# ---------------------------------------------------------------------------
#   Resolve attribute: type.
# ---------------------------------------------------------------------------
function component_resolve_instance_attr_type (instance, parent)
    check_arguments (my, "instance, parent")

    component_require_attr_type (my.instance, my)

    my.valid_types = "nothing, boolean, integer, size, byte, data, string"
    if ! string_in (my.instance.type, my.valid_types)
        my.instance_dump = component_instance_dump (my.instance)

        echo_fatal ("Invalid instance type '$(my.instance_dump:)'. " + \
                    "Expected {$(my.valid_types)}", my)
    endif

    #   Resolve type shortcuts
    if my.instance.type = "data"
        my.instance.type = "byte"
        my.instance.access ?= "readonly"

        my.array = component_get_instance_array (my.instance)
        my.array.length ?= "given"
        my.array.access ?= "readwrite"
    endif

    if my.instance.type = "string"
        my.instance.type = "char"
        my.instance.access ?= "readonly"

        my.string = component_get_instance_string (my.instance)
        my.string.length ?= "null_terminated"
        my.string.access ?= "readwrite"
    endif
endfunction

# ---------------------------------------------------------------------------
#   Resolve attribute: class.
# ---------------------------------------------------------------------------
function component_resolve_instance_attr_class (instance, parent)
    check_arguments (my, "instance, parent")

    component_require_attr_class (my.instance, my)
endfunction

# ---------------------------------------------------------------------------
#   Resolve attribute: enum.
# ---------------------------------------------------------------------------
function component_resolve_instance_attr_enum (instance, parent)
    check_arguments (my, "instance, parent")

    component_require_attr_enum (my.instance, my)
endfunction

# ---------------------------------------------------------------------------
#   Resolve attribute: callback.
# ---------------------------------------------------------------------------
function component_resolve_instance_attr_callback (instance, parent)
    check_arguments (my, "instance, parent")

    component_require_attr_callback (my.instance, my)
endfunction

# ---------------------------------------------------------------------------
#   Resolve attribute: access.
# ---------------------------------------------------------------------------
function component_resolve_instance_attr_access (instance, parent)
    check_arguments (my, "instance, parent")

    my.instance.access ?= "readonly"

    my.valid_access_argument = "readonly, writeonly, readwrite, disown"
    my.valid_access_variable = "readonly, readwrite"
    my.valid_access_return = "readonly, readwrite, disown"

    if item_in (my.instance, "argument") & \
            ! string_in (my.instance.access, my.valid_access_argument)

        echo_fatal ( \
            "Invalid value '$(my.instance.access)' of attribute '$(name (my.instance)).access'." + \
            " Expected {$(my.valid_access_argument)}")

    elsif item_in (my.instance, "variable, property") & \
            ! string_in (my.instance.access, my.valid_access_variable)

        echo_fatal ( \
            "Invalid value '$(my.instance.access)' of attribute '$(name (my.instance)).access'." + \
            " Expected {$(my.valid_access_variable)}")

    elsif item_in (my.instance, "return") & \
            ! string_in (my.instance.access, my.valid_access_return)

        echo_fatal ( \
            "Invalid value '$(my.instance.access)' of attribute '$(name (my.instance)).access'." + \
            " Expected {$(my.valid_access_return)}")
    endif

endfunction

# ---------------------------------------------------------------------------
#   Resolve attribute: instance.size.
# ---------------------------------------------------------------------------
function component_resolve_instance_attr_size (instance, parent)
    check_arguments (my, "instance, parent")

    if defined (my.instance.size)
        my.instance_dump = component_instance_dump (my.instance)

        my.valid_instance_type = "integer, size"
        if ! string_in (my.instance.type ?, my.valid_instance_type)
            echo_fatal ("Illegal attribute 'size' for instance $(my.instance_dump)." + \
                        " Only allowed for instance with type={$(my.valid_instance_type)}", my)
        endif

        my.valid_sizes = "1, 2, 4, 8"
        if ! string_in (my.instance.size, my.valid_sizes)
            echo_fatal ("Illegal attribute 'size' for instance $(my.instance_dump)." + \
                        " Expected {$(my.valid_sizes)}", my)
        endif
    endif
endfunction

# ---------------------------------------------------------------------------
#   Resolve attribute: instance.is_reference.
#   Rules:
#       For 'type'     - default is '0'.
#       For 'enum'     - default is '0'.
#       For 'callback' - default is '0'.
#       For 'class'    - default is '1'.
# ---------------------------------------------------------------------------
function component_resolve_instance_attr_is_reference (instance, parent)
    check_arguments (my, "instance, parent")

    my.instance.is_reference ?= defined (my.instance.class)
endfunction

# ---------------------------------------------------------------------------
#   Resolve attribute: string.length.
# ---------------------------------------------------------------------------
function component_resolve_string_attr_length (string, parent)
    check_arguments (my, "string, parent", my)

    my.string.length ?= "null_terminated"

    my.valid_length = "null_terminated, given, fixed, derived"

    if ! string_in (my.string.length, my.valid_length)
        echo_fatal ("Invalid string attribute length=\"$(my.string.length:)\"." + \
                    " Expected {$(my.valid_length)}", my)
    endif
endfunction

# ---------------------------------------------------------------------------
#   Resolve attribute: array.access.
# ---------------------------------------------------------------------------
function component_resolve_array_attr_access (array, parent)
    check_arguments (my, "array, parent", my)

    my.array.access ?= "readwrite"

    my.valid_access_argument = "readonly, writeonly, readwrite, disown"
    my.valid_access_variable = "readonly, readwrite"
    my.valid_access_return = "readonly, disown"

    if item_in (my.parent, "argument") & \
            ! string_in (my.array.access, my.valid_access_argument)

        echo_fatal ( \
            "Invalid value '$(my.array.access)' " + \
            "of attribute '$(name (my.parent))->array.access'." + \
            " Expected {$(my.valid_access_argument)}")

    elsif item_in (my.parent, "variable, property") & \
            ! string_in (my.array.access, my.valid_access_variable)

        echo_fatal ( \
            "Invalid value '$(my.array.access)' " + \
            "of attribute '$(name (my.parent))->array.access'." + \
            " Expected {$(my.valid_access_variable)}")

    elsif item_in (my.parent, "return") & \
            ! string_in (my.array.access, my.valid_access_return)

        echo_fatal ( \
            "Invalid value '$(my.array.access)' " + \
            "of attribute '$(name (my.parent))->array.access'." + \
            " Expected {$(my.valid_access_return)}")
    endif

endfunction

# ---------------------------------------------------------------------------
#   Resolve attribute: array.length.
# ---------------------------------------------------------------------------
function component_resolve_array_attr_length (array, parent)
    check_arguments (my, "array, parent", my)

    my.array.length ?= "given"
endfunction

# ---------------------------------------------------------------------------
#   Resolve attribute: macros.is_method.
# ---------------------------------------------------------------------------
function component_resolve_macros_attr_is_method (macros, parent)
    check_arguments (my, "macros, parent", my)

    my.macros.is_method ?= "0"
endfunction

# ---------------------------------------------------------------------------
#   Resolve attribute: property.bits.
# ---------------------------------------------------------------------------
function component_resolve_property_attr_bits (property, parent)
    check_arguments (my, "property, parent", my)

    if ! defined (my.property.bits)
        return
    endif

    if ! defined (my.property.type) | ! string_in (my.property.type, "integer, boolean")
        my.instance_dump = component_instance_dump (my.property)
        echo_fatal ("Attribute 'bits' is allowed only for integral types" + \
                ", but found in $(my.instance_dump:)", my)
    endif

    assert_attribute_number (my.property, "bits", my)
endfunction

function component_resolve_attr_module (component, parent)
    check_arguments (my, "component, parent", my)

    component_require_attr_module (my.component, my)
endfunction


# ---------------------------------------------------------------------------
#   Resolve attribute: method.context.
# ---------------------------------------------------------------------------
function component_resolve_method_attr_context (method, parent)
    check_arguments (my, "method, parent", my)

    my.method.context ?= "none"

    my.valid_context = "none, impl, api"

    if ! string_in (my.method.context, my.valid_context)
        echo_fatal ("Invalid method attribute context=\"$(my.method.context:)\"." + \
                    " Expected {$(my.valid_context)}", my)
    endif
endfunction

# ---------------------------------------------------------------------------
#   Resolve attribute: implementation.body.
# ---------------------------------------------------------------------------
function component_resolve_implementation_attr_body (implementation, parent)
    check_arguments (my, "implementation, parent", my)

    my.implementation.body ?= "generated"

    my.valid_body = "stub, generated, handwritten"

    if ! string_in (my.implementation.body, my.valid_body)
        echo_fatal ("Invalid implementation attribute body=\"$(my.implementation.body:)\"." + \
                    " Expected {$(my.valid_body)}", my)
    endif
endfunction

# ###########################################################################
#   Per component resolution.
# ###########################################################################

# ---------------------------------------------------------------------------
#   Add 'lineage' to the component.
# ---------------------------------------------------------------------------
function component_add_lineage (component, parent)
    check_arguments (my, "component, parent", my)

    if item_in (my.parent, "section")
        echo_fatal ("Section must be already embedded as a component's property", my)
    endif

    if count (my.component.lineage)
        #   Already there
        return
    endif

    if count (my.parent.lineage)
        #   Use parent's lineage
        copy my.parent->lineage to my.component
    else
        #   Create new lineage
        new lineage to my.component
        endnew
    endif

    my.component->lineage.of_class = my.parent.of_class

    #   Add parent as ancestor
    new ancestor to my.component->lineage
        .id = name (my.parent)
        .name = my.parent.name
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Resolve component: implementation
# ---------------------------------------------------------------------------
function component_resolve_implementation (implementation, parent)
    check_arguments (my, "implementation, parent")

    component_resolve_attr_lang (my.implementation, my.parent)
    component_resolve_implementation_attr_body (my.implementation, my.parent)
endfunction

# ---------------------------------------------------------------------------
#   Resolve component: require
# ---------------------------------------------------------------------------
function component_resolve_require (require, parent)
    check_arguments (my, "require, parent")

    component_resolve_attr_module (my.require, my.parent)
    component_resolve_attr_scope (my.require, my.parent)
endfunction

# ---------------------------------------------------------------------------
#   Resolve component: string
# ---------------------------------------------------------------------------
function component_resolve_string (string, parent)
    check_arguments (my, "string, parent")

    component_resolve_string_attr_length (my.string, my.parent)
endfunction

# ---------------------------------------------------------------------------
#   Resolve component: array
# ---------------------------------------------------------------------------
function component_resolve_array (array, parent)
    check_arguments (my, "array, parent")

    component_resolve_array_attr_access (my.array, my.parent)
    component_resolve_array_attr_length (my.array, my.parent)
endfunction

# ---------------------------------------------------------------------------
#   Resolve abstract component: instance
# ---------------------------------------------------------------------------
function component_resolve_instance (instance, parent)
    check_arguments (my, "instance, parent", my)

    if defined (my.instance.type)
        component_resolve_instance_attr_type (my.instance, my.parent)

    elsif defined (my.instance.class)
        component_resolve_instance_attr_class (my.instance, my.parent)

    elsif defined (my.instance.enum)
        component_resolve_instance_attr_enum (my.instance, my.parent)

    elsif defined (my.instance.callback)
        component_resolve_instance_attr_callback (my.instance, my.parent)

    else
        echo_fatal ("Component that inherit 'instance' must define one" + \
                    " of the attribute {type, class, enum, callback}" + terminator + \
                    component_instance_dump (my.instance))
    endif

    component_resolve_instance_attr_access (my.instance, my.parent)
    component_resolve_instance_attr_size (my.instance, my.parent)
    component_resolve_instance_attr_is_reference (my.instance, my.parent)

    if count (my.instance.string)
        component_resolve_string (my.instance->string, my.instance)
    endif

    if count (my.instance.array)
        component_resolve_array (my.instance->array, my.instance)
    endif
endfunction

# ---------------------------------------------------------------------------
#   Inherit parent 'instance' attributes.
#   Note, parent mast also be an 'instance'.
# ---------------------------------------------------------------------------
function component_inherit_parent_instance (instance, parent)
    check_arguments (my, "instance, parent", my)

    if ! defined (my.instance.type) & ! defined (my.instance.class) & \
        ! defined (my.instance.enum) & ! defined (my.instance.callback)


        my.instance.type ?= my.parent.type ?
        my.instance.class ?= my.parent.class ?
        my.instance.enum ?= my.parent.enum ?
        my.instance.callback ?= my.parent.callback ?
    endif

    my.instance.size ?= my.parent.size ?
    my.instance.access ?= my.parent.access ?
endfunction

# ---------------------------------------------------------------------------
#   Resolve component: return.
# ---------------------------------------------------------------------------
function component_resolve_return (return, parent)
    check_arguments (my, "return, parent", my)

    component_add_lineage (my.return, my.parent)
    component_resolve_instance (my.return, my.parent)
endfunction

# ---------------------------------------------------------------------------
#   Resolve component: component.
# ---------------------------------------------------------------------------
function component_resolve_component (component, parent)
    check_arguments (my, "component, parent", my)

    component_resolve_attr_of_class (my.component, my.parent)
    component_resolve_attr_c_prefix (my.component, my.parent)
    component_resolve_attr_uid (my.component, my.parent)
endfunction

# ---------------------------------------------------------------------------
#   Resolve component: constant.
# ---------------------------------------------------------------------------
function component_resolve_constant (constant, parent)
    check_argument (my, "constant", my)

    component_require_attr_name (my.constant, my)

    if ! item_in (my.parent ?, "enum")
        component_require_attr_value (my.constant, my)
    endif

    component_add_lineage (my.constant, my.parent)

    component_resolve_component (my.constant, my.parent)
    component_resolve_attr_definition (my.constant, my.parent)
endfunction

# ---------------------------------------------------------------------------
#   Resolve component: enum.
# ---------------------------------------------------------------------------
function component_resolve_enum (enum, parent)
    check_argument (my, "enum", my)

    component_require_attr_name (my.enum, my)

    component_add_lineage (my.enum, my.parent)

    component_resolve_component (my.enum, my.parent)
    component_resolve_attr_visibility (my.enum, my.parent)
    component_resolve_attr_declaration (my.enum, my.parent)
    component_resolve_attr_definition (my.enum, my.parent)

    for my.enum.constant
        component_resolve_constant (constant, my.enum)
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Resolve component: property.
# ---------------------------------------------------------------------------
function component_resolve_property (property, parent)
    check_arguments (my, "property, parent", my)

    component_require_attr_name (my.property, my)
    component_require_lineage (my.parent, my)

    component_add_lineage (my.property, my.parent)

    component_resolve_property_attr_bits (my.property, my.parent)

    component_resolve_instance (my.property, my.parent)
    component_resolve_attr_uid (my.property, my.parent)
endfunction

# ---------------------------------------------------------------------------
#   Resolve component: struct.
# ---------------------------------------------------------------------------
function component_resolve_struct (struct, parent)
    check_arguments (my, "struct, parent", my)

    component_require_attr_name (my.struct, my)

    component_add_lineage (my.struct, my.parent)

    component_resolve_component (my.struct, my.parent)
    component_resolve_attr_visibility (my.struct, my.parent)
    component_resolve_attr_declaration (my.struct, my.parent)
    component_resolve_attr_definition (my.struct, my.parent)

    for my.struct.property
        component_resolve_property (property, my.struct)
    endfor

endfunction

# ---------------------------------------------------------------------------
#   Resolve component: cast.
# ---------------------------------------------------------------------------
function component_resolve_cast (cast, parent)
    check_arguments (my, "cast, parent", my)

    component_resolve_instance (my.cast, my.parent)
endfunction

# ---------------------------------------------------------------------------
#   Resolve component: value.
# ---------------------------------------------------------------------------
function component_resolve_value (value, parent)
    check_arguments (my, "value, parent", my)

    component_inherit_parent_instance (my.value, my.parent)

    component_require_attr_value (my.value, my)
    component_resolve_instance (my.value, my.parent)

    for my.value.cast
        component_resolve_cast (cast, my.value)
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Resolve component: variable.
# ---------------------------------------------------------------------------
function component_resolve_variable (variable, parent)
    check_arguments (my, "variable, parent", my)

    component_require_attr_name (my.variable, my)

    component_add_lineage (my.variable, my.parent)

    component_resolve_component (my.variable, my.parent)
    component_resolve_instance (my.variable, my.parent)
    component_resolve_attr_visibility (my.variable, my.parent)
    component_resolve_attr_declaration (my.variable, my.parent)
    component_resolve_attr_definition (my.variable, my.parent)

    for my.variable.value
        component_resolve_value (value, my.variable)
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Resolve component: argument.
# ---------------------------------------------------------------------------
function component_resolve_argument (argument, parent)
    check_arguments (my, "argument, parent", my)

    component_require_attr_name (my.argument, my)
    component_require_lineage (my.parent, my)

    component_add_lineage (my.argument, my.parent)

    component_resolve_instance (my.argument, my.parent)
    component_resolve_attr_uid (my.argument, my.parent)
endfunction

# ---------------------------------------------------------------------------
#   Resolve component: method.
# ---------------------------------------------------------------------------
function component_resolve_method (method, parent)
    check_arguments (my, "method, parent", my)

    component_add_lineage (my.method, my.parent)

    component_resolve_component (my.method, my.parent)
    component_resolve_attr_visibility (my.method, my.parent)
    component_resolve_attr_declaration (my.method, my.parent)
    component_resolve_attr_definition (my.method, my.parent)
    component_resolve_method_attr_context (my.method, my.parent)

    for my.method.argument
        component_resolve_argument (argument, my.method)
    endfor

    for my.method.return
        component_resolve_return (return, my.method)
    endfor

    for my.method.implementation
        component_resolve_implementation (implementation, my.method)
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Resolve component: callback.
# ---------------------------------------------------------------------------
function component_resolve_callback (callback, parent)
    check_arguments (my, "callback, parent", my)

    component_add_lineage (my.callback, my.parent)

    component_resolve_component (my.callback, my.parent)
    component_resolve_attr_declaration (my.callback, my.parent)

    for my.callback.argument
        component_resolve_argument (argument, my.callback)
    endfor

    for my.callback.return
        component_resolve_return (return, my.callback)
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Resolve component: macros.
# ---------------------------------------------------------------------------
function component_resolve_macros (macros, parent)
    check_arguments (my, "macros, parent", my)

    component_add_lineage (my.macros, my.parent)

    component_resolve_component (my.macros, my.parent)
    component_resolve_attr_definition (my.macros, my.parent)
    component_resolve_macros_attr_is_method (my.macros, my.parent)

    for my.macros.implementation
        component_resolve_implementation (implementation, my.macros)
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Resolve component: macroses.
# ---------------------------------------------------------------------------
function component_resolve_macroses (macroses, parent)
    check_arguments (my, "macroses, parent", my)

    component_require_implementation (my.macroses, my)

    component_resolve_attr_definition (my.macroses, my.parent)
    component_resolve_attr_of_class (my.macroses, my.parent)

    for my.macroses.macros
        component_resolve_attr_of_class (macros, my.macroses)
        component_resolve_macros (macros, my.parent)
    endfor

    for my.macroses.implementation
        component_resolve_implementation (implementation, my.macroses)
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Traverse known components within module and perform complete resolution.
# ---------------------------------------------------------------------------
function foreach_component_resolve (module)
    check_argument (my, "module", my)

    for my.module.require
        component_resolve_require (require, my.module)
    endfor

    for my.module.constant
        component_resolve_constant (constant, my.module)
    endfor

    for my.module.enum
        component_resolve_enum (enum, my.module)
    endfor

    for my.module.variable
        component_resolve_variable (variable, my.module)
    endfor

    for my.module.struct
        component_resolve_struct (struct, my.module)
    endfor

    for my.module.callback
        component_resolve_callback (callback, my.module)
    endfor

    for my.module.method
        component_resolve_method (method, my.module)
    endfor

    for my.module.macros
        component_resolve_macros (macros, my.module)
    endfor

    for my.module.macroses
        component_resolve_macroses (macroses, my.module)
    endfor
endfunction

# ###########################################################################
#   Function for creation widely used components
# ###########################################################################

# ---------------------------------------------------------------------------
#   Add 'impl' argument to the destination with 'readwrite' access.
# ---------------------------------------------------------------------------
function component_create_argument_impl (destination)
    check_arguments (my, "destination", my)

    my.argument = item_prepend_new ("argument", my.destination)
    scope my.argument
        .name = "impl"
        .class = "impl"
        .access = "readwrite"
    endscope
    return my.argument
endfunction

# ---------------------------------------------------------------------------
#   Add 'impl' argument to the destination with 'disown' access.
# ---------------------------------------------------------------------------
function component_create_argument_impl_ref (destination)
    check_arguments (my, "destination", my)

    new argument to my.destination
        .name = "impl"
        .class = "impl"
        .access = "disown"
        return argument
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Add constant 'begin' to the destination with optional value, default 0.
# ---------------------------------------------------------------------------
function component_create_constant_begin (destination, value)
    check_arguments (my, "destination", my)

    new constant to my.destination
        .name = "begin"
        .value = my.value ? "0"

        return constant
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Add constant 'end' to the destination.
# ---------------------------------------------------------------------------
function component_create_constant_end (destination)
    check_arguments (my, "destination", my)

    new constant to my.destination
        .name = "end"

        return constant
    endnew
endfunction

.endtemplate
