#   Copyright (C) 2015-2020 Virgil Security, Inc.
#
#   All rights reserved.
#
#   Redistribution and use in source and binary forms, with or without
#   modification, are permitted provided that the following conditions are
#   met:
#
#       (1) Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#
#       (2) Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in
#       the documentation and/or other materials provided with the
#       distribution.
#
#       (3) Neither the name of the copyright holder nor the names of its
#       contributors may be used to endorse or promote products derived from
#       this software without specific prior written permission.
#
#   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR
#   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#   DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
#   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
#   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
#   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
#   STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
#   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#   POSSIBILITY OF SUCH DAMAGE.
#
#   Lead Maintainer: Virgil Security Inc. <support@virgilsecurity.com>

# ---------------------------------------------------------------------------
#   GSL generation helpers.
# ---------------------------------------------------------------------------
#   This is a code generator helper built using the iMatix GSL code
#   generation language. See https://github.com/zeromq/gsl for details.
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------
#   Abort if argument with given name is not defined.
# ---------------------------------------------------------------------------
function check_argument (argument_scope, argument_name, caller)
    if ! defined (my.argument_scope)
        abort "check_argument: argument_scope is not defined."
    endif

    if ! defined (my.argument_name)
        abort "check_argument: argument_name is not defined."
    endif

    if ! defined (my.argument_scope.$(my.argument_name))
        abort "[$("FATAL":upper,block%-8s)]\
            $("Argument '$(my.argument_name:)' is not defined":no,block%-120s) \
            $(name (my.caller ? my.argument_scope):block)()"
    endif
endfunction

function check_arguments (argument_scope, argument_list, caller)
    check_argument (my, "argument_scope", my.caller)
    check_argument (my, "argument_list", my.caller)

    #   Remove spaces.
    while regexp.match ("([\\w]+)", my.argument_list, my.argument_name)
        my.argument_list = string.search_replace (my.argument_list, my.argument_name, "")
        check_argument (my.argument_scope, my.argument_name, my.caller)
    endwhile
endfunction

# ---------------------------------------------------------------------------
#   Return true if given value is defined and non zero.
# ---------------------------------------------------------------------------
function is_true (x)
    return defined (my.x) & my.x <> 0
endfunction

# ---------------------------------------------------------------------------
#   Return true if both values are defined and non zero.
# ---------------------------------------------------------------------------
function is_true_both (x, y)
    return is_true (my.x) & is_true (my.y)
endfunction

# ---------------------------------------------------------------------------
#   Return true if any of values are defined and non zero.
# ---------------------------------------------------------------------------
function is_true_any (x, y)
    return is_true (my.x) | is_true (my.y)
endfunction

# ---------------------------------------------------------------------------
#   Return true if given value is not defined or is zero.
# ---------------------------------------------------------------------------
function is_false (x)
    return ! defined (my.x) | my.x = 0
endfunction

# ---------------------------------------------------------------------------
#   Return true if both values are not defined or are zeroed.
# ---------------------------------------------------------------------------
function is_false_both (x, y)
    return is_false (my.x) & is_false (my.y)
endfunction

# ---------------------------------------------------------------------------
#   Return true value if given string is empty after trimming.
# ---------------------------------------------------------------------------
function string_empty (str)
    return ! defined (my.str) | (string.length (string.trim (my.str)) = 0)
endfunction

# ---------------------------------------------------------------------------
#   Return true value if given string is defined
#   and not empty after trimming.
# ---------------------------------------------------------------------------
function string_defined (str)
    return defined (my.str) & (string.length (string.trim (my.str)) > 0)
endfunction

# ---------------------------------------------------------------------------
#   Return true if both string are defined and equal.
# ---------------------------------------------------------------------------
function string_equal (str1, str2)
    return defined (my.str1) & defined (my.str2) & (string.lexcmp(my.str1, my.str2) = 0)
endfunction

# ---------------------------------------------------------------------------
#   Return true if given string is in the list.
#   List is as a comma separated alphanumeric strings.
#   i.e "public, private".
#   Note, comparison is case insensitive.
# ---------------------------------------------------------------------------
function string_in (str, list)

    if ! defined (my.str) | ! defined (my.list)
        return 0
    endif

    if ! regexp.match ("\\w", my.list)
        abort "$(name (my):): list is not defined or empty."
    endif

    #   Remove spaces.
    my.list = string.replace (my.list, " |")

    #   Convert to regex pattern.
    my.list = string.convch (my.list, ",", "|")
    my.list_pattern = "^($(my.list:lower))$"

    #   Compare.
    return regexp.match (my.list_pattern, "$(my.str:lower)")
endfunction

# ---------------------------------------------------------------------------
#   Return true if given XML item name is equal to the given string.
# ---------------------------------------------------------------------------
function item_equal (item, str)
    check_arguments (my, "item, str", my)

    return string_equal (name (my.item), my.str)
endfunction

# ---------------------------------------------------------------------------
#   Return true if given XML item name is in the list.
#   List is as a comma separated string with an item names.
#   i.e "public, private".
#   Note, comparison is case insensitive.
# ---------------------------------------------------------------------------
function item_in (item, list)
    check_arguments (my, "list", my)

    return string_in (name (my.item) ? "", my.list)
endfunction

# ---------------------------------------------------------------------------
#   Return true if given multiline string.
# ---------------------------------------------------------------------------
function string_multiline (str)
    check_argument (my, "str")

    return string.cntch (my.str, terminator) > 0
endfunction
# ---------------------------------------------------------------------------
#   Return true if given element is XML item, not value.
# ---------------------------------------------------------------------------
function is_item (element)
    return class (my.element) = "XML item"
endfunction

# ---------------------------------------------------------------------------
#   Return true if given element contains description.
# ---------------------------------------------------------------------------
function has_description (element)
    return defined (my.element) & string_defined (my.element.)
endfunction

# ---------------------------------------------------------------------------
#   Return true if given item defines at least one attribute from the list.
# ---------------------------------------------------------------------------
function has_one_of_attribute (item, attribute_list)
    check_arguments (my, "item, attribute_list", my)

    while regexp.match ("([\\w]+)", my.attribute_list, my.attribute_name)
        my.attribute_list = string.search_replace (my.attribute_list, my.attribute_name, "")

        if defined (my.item.$(my.attribute_name:))
            return 1
        endif
    endwhile

    return 0
endfunction

# ---------------------------------------------------------------------------
#   Return value of the first defined attribute, or nothing if all attributes
#   are not defined.
# ---------------------------------------------------------------------------
function get_one_of_attribute (item, attribute_list)
    check_arguments (my, "item, attribute_list", my)

    while regexp.match ("([\\w]+)", my.attribute_list, my.attribute_name)
        my.attribute_list = string.search_replace (my.attribute_list, my.attribute_name, "")

        if defined (my.item.$(my.attribute_name:))
            return my.item.$(my.attribute_name:)
        endif
    endwhile

    return
endfunction


# ---------------------------------------------------------------------------
#   Return attribute of the first defined attribute, or nothing if all
#   attributes are not defined.
# ---------------------------------------------------------------------------
function get_one_of_attribute_name (item, attribute_list)
    check_arguments (my, "item, attribute_list", my)

    while regexp.match ("([\\w]+)", my.attribute_list, my.attribute_name)
        my.attribute_list = string.search_replace (my.attribute_list, my.attribute_name, "")

        if defined (my.item.$(my.attribute_name:))
            return my.attribute_name
        endif
    endwhile

    return
endfunction

# ---------------------------------------------------------------------------
#   Transform number of tabs to correspond spaces.
# ---------------------------------------------------------------------------
function tabs (tab_count, tab_size)
    my.tab_count ?= 0
    my.tab_size ?= 4
    return " " * (my.tab_count * my.tab_size)
endfunction

# ---------------------------------------------------------------------------
#   Collapse spaces between words to 1 space in the string.
#   Expected one-line string.
# ---------------------------------------------------------------------------
function string_collapse_spaces (str)
    if string_empty (my.str)
        return my.str ?
    endif

    while regexp.match ("(\\w+[ ]{2,}\\w+)", my.str, my.char_spaces_char)
        #   Replace 2 or more spaces with one space.
        regexp.match ("([ ]{2,})", my.char_spaces_char, my.spaces)
        my.replacement = string.search_replace (my.char_spaces_char, my.spaces, " ")
        my.str = string.search_replace (my.str, my.char_spaces_char, my.replacement)
    endwhile

    return my.str
endfunction

# ---------------------------------------------------------------------------
#   Remove spaces and new lines right to the string.
# ---------------------------------------------------------------------------
function string_rtrim (str)
    check_argument (my, "str")

    return string.trim (my.str)
endfunction

# ---------------------------------------------------------------------------
#   Remove trailing white-spaces for each line of multi-line string.
# ---------------------------------------------------------------------------
function string_multi_rtrim (str)
    while regexp.match ("(.*[ ]+$(terminator))", my.str, my.raw_line)
        regexp.match ("(.*)[ ]+$(terminator)", my.str, my.replacement)
        my.str = string.search_replace (my.str, my.raw_line, my.replacement + terminator)
    endwhile

    return string_rtrim (my.str)
endfunction


# ---------------------------------------------------------------------------
#   Remove spaces and new lines left to the string.
# ---------------------------------------------------------------------------
function string_ltrim (str)
    check_argument (my, "str")

    if regexp.match ("^(.*)", my.str, my.first_line)
        regexp.match ("^\\s*(.*)", my.first_line, my.trimmed_first_string)
        return string.search_replace (my.str, my.first_line, my.trimmed_first_string)
    endif

    return ""
endfunction

# ---------------------------------------------------------------------------
#   Remove spaces and new lines left and right to the string.
# ---------------------------------------------------------------------------
function string_trim (str)
    check_argument (my, "str")

    return string_ltrim (string_rtrim (my.str))
endfunction

# ---------------------------------------------------------------------------
#   Remove empty lines before string and after string.
# ---------------------------------------------------------------------------
function string_trim_empty_lines (str)
    check_argument (my, "str")

    while regexp.match ("^([ ]*$(terminator))", my.str, my.raw_line)
        if ! string.prefixed(my.str, my.raw_line)
            last
        endif

        my.str = string.search_replace (my.str, my.raw_line, "")
    endwhile

    return string_rtrim (my.str)
endfunction


# ---------------------------------------------------------------------------
#   Remove spaces and given symbols from the string end.
# ---------------------------------------------------------------------------
function string_rtrim_symbol(str, symbol)
    check_arguments (my, "str, symbol", my)

    if regexp.match ("(.*)[$(my.symbol)]+[ ]*$", my.str, my.new_str)
        return my.new_str
    else
        return my.str
    endif
endfunction

# ---------------------------------------------------------------------------
#   Return trimmed string indented with a given tab count.
# ---------------------------------------------------------------------------
function string_indent (str, tab_count, tab_size)
    my.str ?= ""
    my.str = "$(my.str:left, no)"
    my.str = string_trim_empty_lines (my.str)
    my.indent = tabs (my.tab_count, my.tab_size)
    return my.indent + string.replace (my.str, "$(terminator)|$(terminator)$(my.indent)")
endfunction

# ---------------------------------------------------------------------------
#   Add double quotes to the given string.
# ---------------------------------------------------------------------------
function quote_string (str)
    check_argument (my, "str", my)

    return "\"$(my.str:)\""
endfunction

# ---------------------------------------------------------------------------
#   Make signe-line string from a multiline string.
# ---------------------------------------------------------------------------
function string_to_singleline (str)
    check_argument (my, "str")

    return string_trim(string_collapse_spaces(string.replace(my.str, "$(terminator)| ")))
endfunction

# ---------------------------------------------------------------------------
#   Return a string converted to a path, aka "one two" -> "one/two"
# ---------------------------------------------------------------------------
function string_to_path(str)
    my.str = string_collapse_spaces (my.str)

    if string_empty(my.str)
        return my.str
    endif

    my.path = string.replace (my.str, " |/")

    return my.path
endfunction

# ---------------------------------------------------------------------------
#   Collapse spaces between words to 1 space in the code.
#   Note, do not collapse spaces in macro formatting.
#   Note, do not collapse spaces in string literals.
#   Note, work for both single line and multiline strings.
# ---------------------------------------------------------------------------
function code_collapse_spaces (str)
    if string_empty (my.str)
        return my.str ?
    endif

    while regexp.match ('([^\\s#\\/"][ ]{2,}\\S+)', my.str, my.char_spaces_char)
        #   Replace 2 or more spaces with one space.
        regexp.match ("([ ]{2,})", my.char_spaces_char, my.spaces)
        my.replacement = string.search_replace (my.char_spaces_char, my.spaces, " ")
        my.str = string.search_replace (my.str, my.char_spaces_char, my.replacement)
    endwhile

    return my.str
endfunction

# ---------------------------------------------------------------------------
#   Return true if message with given level should be printed.
#   Allowed levels are (lower level activates all upper levels):
#       - fatal
#       - error
#       - warning
#       - info
#       - trace
#       - debug
# ---------------------------------------------------------------------------
function _C23_echo_is_level_active (level)
    check_argument (my, "level")

    my.echo_level = main.echo_level ? test.echo_level ? "debug"

    return ("$(my.level)" = "fatal"   & string_in (my.echo_level, "debug, trace, info, warning, error, fatal")) | \
           ("$(my.level)" = "error"   & string_in (my.echo_level, "debug, trace, info, warning, error")) | \
           ("$(my.level)" = "warning" & string_in (my.echo_level, "debug, trace, info, warning")) | \
           ("$(my.level)" = "info"    & string_in (my.echo_level, "debug, trace, info")) | \
           ("$(my.level)" = "trace"   & string_in (my.echo_level, "debug, trace")) | \
           ("$(my.level)" = "debug"   & string_in (my.echo_level, "debug"))
endfunction

# ---------------------------------------------------------------------------
#   Print given text if next precondition are satisfied:
#       - text is defined;
#       - echo_level is active - see _C23_echo_is_level_active() function.
#   Argument 'caller' is a function, that call this function.
# ---------------------------------------------------------------------------
function _C23_echo (text, level, caller)
    check_argument (my, "level")

    if ! defined (my.text)
        return
    endif

    if ! _C23_echo_is_level_active (my.level)
        return
    endif

    my.text = code_collapse_spaces (my.text)

    my.caller_echo_str = defined (my.caller) ?? "$(name (my.caller))()" ? ""

    if string.length (my.text) > 120 | string_multiline (my.text)
        my.echo_text = "[$(my.level:upper,block%-8s)]$(" ":no,block%-124s)$(my.caller_echo_str:block)"
        my.echo_text += terminator + string_indent (my.text, 21, 1)
    else
        my.echo_text = "[$(my.level:upper,block%-8s)]\
            $(my.text:no,block%-120s) \
            $(my.caller_echo_str:no,block)"
    endif

    echo string_rtrim (my.echo_text)
endfunction

function _C23_echo_item (item, level, caller)
    check_argument (my, "level")

    if ! defined (my.item) | ! is_item (my.item)
        return
    endif

    if ! _C23_echo_is_level_active (my.level)
        return
    endif

    my.caller_echo_str = defined (my.caller) ?? "$(name (my.caller))()" ? ""

    my.echo_text = "[$(my.level:upper,block%-8s)]\
        $("Dump item <$(name (my.item))/>...":no,block%-120s) \
        $(my.caller_echo_str:no,block)"

    my.item_name = name (my.item)
    my.item_file = my.item_name + ".xml"
    my.item.save (my.item_file)
    xml_file_remove_prolog (my.item_file)
    my.item_text = file.slurp (my.item_file)
    file.delete (my.item_file)
    my.echo_text += terminator + string_indent (my.item_text, 6)

    echo string_rtrim (my.echo_text)

endfunction

function echo_fatal (text, caller)
    _C23_echo (my.text, "fatal", my.caller)
    abort
endfunction

function echo_error (text, caller)
    _C23_echo (my.text, "error", my.caller)
endfunction

function echo_warning (text, caller)
    _C23_echo (my.text, "warning", my.caller)
endfunction

function echo_info (text, caller)
    _C23_echo (my.text, "info", my.caller)
endfunction

function echo_trace (text, caller)
    _C23_echo (my.text, "trace", my.caller)
endfunction

function echo_debug (text, caller)
    _C23_echo (my.text, "debug", my.caller)
endfunction

function echo_debug_item (item, caller)
    _C23_echo_item (my.item, "debug", my.caller)
endfunction

# ---------------------------------------------------------------------------
#   Abort if attribute with given name is not defined within given scope.
# ---------------------------------------------------------------------------
function assert_attribute (attribute_scope, attribute_name, caller)
    check_argument (my, "attribute_scope")
    check_argument (my, "attribute_name")

    if ! defined (my.attribute_scope.$(my.attribute_name))
        my.name = " name=\"$(my.attribute_scope.name:)\"" ? ""
        echo_debug_item (my.attribute_scope)
        echo_fatal ("Attribute '$(my.attribute_name:)' is not defined \
                within <$(name (my.attribute_scope)) $(my.name:)/>", my.caller)
    endif
endfunction

# ---------------------------------------------------------------------------
#   Abort if one of the attributes from the given list is not defined within
#   given scope.
# ---------------------------------------------------------------------------
function assert_attributes (attribute_scope, attribute_list, caller)
    check_arguments (my, "attribute_scope, attribute_list", my.caller)

    while regexp.match ("([\\w]+)", my.attribute_list, my.attribute_name)
        my.attribute_list = string.search_replace (my.attribute_list, my.attribute_name, "")
        assert_attribute (my.attribute_scope, my.attribute_name, my.caller)
    endwhile
endfunction

# ---------------------------------------------------------------------------
#   Abort if attribute with given name is not defined within given scope or
#   attribute is not a number.
# ---------------------------------------------------------------------------
function assert_attribute_number (attribute_scope, attribute_name, caller)
    check_argument (my, "attribute_scope")
    check_argument (my, "attribute_name")

    assert_attribute (my.attribute_scope, my.attribute_name, my.caller)

    if ! regexp.match ("^\\d+$", my.attribute_scope.$(my.attribute_name:))
        my.name = " name=\"$(my.attribute_scope.name)\"" ? ""
        echo_fatal ("Attribute '$(my.attribute_name:)' defined" + \
                " within <$(name (my.attribute_scope)) $(my.name:)/> is not a number", my.caller)
    endif
endfunction

# ---------------------------------------------------------------------------
#   Abort if there is no elements with given name within given scope.
# ---------------------------------------------------------------------------
function assert_item (item_scope, item_name, caller)
    check_arguments (my, "item_scope, item_name", my)

    my.item_count = count (my.item_scope.$(my.item_name))
    if my.item_count = 0
        echo_debug_item (my.item_scope, my.caller)
        echo_fatal ("Item '$(name (my.item_scope))->$(my.item_name:)' is not defined.", my.caller)
    endif
endfunction

# ---------------------------------------------------------------------------
#   Abort if given argument has type that differs from given.
# ---------------------------------------------------------------------------
function assert_argument_type (argument, type, caller)
    check_argument (my, "argument")
    check_argument (my, "type")

    my.actual_type = name (my.argument) ?

    if ! defined (my.actual_type)
        echo_fatal ("Argument is not a type, but '$(class (my.argument))'", my.caller ? my)
    endif

    if my.actual_type <> my.type
        echo_fatal ("Argument has wrong type. \
                Was given <$(my.actual_type:)/>, expected <$(my.type)/>", my.caller ? my)
    endif
endfunction


# ---------------------------------------------------------------------------
#   Abort if 0 or more then 1 attributes from the list are given.
# ---------------------------------------------------------------------------
function assert_attribute_one_of (attribute_scope, attribute_list, caller)
    check_arguments (my, "attribute_scope, attribute_list", my)

    my.attributes_count = 0
    my.defined_attributes = ""
    my.list = my.attribute_list

    while regexp.match ("([\\w]+)", my.list, my.attribute_name)
        my.list = string.search_replace (my.list, my.attribute_name, "")

        if defined (my.attribute_scope.$(my.attribute_name:))
            my.attributes_count += 1

            if ! string_empty (my.defined_attributes)
                my.defined_attributes += ", "
            endif

            my.defined_attributes += my.attribute_name
        endif
    endwhile

    my.name = " name=\"$(my.attribute_scope.name)\"" ? ""

    if my.attributes_count = 0
        echo_fatal ("Expected one of the attributes: {$(my.attribute_list)} \
                within <$(name (my.attribute_scope)) $(my.name:)/>, to be defined.", my.caller)

    elsif my.attributes_count > 1
        echo_fatal ("Expected only one attribute of: {$(my.attribute_list)} \
                within <$(name (my.attribute_scope)) $(my.name:)/>, but met {$(my.defined_attributes)}.", my.caller)

    endif
endfunction


# ---------------------------------------------------------------------------
#   Change spaces balance in the code: remove redundant spaces.
# ---------------------------------------------------------------------------
function code_format (code)
    if string_empty (my.code)
        return my.code ?
    endif
    #   Remove spaces after parentheses.
    while regexp.match ("(\\( +)", my.code, my.spaces)
        my.code = string.replace (my.code, "$(my.spaces:)|(")
    endwhile
    #   Remove spaces before parentheses.
    while regexp.match ("( +\\))", my.code, my.spaces)
        my.code = string.replace (my.code, "$(my.spaces:)|)")
    endwhile
    #   Remove all spaces in macros function between name and parentheses.
    while regexp.match ("#\\s*define\\s+(\\w+\\s+\\()", my.code, my.macros_name_space_parentheses)
        #   Remove all spaces between name and parentheses.
        regexp.match ("(\\s+)", my.macros_name_space_parentheses, my.spaces)
        my.replacement = string.search_replace (my.macros_name_space_parentheses, my.spaces, "")
        my.code = string.search_replace (my.code, my.macros_name_space_parentheses, my.replacement)
    endwhile
    #   Remove all spaces before and after '->' symbol.
    while regexp.match ("((\\s+->)|(->\\s+))", my.code, my.pointer_access_symbol)
        #   Remove all spaces between name and parentheses.
        my.code = string.search_replace (my.code, my.pointer_access_symbol, "->")
    endwhile
    return my.code
endfunction

# ---------------------------------------------------------------------------
#   Insert given content as is to the current output.
#   If content is not defined new line is inserted.
# ---------------------------------------------------------------------------
.macro out (content)
.if ! defined (my.content)
.   return
.endif
$(my.content:)
.endmacro

# ---------------------------------------------------------------------------
#   Insert new line to the current output.
# ---------------------------------------------------------------------------
function newline (count)
    my.count ?= 1
    while my.count > 0
        out ("")
        my.count = my.count - 1
    endwhile
endfunction

# ---------------------------------------------------------------------------
#   Insert new line if given condition is true.
# ---------------------------------------------------------------------------
function newline_if (condition, count)
    if is_true (my.condition)
        newline (my.count)
    endif
endfunction

# ---------------------------------------------------------------------------
#   Read content between '@license ... @end' section and '@generated' line
#       and store it to 'context.content_before' attribute.
#   Read content between '@generated...@end' section and '@footer' line and
#       and store it to 'context.content_after' attribute.
# ---------------------------------------------------------------------------
function read_non_generated_content (source_file, context)
    if ! file.exists (my.source_file)
        return
    endif

    my.file_error = # undefined
    my.file_handle = file.open (my.source_file, "r", my.file_error)
    if defined (my.file_error)
        echo_fatal ("Can not open file '$(my.source_file:)'. " + my.file_error, my)
    endif

    my.empty_content = ""
    my.content_before = ""
    my.content_after = ""
    my.state = "init" # init ->
                      # found_license -> found_license_end ->
                      # found_generated -> found_generated_end ->
                      # found_footer -> found_end
    while defined (my.file_handle)
        my.line = my.file_handle.read (my.error)? ""
        if defined (my.error)
            # end of file
            my.content_before = string_trim (my.content_before)
            my.content_after = string_trim (my.content_after)
            last
        elsif my.state = "init" & regexp.match ("//\\s*@license", my.line)
            my.state = "found_license"
        elsif my.state = "found_license" & regexp.match ("//\\s*@end", my.line)
            my.state = "found_license_end"
        elsif my.state = "found_license_end"
            if regexp.match ("//\\s*@generated", my.line)
                my.state = "found_generated"
            else
                my.content_before += my.line
            endif
        elsif my.state = "found_generated" & regexp.match ("//\\s*@end", my.line)
            my.state = "found_generated_end"
        elsif my.state = "found_generated_end"
            if regexp.match ("//\\s*@footer", my.line)
                my.state = "found_footer"
            else
                my.content_after += my.line
            endif
        elsif my.state = "found_footer" & regexp.match ("//\\s*@end", my.line)
            my.state = "found_end"
        endif
    endwhile
    file.close (my.file_handle)
    my.context.content_before = my.content_before
    my.context.content_after = my.content_after
endfunction


# ---------------------------------------------------------------------------
#   Parse content after the block '@generated...@end' and collects functions
#   names and corresponding implementation body to the dictionary which then
#   returns:
#       <entities>
#           <entity name="..." body="..."/>
#       </entities>
# ---------------------------------------------------------------------------
function parse_handwritten_content (content)
    assert_attribute (my, "content", my)

    my.file_temp = "temp.file"

    my.file_error = # undefined

    my.file_handle = file.open (my.file_temp, "w", my.file_error)
    if defined (my.file_error)
        echo_fatal ("Can not open file for write '$(my.source_file:)'. " + my.file_error, my)
    endif

    file.write (my.file_handle, my.content, my.file_error)
    if defined (my.file_error)
        echo_fatal ("Can not write to file '$(my.source_file:)'. " + my.file_error, my)
    endif

    file.close (my.file_handle, my.file_error)
    if defined (my.file_error)
        echo_fatal ("Can not close file '$(my.source_file:)'. " + my.file_error, my)
    endif

    my.file_handle = file.open (my.file_temp, "r", my.file_error)
    if defined (my.file_error)
        echo_fatal ("Can not open file for read '$(my.source_file:)'. " + my.file_error, my)
    endif


    my.entities = XML.new ("entities")
    my.state = "find_name"
    my.function_name_pattern = "(\\w+)\\s?[(]"
    my.braces_counter = "0"
    my.function_body = ""

    while defined (my.file_handle)
        my.line = my.file_handle.read (my.error) ? ""

        if defined (my.error)
            last
        endif

        if my.state = "find_name" & string.prefixed (my.line, "//")
            next
        endif

        my.braces_counter += string.cntch (my.line, "{")
        my.braces_counter -= string.cntch (my.line, "}")

        if my.state = "find_name" & regexp.match (my.function_name_pattern, my.line, my.function_name)
            my.state = "name_found"
        endif

        if my.state = "name_found" & my.braces_counter = "1"
            my.state = "body_start_found"

        elsif my.state = "body_start_found" & my.braces_counter > "0"
            my.function_body += my.line

        elsif my.state = "body_start_found" & my.braces_counter = "0"
            my.state = "body_end_found"
        endif

        if my.state = "body_end_found"
            new entity to my.entities
                .name = my.function_name
                .body = my.function_body
            endnew

            my.function_name = # Undefine
            my.function_body = ""
            my.state = "find_name"
        endif
    endwhile


    file.close (my.file_handle)
    file.delete (my.file_temp)


    return my.entities
endfunction

# ---------------------------------------------------------------------------
#   Eliminate spaces that appears during code formatting within GSL scripts.
# ---------------------------------------------------------------------------
function code_remove_side_effects (code)
    my.code = "$(my.code:left,no)"
    my.code = string_trim (my.code)
    my.code = code_collapse_spaces (my.code)
    my.code = code_format (my.code)
    return my.code
endfunction

# ---------------------------------------------------------------------------
#   Insert given multiline code.
# ---------------------------------------------------------------------------
function format_code (body, tab_count)
    check_argument (my, "body")

    my.body = code_remove_side_effects (my.body)
    my.body = string_indent (my.body, my.tab_count)
    my.body = string_multi_rtrim (my.body)

    return my.body
endfunction

# ---------------------------------------------------------------------------
#   Trim and adjust content to the leftmost.
# ---------------------------------------------------------------------------
function format_left (body, tab_count)
    if ! defined (my.body)
        return
    endif

    return terminator + string_indent (my.body, my.tab_count)
endfunction

# ---------------------------------------------------------------------------
#   Insert given multiline code.
# ---------------------------------------------------------------------------
function insert_code (body, tab_count)
    check_argument (my, "body")

    out (format_code (my.body, my.tab_count))
endfunction

# ---------------------------------------------------------------------------
#   Return given title if it is new or differs from the previous one.
#   Function state is stored within 'context':
#       - context.previous_title
#       - context.current_title
# ---------------------------------------------------------------------------
function title_if_new (title, context)
    check_argument (my, "title")
    check_argument (my, "context")

    my.context.previous_title = my.context.current_title ?
    my.context.current_title = my.title

    my.is_new_title_detected = \
            ! defined (my.context.previous_title) | \
            ! string_equal (my.context.current_title, my.context.previous_title)

    return my.is_new_title_detected ?? my.context.current_title ?
endfunction

# ---------------------------------------------------------------------------
#   Return adjusted string according to rules:
#       - remove all trailing and leading spaces and newlines;
#       - prefix each line (if string is multiline) with given 'prefix';
#       - tab each line (if string is multiline) with given 'tabs';
#       - add new line before string;
#       - add new line after string;
#       - tab next line after string with given 'next tabs'.
# ---------------------------------------------------------------------------
function xml_string_adjust (str, tab_count, next_tab_count, prefix, tab_size)
    if string_empty (my.str)
        echo_debug ("Do nothing - given string is empty.", my)
        return
    endif
    my.tab_count ?= 0
    my.next_tab_count ?= 0
    my.prefix ?= ""
    my.str = "$(my.str:left, no)"
    my.str = string_trim (my.str)
    my.str = "$(my.prefix:)$(my.str:block, no)$(terminator)"
    my.str = string_trim (my.str)
    my.str = string_multi_rtrim (my.str)
    my.indent = tabs (my.tab_count, my.tab_size)
    my.str = string.replace (my.str, "$(terminator)|$(terminator)$(my.indent)")
    if my.next_tab_count < 0
        return terminator + my.indent + my.str
    else
        my.next_indent = tabs (my.next_tab_count, my.tab_size)
        return terminator + my.indent + my.str + terminator + my.next_indent
    endif
endfunction

# ---------------------------------------------------------------------------
#   Remove XML Prologue from the given file.
#   This action is required if given XML file acts as GSL model.
# ---------------------------------------------------------------------------
function xml_file_remove_prolog (file_name)
    if ! file.exists (my.file_name)
        abort "xml_file_remove_prolog: file does not exists: " + my.file_name
    endif
    my.content = file.slurp (my.file_name)
    while regexp.match ("(<[?].*[?]>)", my.content, my.prolog)
        my.content = string.replace (my.content, "$(my.prolog:)|")
    endwhile
    output my.file_name
        out (string_trim (my.content))
    close
endfunction

# ---------------------------------------------------------------------------
#   Perpend new component with given a 'name' to the 'parent_data', or
#   insert after given component if it is defined.
# ---------------------------------------------------------------------------
function item_prepend_new (name, parent_data, after_item)
    check_argument (my, "name")
    check_argument (my, "parent_data")

    if defined (my.after_item)
        new $(my.name:) after my.after_item
            return $(my.name:)
        endnew
    elsif count (my.parent_data.$(my.name:)) > 0
        new $(my.name:) before my.parent_data->$(my.name:)
            return $(my.name:)
        endnew
    else
        new $(my.name:) to my.parent_data
            return $(my.name:)
        endnew
    endif
endfunction

# ---------------------------------------------------------------------------
#   Replacement for GSL built-in '.copy <from-scope> to <parent-data>'.
#   Return reference to the copied element.
# ---------------------------------------------------------------------------
function item_copy_to (item, destination, alias)
    check_argument (my, "item")
    check_argument (my, "destination")

    my.temp_parent_data = XML.new ()

    if string_defined (my.alias)
        copy my.item to my.temp_parent_data as $(my.alias:)
    else
        copy my.item to my.temp_parent_data
    endif

    for my.temp_parent_data. as data
        my.item_ref = data
        move my.item_ref to my.destination
        return my.item_ref
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Replacement for GSL built-in '.copy <from-scope> after <item>'.
#   Return reference to the copied element.
# ---------------------------------------------------------------------------
function item_copy_after (item, after_item, alias)
    check_arguments (my, "item, after_item", my)

    my.temp_parent_data = XML.new ()

    if string_defined (my.alias)
        copy my.item to my.temp_parent_data as $(my.alias:)
    else
        copy my.item to my.temp_parent_data
    endif

    for my.temp_parent_data. as data
        my.item_ref = data
        move my.item_ref after my.after_item
        return my.item_ref
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Tab body to the depth level.
# ---------------------------------------------------------------------------
function item_format_body (item, depth)
    check_arguments (my, "item", my)

    my.depth ?= 1

    if defined (my.item.)
        my.item. = terminator + string_indent (my.item., my.depth) + \
                terminator + tabs (my.depth - 1)
    endif

    for my.item. as child_item where is_item (child_item)
        item_format_body (child_item, my.depth + 1)
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Return XML model loaded from the file, if success.
#   In any error - abort.
# ---------------------------------------------------------------------------
function item_load_from_file (file_name, destination, dir_path)
    check_argument (my, "file_name")

    my.dir_path = directory.resolve (my.dir_path) ?
    my.file_path = "$(my.dir_path?:)$(my.file_name:)"

    echo_trace ("Loading file: $(my.file_path:)", my)

    if ! file.exists (my.file_path)
        echo_fatal ("File does not exist: $(my.file_path:).", my)
    endif

    my.model = XML.load_file (my.file_path, my.error) ?
    if defined (my.error)
        echo_fatal ("Error loading file: $(my.file_path:). " + my.error, my)
    endif

    if defined (my.destination)
        move my.model to my.destination
    endif

    return my.model
endfunction

# ---------------------------------------------------------------------------
#   Save XML model to file.
#   In any error - abort.
# ---------------------------------------------------------------------------
function item_save_to_file (model, file_name, dir_path)
    check_arguments (my, "model, file_name", my)

    if defined (my.dir_path)
        my.dir_path = directory.resolve (my.dir_path) ?

        if directory.create (my.dir_path) = -1
            echo_fatal ("Can not create directory: $(my.dir_path:). ", my)
        endif
    endif


    my.model_name = name (my.model)
    if string_defined (my.model.name)
        my.model_name += " name=\"$(my.model.name:)\""
    endif

    my.file_path = "$(my.dir_path?:)$(my.file_name:)"
    echo_trace ("Saving <$(my.model_name)/> to the file: $(my.file_path:)", my)

    item_format_body (my.model)
    my.model.save (my.file_path, my.error)

    if defined (my.error)
        echo_fatal ("Error saving file: $(my.file_path:). " + my.error, my)
    endif

endfunction

# ---------------------------------------------------------------------------
#   Load XML models loaded from files located within 'dir_path'
#   and matched given pattern to the 'destination'.
# ---------------------------------------------------------------------------
function item_load_from_file_pattern (pattern, destination, dir_path)
    check_argument (my, "pattern")
    check_argument (my, "destination")
    check_argument (my, "dir_path")

    my.dir = directory.open (my.dir_path, my.error) ?
    if defined (my.error)
        echo_fatal ("Error open directory: " + my.error, my)
    endif

    for my.dir.file as f where regexp.match (my.pattern, f.name)
        my.model = item_load_from_file (f.name, , my.dir_path)
        move my.model to my.destination
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Return item with a given type and name that is found within source.
# ---------------------------------------------------------------------------
function item_find_named (source, type, name, caller)
    check_argument (my, "source")
    check_argument (my, "type")
    check_argument (my, "name")

    my.item = my.source->$(my.type:) (name = my.name) ?
    if ! defined (my.item)
        echo_fatal ("Item <$(my.type:) name=\"$(my.name:)\"> \
                is not found within <$(name (my.source))/>", my.caller ? my)
    endif

    return my.item
endfunction

# ---------------------------------------------------------------------------
#   Return formatted string constructed by concatenating parts separated by
#   spaces.
# ---------------------------------------------------------------------------
function cat (part1, part2, part3, part4, part5, part6, part7, part8)
    my.result = "$(my.part1 ?:) $(my.part2 ?:) $(my.part3 ?:) $(my.part4 ?:) " + \
                "$(my.part5 ?:) $(my.part6 ?:) $(my.part7 ?:) $(my.part8 ?:)"
    my.result = string_trim (my.result)
    my.result = string_collapse_spaces (my.result)
    return "$(my.result:)"
endfunction

# ---------------------------------------------------------------------------
#   Return formatted path string.
#   Note, path is not resolved.
# ---------------------------------------------------------------------------
function cat_path (part1, part2, part3, part4, part5, part6, part7, part8)
    my.result = "$(my.part1 ?:)/$(my.part2 ?:)/$(my.part3 ?:)/$(my.part4 ?:)/" + \
                "$(my.part5 ?:)/$(my.part6 ?:)/$(my.part7 ?:)/$(my.part8 ?:)/"

    my.result = ""
    my.result += string_defined (my.part1) ?? (my.part1 + "/") ? ""
    my.result += string_defined (my.part2) ?? (my.part2 + "/") ? ""
    my.result += string_defined (my.part3) ?? (my.part3 + "/") ? ""
    my.result += string_defined (my.part4) ?? (my.part4 + "/") ? ""
    my.result += string_defined (my.part5) ?? (my.part5 + "/") ? ""
    my.result += string_defined (my.part6) ?? (my.part6 + "/") ? ""
    my.result += string_defined (my.part7) ?? (my.part7 + "/") ? ""
    my.result += string_defined (my.part8) ?? (my.part8 + "/") ? ""

    #   Collapse path separators.
    while regexp.match ("\/\/", my.result)
        my.result = string.replace (my.result, "//|/")
    endwhile

    #   Trim trailing path separator.
    if regexp.match("(.+)\/$", my.result, my.trimmed_result)
        my.result = my.trimmed_result
    endif

    return my.result
endfunction

# ---------------------------------------------------------------------------
#   Return string with removed sequential duplicated words.
# ---------------------------------------------------------------------------
function remove_sequential_duplicated_words (str)
    check_argument (my, "str", my)

    my.result = ""
    my.prev_separator = ""
    while my.str <> ""

        my.word = string.prefix (my.str, "_ ")

        if ! string_defined (my.word)
            my.word = my.str
        endif

        my.separator_length = is_false (my.is_last_word) ?? "1" ? "0"
        my.separator = string.substr (my.str, string.length(my.word), , my.separator_length)
        my.str = string.substr (my.str, string.length(my.word) + my.separator_length)

        if ! string_equal (my.word, my.prev_word)
            my.result += my.prev_separator + my.word
        endif

        my.prev_word = my.word
        my.prev_separator = my.separator
    endwhile

    return my.result
endfunction

# ---------------------------------------------------------------------------
#   Return formatted string constructed by concatenating parts separated by
#   spaces and removed sequential duplicated words.
# ---------------------------------------------------------------------------
function cat_reduce (part1, part2, part3, part4, part5, part6, part7, part8)
    my.result = "$(my.part1 ?:) $(my.part2 ?:) $(my.part3 ?:) $(my.part4 ?:) " + \
                "$(my.part5 ?:) $(my.part6 ?:) $(my.part7 ?:) $(my.part8 ?:)"

    return remove_sequential_duplicated_words ( \
                cat (my.part1, my.part2, my.part3, my.part4, my.part5, my.part6, my.part7, my.part8))
endfunction


# ---------------------------------------------------------------------------
#   Return 'uid' as concatenated C like string.
# ---------------------------------------------------------------------------
function make_id (part1, part2, part3, part4, part5, part6, part7, part8)
    return "$(cat (\
            my.part1, my.part2, my.part3, my.part4, \
            my.part5, my.part6, my.part7, my.part8):c, lower)"
endfunction


# ---------------------------------------------------------------------------
#   Return true if given value is uid reference in format: .(<uid>)
# ---------------------------------------------------------------------------
function is_ref (maybe_ref)
    check_argument (my, "maybe_ref", my)

    return regexp.match ("^\\.\\(.+\\)$", my.maybe_ref)
endfunction

# ---------------------------------------------------------------------------
#   Return true if given value contains uid reference of format: .(<uid>)
# ---------------------------------------------------------------------------
function has_ref (maybe_ref)
    check_argument (my, "maybe_ref", my)

    return regexp.match ("\\.\\(.+\\)", my.maybe_ref)
endfunction

# ---------------------------------------------------------------------------
#   Wraps given UID as 'Reference UID'.
# ---------------------------------------------------------------------------
function ref (uid)
    check_argument (my, "uid", my)

    return ".($(my.uid:c,lower))"
endfunction

# ---------------------------------------------------------------------------
#   Wraps given UID as 'Reference UID' specific for C language.
# ---------------------------------------------------------------------------
function c_ref (uid)
    check_argument (my, "uid", my)

    return ".(c_$(my.uid:c,lower))"
endfunction

# ---------------------------------------------------------------------------
#   Wraps given UID as 'Reference UID' for specific language.
# ---------------------------------------------------------------------------
function make_ref (uid, lang)
    check_argument (my, "uid", my)

    if defined (my.lang) & string.prefixed (my.uid, "_")
        #    Shortcut
        return ".($(make_id (my.uid)))"
    else
        return ".($(make_id (my.lang, my.uid)))"
    endif
endfunction

# ---------------------------------------------------------------------------
#   Wraps given UID as 'Reference UID' specific for C language.
# ---------------------------------------------------------------------------
function make_ref_c (uid)
    check_argument (my, "uid", my)

    return make_ref (my.uid, "c")
endfunction

# ---------------------------------------------------------------------------
#   Wraps given UID as 'Reference UID' specific for Swift language.
# ---------------------------------------------------------------------------
function make_ref_swift (uid)
    check_argument (my, "uid", my)

    return make_ref (my.uid, "swift")
endfunction

# ---------------------------------------------------------------------------
#   Wraps given UID as 'Reference UID' specific for Python language.
# ---------------------------------------------------------------------------
function make_ref_python (uid)
    check_argument (my, "uid", my)

    return make_ref (my.uid, "python")
endfunction

# ---------------------------------------------------------------------------
#   Wraps given UID as 'Reference UID' specific for Java language.
# ---------------------------------------------------------------------------
function make_ref_java (uid)
    check_argument (my, "uid", my)

    return make_ref (my.uid, "java")
endfunction

# ---------------------------------------------------------------------------
#   Wraps given UID as 'Reference UID' specific for PHP language.
# ---------------------------------------------------------------------------
function make_ref_php (uid)
    check_argument (my, "uid", my)

    return make_ref (my.uid, "php")
endfunction

# ---------------------------------------------------------------------------
#   Wraps given UID as 'Reference UID' specific for Go language.
# ---------------------------------------------------------------------------
function make_ref_go (uid)
    check_argument (my, "uid", my)

    return make_ref (my.uid, "go")
endfunction

# ---------------------------------------------------------------------------
#   If given first parameter contains universal ref of format .(<uid>), then
#   return language specific ref of format .(<lang>_<uid>).
# ---------------------------------------------------------------------------
function lang_ref (maybe_ref, lang)
    check_arguments (my, "maybe_ref, lang", my)

    my.lang = "$(my.lang:lower)"
    my.valid_langs = "c, java, csharp, swift, python, wasm, go, php"

    if ! string_in (my.lang, my.valid_langs)
        echo_fatal ("Attempt to resolve reference for invalid language '$(my.lang:)'." + \
                " Supported languages are {$(my.valid_langs:)}", my)
    endif

    if regexp.match ("\\.\\(([^_)]+)([^)]+)?\\)", my.maybe_ref, my.maybe_lang, my.uid_tail)
        if defined (my.uid_tail) & my.maybe_lang = my.lang
            #   Already prefixed with requested language
            return my.maybe_ref
        elsif string_in (my.maybe_lang, my.valid_langs)
            echo_fatal ("Attempt to resolve already resolved reference for another language", my)
        else
            my.base_uid = my.maybe_lang + (my.uid_tail ? "")
            my.lang_uid = make_id (my.lang, my.base_uid)
            return string.search_replace (my.maybe_ref, my.base_uid, my.lang_uid)
        endif
    endif

    return my.maybe_ref
endfunction


# ---------------------------------------------------------------------------
#   Try to insert prefix after <lang> prefix.
#   Return modified string if success, otherwise return nothing.
# ---------------------------------------------------------------------------
function insert_prefix_after_lang_uid (uid, prefix, lang)
    check_arguments (my, "uid, prefix, lang", my)

    my.lang_prefix = my.lang + "_"

    if string.prefixed (my.uid, my.lang_prefix)
        return make_id (my.lang, my.prefix, string.search_replace(my.uid, my.lang_prefix, ""))
    endif

    return
endfunction


# ---------------------------------------------------------------------------
#   Add given prefix to the uid.
#   If given uid contains <lang> prefix, then given prefix will be inserted
#   immediately after it.
# ---------------------------------------------------------------------------
function uid_insert_prefix (uid, prefix)
    check_arguments (my, "uid", my)

    if ! defined (my.prefix)
        return my.uid
    endif

    my.new_uid ?= insert_prefix_after_lang_uid (my.uid, my.prefix, "c") ?
    my.new_uid ?= insert_prefix_after_lang_uid (my.uid, my.prefix, "java") ?
    my.new_uid ?= insert_prefix_after_lang_uid (my.uid, my.prefix, "csharp") ?
    my.new_uid ?= insert_prefix_after_lang_uid (my.uid, my.prefix, "swift") ?
    my.new_uid ?= insert_prefix_after_lang_uid (my.uid, my.prefix, "python") ?
    my.new_uid ?= insert_prefix_after_lang_uid (my.uid, my.prefix, "wasm") ?
    my.new_uid ?= insert_prefix_after_lang_uid (my.uid, my.prefix, "go") ?
    my.new_uid ?= make_id (my.prefix, my.uid)

    return my.new_uid
endfunction

# ---------------------------------------------------------------------------
#   Shortcut for lang_ref (my.maybe_ref, "c")
# ---------------------------------------------------------------------------
function c_lang_ref (maybe_ref)
    check_argument (my, "maybe_ref", my)

    return lang_ref (my.maybe_ref, "c")
endfunction

# ---------------------------------------------------------------------------
#   Shortcut for lang_ref (my.maybe_ref, "swift")
# ---------------------------------------------------------------------------
function swift_lang_ref (maybe_ref)
    check_argument (my, "maybe_ref", my)

    return lang_ref (my.maybe_ref, "swift")
endfunction

# ---------------------------------------------------------------------------
#   Shortcut for lang_ref (my.maybe_ref, "python")
# ---------------------------------------------------------------------------
function python_lang_ref (maybe_ref)
    check_argument (my, "maybe_ref", my)

    return lang_ref (my.maybe_ref, "python")
endfunction

# ---------------------------------------------------------------------------
#   Shortcut for lang_ref (my.maybe_ref, "java")
# ---------------------------------------------------------------------------
function java_lang_ref (maybe_ref)
    check_argument (my, "maybe_ref", my)

    return lang_ref (my.maybe_ref, "java")
endfunction

# ---------------------------------------------------------------------------
#   Shortcut for lang_ref (my.maybe_ref, "php")
# ---------------------------------------------------------------------------
function php_lang_ref (maybe_ref)
    check_argument (my, "maybe_ref", my)

    return lang_ref (my.maybe_ref, "php")
endfunction

# ---------------------------------------------------------------------------
#   Shortcut for lang_ref (my.maybe_ref, "wasm")
# ---------------------------------------------------------------------------
function wasm_lang_ref (maybe_ref)
    check_argument (my, "maybe_ref", my)

    return lang_ref (my.maybe_ref, "wasm")
endfunction

# ---------------------------------------------------------------------------
#   Shortcut for lang_ref (my.maybe_ref, "go")
# ---------------------------------------------------------------------------
function go_lang_ref (maybe_ref)
    check_argument (my, "maybe_ref", my)

    return lang_ref (my.maybe_ref, "go")
endfunction

# ###########################################################################
#   Debug helpers
# ###########################################################################

function foreach_dump (item_name, source, destination_dir)
    check_arguments (my, "item_name, source, destination_dir", my)

    for my.source.$(my.item_name) as item
        item_save_to_file (item, make_id (my.item_name, item.name?) + ".xml", my.destination_dir)
    endfor
endfunction

# ###########################################################################
#   Item inspection helpers
# ###########################################################################
function is_instance_of_generic_class (instance)
    check_arguments (my, "instance", my)

    my.class_name = my.instance.class ? my.instance.impl ?

    if defined (my.class_name)
        return !string_in (my.class_name, "data, buffer, error")
    else
        return "0"
    endif
endfunction
