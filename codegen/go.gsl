.template 0
#   Copyright (C) 2015-2010 Virgil Security Inc.
#
#   All rights reserved.
#
#   Redistribution and use in source and binary forms, with or without
#   modification, are permitted provided that the following conditions are
#   met:
#
#       (1) Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#
#       (2) Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in
#       the documentation and/or other materials provided with the
#       distribution.
#
#       (3) Neither the name of the copyright holder nor the names of its
#       contributors may be used to endorse or promote products derived from
#       this software without specific prior written permission.
#
#   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR
#   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#   DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
#   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
#   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
#   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
#   STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
#   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#   POSSIBILITY OF SUCH DAMAGE.
#
#   Lead Maintainer: Virgil Security Inc. <support@virgilsecurity.com>

# ---------------------------------------------------------------------------
#   Contains API for Go wrapper generation.
# ---------------------------------------------------------------------------
#   This is a code generator built using the iMatix GSL code generation
#   language. See https://github.com/imatix/gsl for details.
# ---------------------------------------------------------------------------

gsl from "common.gsl"
gsl from "interface.gsl"
gsl from "component.gsl"
gsl from "c_component.gsl"
gsl from "go_codegen.gsl"
gsl from "wrapper_helpers.gsl"

# ===========================================================================
#   C types derivation. TODO: extract this functions to separate GSL module.
# ===========================================================================

# ---------------------------------------------------------------------------
#   Return .(UID) that refers to the C instance shallow copy method.
# ---------------------------------------------------------------------------
function instance_derive_c_method_shallow_copy (instance)
    check_arguments (my, "instance", my)

    my.project_uid = component_derive_project_uid (my.instance)

    if has_one_of_attribute(my.instance, "interface")
        return make_ref_c (make_id (my.project_uid, "class", "impl", "method", "shallow copy"))

    elsif has_one_of_attribute(my.instance, "class, impl")
        return make_ref_c (make_id (my.project_uid, "class", my.instance.class ? my.instance.impl, "method", "shallow copy"))
    endif
endfunction

# ===========================================================================
#   Name and type derivation.
# ===========================================================================

# ---------------------------------------------------------------------------
#   Return formatted argument name.
# ---------------------------------------------------------------------------
function go_derive_argument_name (argument, go_project)
    check_arguments (my, "argument", my)

    return go_derive_argument_name_str (my.argument.name)
endfunction

# ---------------------------------------------------------------------------
#   Return formatted argument name from raw name.
# ---------------------------------------------------------------------------
function go_derive_argument_name_str (name, go_project)
    check_arguments (my, "name", my)

    if my.name = "error"
        return "err"
    else
        return "$(my.name:Camel)"
    endif
endfunction

# ---------------------------------------------------------------------------
#   Return invocation of the getter function that returns buffer length.
# ---------------------------------------------------------------------------
function go_derive_buffer_length_getter (class, method, argument)
    assert_attributes (my, "class, method, argument")

    assert_item (my.argument, "length", my)

    my.length = my.argument->length
    assert_attribute_one_of (my.length, "constant, argument, method", my)

    for my.length.proxy
        if ! defined (proxy.[to])
            echo_debug_item (my.argument, my)
            assert_attributes (proxy, "to", my)
        endif

        my.proxy_args ?= ""

        if ! first ()
            my.proxy_args += ", "
        endif

        if defined (proxy.argument)

            my.arg_name = go_derive_argument_name_str (proxy.argument)

            if string_in (proxy.cast, "data_length, str_length")
                my.proxy_args += "uint(len($(my.arg_name:)))"
            else
                my.is_interface = "0"
                for my.method.argument where string_equal (proxy.argument, argument.name)
                  if !string_empty (argument.interface)
                    my.is_interface = "1"
                  endif
                endfor

                if is_true (my.is_interface)
                    my.arg_interface = go_derive_interface_name_str (proxy.[to])
                    my.proxy_args += "$(my.arg_name:)\\.($(my.arg_interface:))"
                else
                    my.proxy_args += my.arg_name
                endif
            endif

        elsif defined (proxy.constant)
            my.proxy_args += go_lang_ref (proxy.constant)
        else
            echo_debug_item (my.argument, my)
            echo_fatal ("Buffer length argument can be proxied. Undefined type.", my)
        endif
    endfor

    my.specified_proxy_object = get_one_of_attribute (my.length, "class, interface, impl") ?
    if defined (my.specified_proxy_object)
        if my.specified_proxy_object = "self"
            my.specified_proxy_object = my.class.name
        endif
        my.proxy_object = go_derive_struct_name_str (my.specified_proxy_object)
        my.is_static_method = "1"
    else
        my.proxy_object = "obj"
    endif

    if defined (my.length.method)
        my.proxy_method = go_derive_func_name_str (my.length.method)
        if is_true (my.is_static_method)
            return "$(my.proxy_object:)$(my.proxy_method:)($(my.proxy_args?:)) /* lg1 */"
        else
            return "$(my.proxy_object:).$(my.proxy_method:)($(my.proxy_args?:)) /* lg2 */"
        endif

    elsif defined (my.length.constant)
        if string_equal (my.proxy_object, "obj")
            my.proxy_constant_func = go_derive_getter_name_str (my.length.constant)
            return "$(my.proxy_object:).$(my.proxy_constant_func:)() /* lg3 */"
        else
            return "$(my.proxy_object:)$(my.length.constant:Pascal) /* lg4 */"
        endif

    elsif defined (my.length.argument)
        my.proxy_argument = go_derive_argument_name_str (my.length.argument)

        if string_in (my.length.cast, "data_length")
            my.proxy_argument = "len($(my.proxy_argument:))"
        endif

        return my.proxy_argument
    endif
endfunction

# ---------------------------------------------------------------------------
#   Return formatted constant name.
# ---------------------------------------------------------------------------
function go_derive_constant_c_name (constant, proxy_name, go_project)
    check_arguments (my, "constant, proxy_name, go_project", my)

    my.constant_name = "$(my.constant:c)"
    return "$(my.go_project.prefix:)_$(my.proxy_name:c)_$(my.constant_name:UPPER)"
endfunction

# ---------------------------------------------------------------------------
#   Return formatted constant name.
# ---------------------------------------------------------------------------
function go_derive_constant_name (constant, instance, go_project)
    check_arguments (my, "constant, instance", my)

    assert_attribute (my.constant, "name", my)
    assert_attribute (my.instance, "name", my)

    if (my.instance.name = "status")
        return "$(my.go_project.name:Pascal)Error$(my.constant.name:Pascal)"
    else
        return "$(my.instance.name:Pascal)$(my.constant.name:Pascal)"
    endif
endfunction

# ---------------------------------------------------------------------------
#   Return type of the Go constant.
# ---------------------------------------------------------------------------
function go_derive_constant_type (constant, instance, go_project)
    #check_arguments (my, "constant, instance, go_project", my)

    if item_in (my.instance, "enum")
        if my.instance.name = "status"
            return "int"
        else
            return go_derive_enum_name (my.instance, my.go_project)
        endif
    elsif defined (my.constant.type)
        return go_derive_instance_type (my.constant)
    endif
    return "int"
endfunction

# ---------------------------------------------------------------------------
#   Return .(UID) that refers to the C type of the class.
# ---------------------------------------------------------------------------
function go_derive_c_type (instance)
    check_arguments (my, "instance", my)

    if item_in (my.instance, "interface")
        my.project_uid = c_component_derive_instance_project_uid (my.instance)
        my.type_uid = c_component_derive_instance_type_uid ("struct", "impl", "impl")
        return "$(make_ref_c (make_id(my.project_uid, my.type_uid)):) /*ct1*/"

    elsif item_in (my.instance, "class")
        return "$(make_ref_c (make_id ("class", my.instance.name, "struct", my.instance.name))) /*ct2*/"

    elsif defined (my.instance.class)
        if my.instance.class = "data"
            return ".(c_project_common_class_data_struct_data) /*ct3*/"

        elsif my.instance.class = "error"
            return "$(make_ref_c (make_id ("class", my.instance.class, "struct", my.instance.class))) /*ct4*/"

        else
            my.project_uid = c_component_derive_instance_project_uid (my.instance)
            my.type_uid = c_component_derive_instance_type_uid ("struct", my.instance.class, my.instance.class)
            return "$(make_ref_c (make_id(my.project_uid, my.type_uid)):) */*ct5*/"
        endif

    elsif defined (my.instance.interface)
        my.project_uid = c_component_derive_instance_project_uid (my.instance)
        my.type_uid = c_component_derive_instance_type_uid ("struct", "impl", "impl")
        return "$(make_ref_c (make_id(my.project_uid, my.type_uid)):) */*ct6*/"
    elsif defined (my.instance.impl)
        return "$(make_ref_c (make_id ("class", my.instance.impl, "struct", my.instance.impl))) * /*ct7*/"
    elsif defined (my.instance.type)
        if count (my.instance.array)
            return "$(my.instance.type:) */*ct8*/"
        else
            return my.instance.type
        endif
    elsif defined (my.instance.enum)
        my.project_uid = c_component_derive_instance_project_uid (my.instance)
        my.type_uid = make_id ("class", my.instance.enum, "enum", my.instance.enum)
        return "$(make_ref_c (make_id(my.project_uid, my.type_uid)):) /*ct9*/"
    endif

    return "$(make_ref_c (make_id ("class", my.instance.name, "struct", my.instance.name))) /*ct10*/"
endfunction

# ---------------------------------------------------------------------------
#   Return .(UID) of dependency type.
# ---------------------------------------------------------------------------
function go_derive_dependency_type (dependency)
    check_arguments (my, "dependency", my)

    my.project_uid = component_derive_project_uid (my.dependency)
    my.is_pointer = "0"

    if defined (my.dependency.interface)
        my.type_uid = make_id ("interface", "$(my.dependency.interface:Pascal)")

    elsif defined (my.dependency.api)
        my.type_uid = make_id ("interface", "$(my.dependency.api:Pascal)")

    elsif defined (my.dependency.class)
        my.type_uid = make_id ("struct", "$(my.dependency.class:Pascal)")
        my.is_pointer = "1"

    elsif defined (my.dependency.impl)
        my.type_uid = make_id ("struct", "$(my.dependency.impl:Pascal)")
        my.is_pointer = "1"

    else
        echo_debug_item (my.dependency, my)
        echo_fatal ("Unhanded dependency type.", my)
    endif

    if defined (my.dependency.project)
        return "$(my.dependency.project:).$(make_ref_go (make_id(my.project_uid, my.type_uid)))"
    endif

    if is_true (my.is_pointer)
        return "*$(make_ref_go (make_id(my.project_uid, my.type_uid)))"
    else
        return make_ref_go (make_id(my.project_uid, my.type_uid))
    endif
endfunction

# ---------------------------------------------------------------------------
#   Return formatted module name for enum.
# ---------------------------------------------------------------------------
function go_derive_enum_module_name (enum, go_project)
    check_arguments (my, "enum, go_project", my)

    assert_attribute (my.enum, "name", my)

    if my.enum.name = "status"
        return "$(my.go_project.name:C)_error"
    else
        return "$(my.enum.name:C)"
    endif
endfunction

# ---------------------------------------------------------------------------
#   Return formatted name of the Go enum.
# ---------------------------------------------------------------------------
function go_derive_enum_name (enum, go_project)
    check_arguments (my, "enum, go_project", my)

    assert_attribute_one_of (my.enum, "name", my)

    if my.enum.name = "status"
        return go_derive_enum_status_name (my.go_project)
    else
        return "$(my.enum.name:Pascal)"
    endif

endfunction

# ---------------------------------------------------------------------------
#   Return formatted name of the Go enum.
# ---------------------------------------------------------------------------
function go_derive_enum_status_name (go_project)
    check_arguments (my, "go_project", my)

    return "$(my.go_project.name:Pascal)Error"
endfunction

# ---------------------------------------------------------------------------
#   Return type of the Go enum.
# ---------------------------------------------------------------------------
function go_derive_enum_type (enum, go_project)
    check_arguments (my, "enum", my)
    if my.enum.name = "status"
        return "struct"
    endif

    return "int"

endfunction

# ---------------------------------------------------------------------------
#   Return formatted function name.
# ---------------------------------------------------------------------------
function go_derive_func_name (method, go_project)
    check_arguments (my, "method", my)

    return go_derive_func_name_str (my.method.name)
endfunction

# ---------------------------------------------------------------------------
#   Return formatted function name by constant.
# ---------------------------------------------------------------------------
function go_derive_func_name_by_constant (constant)
    check_arguments (my, "constant", my)

    assert_attribute (my.constant, "name", my)

    return go_derive_getter_name_str (my.constant.name)
endfunction

# ---------------------------------------------------------------------------
#   Return formatted function name.
# ---------------------------------------------------------------------------
function go_derive_func_name_str (name)
    check_arguments (my, "name", my)

    return "$(my.name:Pascal)"
endfunction

# ---------------------------------------------------------------------------
#   Return true if go function must throws.
# ---------------------------------------------------------------------------
function go_derive_func_throws (method)
    check_arguments (my, "method", my)

    if count (my.method.return, string_equal (return.enum, "status"))
        return "1"
    elsif count (my.method.argument, string_equal (argument.class, "error") & argument.access = "readwrite")
        return "1"
    else
        return "0"
    endif
endfunction

# ---------------------------------------------------------------------------
#   Return formatted getter name from raw name.
# ---------------------------------------------------------------------------
function go_derive_getter_name_str (name)
    check_arguments (my, "name", my)

    return "Get$(my.name:c, Pascal)"
endfunction

# ---------------------------------------------------------------------------
#   Return true if go method handle status returned from the C proxy.
# ---------------------------------------------------------------------------
function go_derive_handle_proxy_status(method)
    check_arguments (my, "method", my)

    return count (my.method.return, string_equal (return.enum, "status"))
endfunction

# ---------------------------------------------------------------------------
#   Return formatted instance name.
# ---------------------------------------------------------------------------
function go_derive_instance_name (instance)
    check_arguments (my, "instance", my)

    assert_attribute (my.instance, "name", my)

    return "$(my.instance.name:Camel)"
endfunction

# ---------------------------------------------------------------------------
#   Derive C type from the <instance/> type attributes.
# ---------------------------------------------------------------------------
function go_derive_instance_c_type (instance)
    check_arguments (my, "instance", my)

    if defined (my.instance.type)
        if my.instance.type = "nothing"
            my.primitive_type = "Void"

        elsif my.instance.type = "boolean"
            my.primitive_type = "C.bool"

        elsif my.instance.type = "integer"
            my.primitive_type = go_derive_integer_c_type (my.instance.size ?)

        elsif my.instance.type = "unsigned"
            my.primitive_type = go_derive_unsigned_c_type (my.instance.size ?)

        elsif my.instance.type = "byte"
            my.primitive_type = "C.byte"

        elsif my.instance.type = "size"
            my.primitive_type = "C.size_t"

        elsif my.instance.type = "char"
            if count(my.instance.string)
                my.primitive_type = "*C.char"
            else
                #TODO verify char type
                my.primitive_type = "C.uint8"
            endif
        else
            echo_fatal ("Unsupported instance type '$(my.instance.type)' for C language.", my)
        endif

        if is_true (my.instance.is_reference)
            if string_in (my.instance.access, "readonly")
                my.primitive_type = "*$(my.primitive_type:)"
            else
                my.primitive_type = "*$(my.primitive_type:)"
            endif
        endif

        if count (my.instance.array)
            if string_in (my.instance.access, "readonly")
                my.primitive_type = "*$(my.primitive_type:)"
            else
                my.primitive_type = "*$(my.primitive_type:)"
            endif
        endif

        return my.primitive_type
    endif

endfunction

# ---------------------------------------------------------------------------
#   Derive Go type from the <instance/> type attributes.
# ---------------------------------------------------------------------------
function go_derive_instance_type (instance)
    check_arguments (my, "instance", my)

    if defined (my.instance.type)
        if my.instance.type = "nothing"
            my.primitive_type = "Void"

        elsif my.instance.type = "boolean"
            my.primitive_type = "bool"

        elsif my.instance.type = "integer"
            my.primitive_type = go_derive_integer_type (my.instance.size ?)

        elsif my.instance.type = "unsigned"
            my.primitive_type = go_derive_unsigned_type (my.instance.size ?)

        elsif my.instance.type = "byte"
            my.primitive_type = "byte"

        elsif my.instance.type = "size"
            my.primitive_type = "uint"

        elsif my.instance.type = "char"
            if count(my.instance.string)
                my.primitive_type = "string"
            else
                #TODO verify char type
                my.primitive_type = "uint8"
            endif
        else
            echo_fatal ("Unsupported instance type '$(my.instance.type)' for Go language.", my)
        endif

        if is_true (my.instance.is_reference)
            if string_in (my.instance.access, "readonly")
                my.primitive_type = "unsafe.Pointer"
                #my.primitive_type = "[]$(my.primitive_type:)"
            else
                my.primitive_type = "unsafe.Pointer"
                #my.primitive_type = "[]$(my.primitive_type:)"
            endif
        endif

        if count (my.instance.array)
            if string_in (my.instance.access, "readonly")
                my.primitive_type = "[]$(my.primitive_type:)"
            else
                my.primitive_type = "[]$(my.primitive_type:)"
            endif
        endif

        return my.primitive_type

    elsif defined (my.instance.class)

        if my.instance.class = "any"
            return "Any"

        elsif my.instance.class = "data"
            return "Data"

        elsif my.instance.class = "buffer"
            return "Data"

        elsif my.instance.class = "str" | my.instance.class = "str buffer"
            return "string"

        elsif my.instance.class = "error"
            return class_derive_c_instance_type (my.instance)

        elsif is_ref (my.instance.class) | defined (my.instance.library)
            return go_lang_ref (my.instance.class)

        else
            my.project_uid = component_derive_project_uid (my.instance)
            my.type_uid = make_id ("struct", "$(my.instance.class:Pascal)")
            return make_ref_go (make_id(my.project_uid, my.type_uid))
        endif

    elsif defined (my.instance.impl)
        my.project_uid = component_derive_project_uid (my.instance)
        my.type_uid = make_id ("struct", "$(my.instance.impl:Pascal)")
        return make_ref_go (make_id(my.project_uid, my.type_uid))

    elsif defined (my.instance.interface)
        my.project_uid = component_derive_project_uid (my.instance)
        my.type_uid = make_id ("interface", "$(my.instance.interface:Pascal)")
        return make_ref_go (make_id(my.project_uid, my.type_uid))

    elsif defined (my.instance.enum)
        my.project_uid = component_derive_project_uid (my.instance)
        my.type_uid = make_id ("enum", "$(my.instance.enum:Pascal)")
        return make_ref_go (make_id(my.project_uid, my.type_uid))

    else
        my.instance_dump = component_instance_dump (my.instance)

        echo_warning ("Unreachable code, component_resolve_instance() must handle this. $(my.instance_dump:)", my)

        return "Unknown"
    endif
endfunction

# ---------------------------------------------------------------------------
#   Derive C integer type correspond to it's size.
#   Size: {1, 2, 4, 8}.
# ---------------------------------------------------------------------------
function go_derive_integer_c_type (size)
    if defined (my.size)
        if my.size = "1"
            return "C.int8_t"

        elsif my.size = "2"
            return "C.int16_t"

        elsif my.size = "4"
            return "C.int32_t"

        elsif my.size = "8"
            return "C.int64_t"
        else
            echo_fatal ("Unsupported size 'my.size' for Go integers", my)
        endif
    else
        return "C.int32_t"
    endif
endfunction

# ---------------------------------------------------------------------------
#   Derive Go integer type correspond to it's size.
#   Size: {1, 2, 4, 8}.
# ---------------------------------------------------------------------------
function go_derive_integer_type (size)
    if defined (my.size)
        if my.size = "1"
            return "int8"

        elsif my.size = "2"
            return "int16"

        elsif my.size = "4"
            return "int32"

        elsif my.size = "8"
            return "int64"
        else
            echo_fatal ("Unsupported size 'my.size' for Go integers", my)
        endif
    else
        return "int32"
    endif
endfunction

# ---------------------------------------------------------------------------
#   Return formatted name of the Go interface.
# ---------------------------------------------------------------------------
function go_derive_interface_name (interface, go_project)
    check_arguments (my, "interface, go_project", my)

    assert_attribute_one_of (my.interface, "name, interface", my)

    return go_derive_interface_name_str (my.interface.name ? my.interface.interface)
endfunction

# ---------------------------------------------------------------------------
#   Return formatted name of the Go interface.
# ---------------------------------------------------------------------------
function go_derive_interface_name_str (name)
    check_arguments (my, "name", my)

    return "$(my.name:Pascal)"
endfunction

# ---------------------------------------------------------------------------
#   Return formatted module name.
# ---------------------------------------------------------------------------
function go_derive_module_name (type)
    check_arguments (my, "type", my)

    assert_attribute (my.type, "name", my)

    return "$(my.type.name:C)"
endfunction

# ---------------------------------------------------------------------------
#   Return path to the package directory.
# ---------------------------------------------------------------------------
function go_derive_package_dir (project, wrapper)
    check_arguments (my, "project, wrapper", my)

    assert_attribute (my.project, "name", my)
    assert_attribute (my.wrapper, "package", my)

    my.package = go_derive_package_name (my.project, my.wrapper)

    return string.replace (my.package, ".|/")
endfunction

# ---------------------------------------------------------------------------
#   Return formatted package name.
# ---------------------------------------------------------------------------
function go_derive_package_name (project, wrapper)
    check_arguments (my, "project, wrapper", my)

    assert_attribute (my.project, "name", my)
    assert_attribute (my.wrapper, "package", my)

    return string.replace ("$(my.project.name:c,lower)", "_|.")
endfunction

# ---------------------------------------------------------------------------
#   Return proxy C type of the method return value.
# ---------------------------------------------------------------------------
function go_derive_proxy_return_c_type (method)
    check_arguments (my, "method", my)

    if ! count (my.method.return)
        return "Void"
    endif

    my.return = my.method->return

    if defined (my.return.type)
        return go_derive_instance_c_type (my.return) ?

    #TODO
    #elsif defined (my.return.enum)
    #    return make_ref_c (make_id ("class", my.return.enum, "enum", my.return.enum))

    #elsif has_one_of_attribute (my.return, "interface, class, impl")
    #    return "auto"
    endif

    return ""
endfunction

# ---------------------------------------------------------------------------
#   Return proxy type of the method return value.
# ---------------------------------------------------------------------------
function go_derive_proxy_return_type (method)
    check_arguments (my, "method", my)

    if ! count (my.method.return)
        return "Void"
    endif

    my.return = my.method->return

    if defined (my.return.type)
        return go_derive_instance_type (my.return)

    elsif defined (my.return.enum)
        return make_ref_c (make_id ("class", my.return.enum, "enum", my.return.enum))

    elsif has_one_of_attribute (my.return, "interface, class, impl")
        return "auto"
    endif

    return "Any"
endfunction

# ---------------------------------------------------------------------------
#   Return name of the class that handles multiple method's return values.
# ---------------------------------------------------------------------------
function go_derive_result_class_name (go_parent, go_func)
    check_arguments (my, "go_parent, go_func", my)

    return "$(my.go_func.interface ? my.go_parent.name:Pascal)$(my.go_func.name:Pascal)Result"
endfunction

# ---------------------------------------------------------------------------
#   Return C type for class context.
# ---------------------------------------------------------------------------
function go_derive_struct_context_c_type (class)
    return "/*sc1*/"
endfunction

# ---------------------------------------------------------------------------
#   Return C type for class context.
# ---------------------------------------------------------------------------
function go_derive_struct_context_type (class)
    check_arguments (my, "class", my)

    my.type = go_derive_c_type (my.class)
    return "*C.$(my.type:)"
endfunction

# ---------------------------------------------------------------------------
#   Return C type for class context.
# ---------------------------------------------------------------------------
function go_derive_struct_default_context_type ()
    return "*C.vscf_impl_t"
endfunction

# ---------------------------------------------------------------------------
#   Return C type for class context.
# ---------------------------------------------------------------------------
function go_derive_struct_public_context_type ()
    return "uintptr"
endfunction

# ---------------------------------------------------------------------------
#   Return formatted name of the Go struct.
# ---------------------------------------------------------------------------
function go_derive_struct_name (class, go_project)
    check_arguments (my, "class, go_project", my)

    assert_attribute_one_of (my.class, "name, class", my)

    return go_derive_struct_name_str (my.class.name ? my.class.class)
endfunction

# ---------------------------------------------------------------------------
#   Return formatted name of the Go struct.
# ---------------------------------------------------------------------------
function go_derive_struct_name_str (name)
    check_arguments (my, "name", my)

    return "$(my.name:Pascal)"
endfunction

# ---------------------------------------------------------------------------
#   Derive C unsigned integer type correspond to it's size.
#   Size: {1, 2, 4, 8}.
# ---------------------------------------------------------------------------
function go_derive_unsigned_c_type (size)
    if defined (my.size)
        if my.size = "1"
            return "C.uchar"

        elsif my.size = "2"
            return "C.ushort"

        elsif my.size = "4"
            return "C.uint"

        elsif my.size = "8"
            return "C.uint64_t"
        else
            echo_fatal ("Unsupported size 'my.size' for Go unsigned integers", my)
        endif
    else
        return "C.uint"
    endif
endfunction

# ---------------------------------------------------------------------------
#   Derive Go unsigned integer type correspond to it's size.
#   Size: {1, 2, 4, 8}.
# ---------------------------------------------------------------------------
function go_derive_unsigned_type (size)
    if defined (my.size)
        if my.size = "1"
            return "uint8"

        elsif my.size = "2"
            return "uint16"

        elsif my.size = "4"
            return "uint32"

        elsif my.size = "8"
            return "uint64"
        else
            echo_fatal ("Unsupported size 'my.size' for Go unsigned integers", my)
        endif
    else
        return "uint32"
    endif
endfunction

# ===========================================================================
#   Attribute mapping.
# ===========================================================================

# ---------------------------------------------------------------------------
#   Map attribute 'access' of <component/> to <go_component/>.
# ---------------------------------------------------------------------------
function go_map_attr_access (go_component, component)
    check_arguments (my, "go_component, component", my)

    assert_attribute (my.component, "access", my)

    my.go_component.access = my.component.access
endfunction

# ---------------------------------------------------------------------------
#   Map attribute 'scope' of <component/> to <go_component/>.
# ---------------------------------------------------------------------------
function go_map_attr_scope (go_component, component)
    check_arguments (my, "go_component, component", my)

    my.go_component.scope = my.component.scope ? "public"
endfunction

# ---------------------------------------------------------------------------
#   Map attribute 'visibility' of <component/> to <go_component/>.
# ---------------------------------------------------------------------------
function go_map_attr_visibility (go_component, component)
    check_arguments (my, "go_component, component", my)

    assert_attribute (my.component, "visibility", my)

    my.go_component.visibility = my.component.visibility ? "public"
endfunction

# ---------------------------------------------------------------------------
#   Add entities for regular enum (not error codes).
# ---------------------------------------------------------------------------
function go_map_enum_default (go_interface, enum, go_project, meta)
    check_arguments (my, "go_interface, enum, go_project, meta")

    for my.enum.constant
        go_create_constant (constant, my.enum, my.go_interface, my.go_project, my.meta)
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Add entities specific for "status" enum.
# ---------------------------------------------------------------------------
function go_map_enum_status (go_struct, enum, go_module, go_project, meta)
    check_arguments (my, "go_struct, enum, go_module, go_project, meta")

    go_create_import ("", "fmt", my.go_module)

    new go_field to my.go_struct
        . = "/* Error status code. */"
        .name = "Code"
        .type = "int"
    endnew

    new go_field to my.go_struct
        . = "/* Error status message. */"
        .name = "Message"
        .type = "string"
    endnew

    my.switch_case = format_left ("switch (status) {")
    for my.enum.constant where 0.name <> "success"
        go_create_constant (constant, my.enum, my.go_struct, my.go_project, my.meta)

        my.case_value = \
                make_ref_c (make_id ("class", my.enum.name, "enum", my.enum.name, "constant", constant.name))
        my.msg = go_format_string (constant.)
        my.switch_case += format_left ("\
            case C.$(my.case_value:):
                return &$(my.go_struct.name:) {int(status), $(my.msg:)}
        ")
    endfor
    my.switch_case += format_left ("\
        }
    ")

    new go_func to my.go_struct
        . = ""
        .name = "Error"
        .visibility = "public"

        new go_code to go_func
            . = "\
                return fmt.Sprintf(\"$(my.go_struct.name:){code: %v message: %s}\", obj.Code, obj.Message)
            "
        endnew

        new go_return to go_func
            .type = "string"
        endnew
    endnew

    new go_func to my.go_struct
        . = "/* Check given C status, and if it's not \"success\" then raise correspond error. */"
        .name = "HandleStatus"
        .visibility = "internal"
        .throws = "1"
        .is_static = "1"

        new go_argument to go_func
            .name = "status"
            my.arg_type = make_ref_c (make_id ("class", my.enum.name, "enum", my.enum.name))
            .type = "C.$(my.arg_type:)"
        endnew

        my.success_constant = \
                make_ref_c (make_id ("class", my.enum.name, "enum", my.enum.name, "constant success"))

        new go_code to go_func
            . = format_left ("\
                if status != C.$(my.success_constant:) {
            ", 2)
            . += format_left (my.switch_case, 3)
            . += format_left ("\
                }
                return nil
            ", 2)
        endnew
    endnew

    new go_struct to my.go_module
        . = ""
        .name = "wrapError"

        new go_field to go_struct
            . = "/* Error. */"
            .name = "err"
            .type = "error"
        endnew

        new go_field to go_struct
            . = "/* Error message. */"
            .name = "msg"
            .type = "string"
        endnew

        new go_func to go_struct
            . = ""
            .name = "Error"
            .visibility = "public"

            new go_code to go_func
                . = "\
                    return fmt.Sprintf(\"%s: %v\", obj.msg, obj.err)
                "
            endnew

            new go_return to go_func
                .type = "string"
            endnew
        endnew

        new go_func to go_struct
            . = ""
            .name = "Unwrap"
            .visibility = "public"

            new go_code to go_func
                . = "\
                    return obj.err
                "
            endnew

            new go_return to go_func
                .type = "error"
            endnew
        endnew

    endnew
endfunction

# ---------------------------------------------------------------------------
#   Map <instance/> attributes to the <go_instance/> attributes.
# ---------------------------------------------------------------------------
function go_map_instance (go_instance, instance)
    check_arguments (my, "go_instance, instance", my)

    go_map_attr_access (my.go_instance, my.instance)
    go_map_instance_type (my.go_instance, my.instance)

    if item_in(my.instance, "argument") & my.instance.access = "disown" & \
            has_one_of_attribute(my.instance, "interface, impl, class")
        my.go_instance.c_type = class_derive_c_instance_type (my.instance)
        my.go_instance.method_shallow_copy = instance_derive_c_method_shallow_copy (my.instance)
    endif
endfunction

# ---------------------------------------------------------------------------
#   Map <instance/> attributes to the <go_instance type=""/> attributes.
# ---------------------------------------------------------------------------
function go_map_instance_type (go_instance, instance)
    check_arguments (my, "go_instance, instance", my)

    my.go_instance.type = go_derive_instance_type (my.instance)
    my.go_instance.c_type = go_derive_instance_c_type (my.instance) ?


    if defined (my.instance.type)
        my.go_instance.is_primitive_type = "1"

    elsif defined (my.instance.class)
        my.go_instance.is_class = "1"

        if my.instance.class = "any"
            my.go_instance.is_any = "1"

        elsif my.instance.class = "data"
            my.go_instance.is_data = "1"

        elsif my.instance.class = "buffer"
            my.go_instance.is_buffer = "1"

        elsif my.instance.class = "str buffer"
            my.go_instance.is_buffer = "1"

        elsif my.instance.class = "error"
            my.go_instance.is_error = "1"
            my.go_instance.method_reset = make_ref_c (make_id ("class error method reset"))
        endif

    elsif defined (my.instance.interface)
        my.go_instance.is_interface = "1"

    elsif defined (my.instance.enum)
        my.go_instance.is_enum = "1"

    elsif defined (my.instance.impl)
        my.go_instance.is_class = "1"
    endif

    my.go_instance.is_array = count (my.instance.array) ?? "1" ?
    my.go_instance.is_string = count (my.instance.string) ?? "1" ?
    my.go_instance.is_reference = my.instance.is_reference ?
endfunction

# ===========================================================================
#   Component resolution.
# ===========================================================================

# ---------------------------------------------------------------------------
#   Resolve UIDs for given component and all inner components.
# ---------------------------------------------------------------------------
function go_module_resolve_uids (go_component, parent_uid)
    check_arguments (my, "go_component", my)

    if defined (my.parent_uid) & string.prefixed (my.parent_uid, "go_module")
        my.parent_uid = # Undefined
    endif

    my.component_name = name (my.go_component)
    if  defined (my.parent_uid) & string.prefixed (my.component_name, "go_")
        regexp.match ("go_(.+)", my.component_name, my.component_name)
    endif

    my.go_component.uid = make_id (my.parent_uid, my.component_name, my.go_component.name)

    for my.go_component. as inner_component where is_item (inner_component) & defined (inner_component.name)
        go_module_resolve_uids (inner_component, my.go_component.uid)
    endfor
endfunction

# ===========================================================================
#   Module resolution.
# ===========================================================================

# ---------------------------------------------------------------------------
#   Add auto-resoving attributes:
#       - uid.
# ---------------------------------------------------------------------------
function go_module_resolve (go_module, go_project)
    check_arguments (my, "go_module, go_project", my)

    echo_trace ("Resolving <$(name (my.go_module)) name=\"$(my.go_module.name:)\"/>", my)

    assert_attribute (my.go_module, "name", my)

    #   Resolve UIDs
    go_module_resolve_uids (my.go_module)
endfunction

# ===========================================================================
#   Create functions.
# ===========================================================================

# ---------------------------------------------------------------------------
#   Create entity <go_argument/> from the entity <argument/>.
# ---------------------------------------------------------------------------
function go_create_argument (argument, destination, go_project, meta)
    check_arguments (my, "argument, destination, go_project, meta", my)

    assert_attributes (my.argument, "name", my)

    new go_argument to my.destination
        .name = go_derive_instance_name (my.argument)

        go_map_instance (go_argument, my.argument)

        return go_argument
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create <go_cgo_flag/> for <go_instance/>
# ---------------------------------------------------------------------------
function go_create_cgo_flag (name, platform, value, go_instance)
    check_arguments (my, "name, value, go_instance", my)

    new go_cgo_flag to my.go_instance
        .name = my.name
        .value = my.value
        .platform = my.platform?
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create <go_cgo_include/> for <go_instance/>
# ---------------------------------------------------------------------------
function go_create_cgo_include (unit_name, go_instance, go_project)
    check_arguments (my, "unit_name, go_instance", my)

    if count (my.go_instance.go_cgo_include, string_equal (go_import.import, my.unit_name))
        # already imported
    else
        new go_cgo_include to my.go_instance
            .unit_name = "virgil/crypto/$(my.go_project.name)/$(my.unit_name:)"
            #.unit_name = my.unit_name
        endnew
    endif
endfunction

# ---------------------------------------------------------------------------
#   Create <go_cgo_include/> for <go_instance/>
# ---------------------------------------------------------------------------
function go_create_cgo_include_instructions (go_module, go_project)
    go_create_cgo_include (my.go_project.c_umbrella_header, my.go_module, my.go_project)
endfunction

# ---------------------------------------------------------------------------
#   Create <go_cgo_include/> for <go_instance/>
# ---------------------------------------------------------------------------
function go_create_cgo_instructions (go_module, go_project)
    check_arguments (my, "go_module, go_project", my)

    # Define CGO instructions

    for my.go_project.cgo_link
        if defined (cgo_link.path)
            my.path = "${SRCDIR}/../pkg/$(cgo_link.path:)"
        else
            my.path = "${SRCDIR}/../pkg/$(cgo_link.platform:)_amd64"
        endif

        go_create_cgo_flag ("CFLAGS", cgo_link.platform, "-I$(my.path:)/include/", my.go_module)
        go_create_cgo_flag ("LDFLAGS", cgo_link.platform, "-L$(my.path:)/lib $(cgo_link.libraries:)", my.go_module)
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Create custom modules:
#       - module with base interface that handles C context.
# ---------------------------------------------------------------------------
function go_create_context_module (go_project, meta)
    check_arguments (my, "go_project, meta", my)

    if !is_true (my.go_project.is_context_used)
        return
    endif

    my.name = "context"

    new go_module to my.go_project
        . = "/* This is base interface for all types that wrap C interfaces. */"
        .name = my.name
        .package = my.go_project.package
        .package_dir = my.go_project.package_dir
        .source_file_name = "$(0.name:C).go"
        .source_file_path = cat_path (my.go_project.source_dir, 0.source_file_name)

        new go_license to go_module
            . = go_format_license (my.go_project->license) ?
        endnew

        go_create_cgo_include_instructions (go_module, my.go_project)

        for my.go_project.go_import
            copy go_import to go_module
        endfor

        new go_interface to go_module
            .name = my.name
            .visibility = "public"

            new go_func to go_interface
                . = "/* Get C context */"
                .name = "Ctx"
                .visibility = "public"

                my.type = go_derive_struct_public_context_type ()

                new go_return to go_func
                    .type = my.type
                    .access = "readonly"
                    .is_enum = "0"
                    .is_reference = "0"
                endnew
            endnew
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create custom modules:
#       - module with base interface that handles C context.
# ---------------------------------------------------------------------------
function go_create_custom_modules (source, go_project, meta)
    check_arguments (my, "source, go_project, meta", my)

    if !count (my.source.interface, scope = "public")
        return
    endif

    my.go_project.is_context_used = "1"

endfunction

# ---------------------------------------------------------------------------
#   Create <go_import/> for <go_instance/>
# ---------------------------------------------------------------------------
function go_create_import (id, path, go_instance)
    check_arguments (my, "path, go_instance", my)

    if count (my.go_instance.go_import, string_equal (go_import.path, my.path))
        # already imported
    else
        new go_import to my.go_instance
            if !string_empty (my.id)
                .id = my.id
            endif
            .path = my.path
        endnew
    endif
endfunction

# ---------------------------------------------------------------------------
#   Create <go_import/> for <go_module/> if method uses Buffer or Data.
# ---------------------------------------------------------------------------
function go_create_import_to_common (method, go_module)
    check_arguments (my, "method, go_module", my)
    return

    for my.method.argument
        if string_in (argument.class, "data, buffer")
            go_create_import (".", "virgil/common", go_module)
        endif
    endfor

    for my.method.return
        if string_in (return.class, "data, buffer")
            go_create_import (".", "virgil/common", go_module)
        endif
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Create enumeration <go_constant/> from the entity <constant/>
# ---------------------------------------------------------------------------
function go_create_constant (constant, instance, go_instance, go_project, meta)
    check_arguments (my, "constant, instance, go_instance, go_project, meta", my)

    assert_attribute (my.instance, "name", my)
    assert_attribute (my.constant, "name", my)

    if defined(my.constant.value)
        the_value = my.constant.value
    elsif defined(my.go_instance.last_value)
        the_value = my.go_instance.last_value + 1
    else
        the_value = 0
    endif
    my.go_instance.last_value = the_value

    new go_constant to my.go_instance
        . = go_format_description (my.constant) ?
        .name = go_derive_constant_name (my.constant, my.instance, my.go_project)
        .type = go_derive_constant_type (my.constant, my.instance, my.go_project)
        .value = the_value
    endnew

    return my.go_constant
endfunction

# ---------------------------------------------------------------------------
#   Create entity <go_func/> with 'Delete' method declaration.
# ---------------------------------------------------------------------------
function go_create_func_clear_declaration (destination, go_project, meta)
    check_arguments (my, "destination, go_project, meta", my)

    new go_func to my.destination
        . = go_format_comment ("Release underlying C context.")
        .name = "Delete"

        return go_func
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create entity <go_func/> with 'delete' method declaration.
# ---------------------------------------------------------------------------
function go_create_func_clear_declaration_private (destination, go_project, meta)
    check_arguments (my, "destination, go_project, meta", my)

    new go_func to my.destination
        . = go_format_comment ("Release underlying C context.")
        .name = "delete"

        return go_func
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create entity <go_func/> with <method/> declaration.
# ---------------------------------------------------------------------------
function go_create_func_declaration (class, method, destination, go_project, meta)
    check_arguments (my, "class, method, destination, go_project, meta", my)

    my.name = go_derive_func_name (my.method, my.go_project)
    new go_func to my.destination
        . = go_format_description (my.method) ?
        .name = "$(my.name:)"
        .throws = go_derive_func_throws (my.method)
        .handle_proxy_status = go_derive_handle_proxy_status (my.method)
        .interface = my.method.interface ?

        if ! defined (my.method.interface) & is_true (my.method.is_static)
            .is_static = "1"
        endif

        go_map_attr_visibility (go_func, my.method)

        for my.method.argument
            if argument.access <> "writeonly"
                go_create_argument (argument, go_func, my.go_project, my.meta)
            endif

            if (string_in (argument.class, "buffer") & string_in (argument.access, "readwrite, writeonly")) \
                | string_equal (argument.class, "str buffer")

                go_create_return_from_argument (my.class, my.method, argument, go_func, my.go_project, my.meta)
            endif
        endfor

        for my.method.return where ! string_equal (return.enum, "status")
            go_create_return (return, go_func, my.go_project, my.meta)
        endfor

        return go_func
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create entity <go_func/> from the entity <instance/>.
# ---------------------------------------------------------------------------
function go_create_func_from_constant (instance, constant, destination, go_project, meta)
    check_arguments (my, "instance, constant, destination, go_project, meta", my)

    new go_func to my.destination
        . = go_format_description (my.constant) ?
        .name = go_derive_func_name_by_constant (my.constant)
        .visibility = "public"

        if !item_in (my.instance, "interface")
            .is_static = "1"
        endif

        my.type = go_derive_constant_type (my.constant, my.instance, my.go_project)

        new go_return to go_func
            .type = my.type
            .access = "readonly"
            .is_enum = "0"
            .is_reference = "0"
        endnew

        if !item_in (my.destination, "go_interface")
            .is_implemented = "1"

            if defined (my.constant.value)
                new go_code to go_func
                    . = "\
                        return $(my.constant.value:)
                    "
                endnew
            else
                my.c_method = make_ref_c (make_id ("class", my.instance.name, "method", my.constant.name))
                new go_code to go_func
                    . = "\
                        return $(my.type:)(C.$(my.c_method:)())
                    "
                endnew
            endif
        endif

        return go_func
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Add <go_func/> with setter only that proxy dependency to the
#   C context.
# ---------------------------------------------------------------------------
function go_create_func_from_dependency (dependency, impl, destination, go_module, go_project, meta)
    check_arguments (my, "dependency, impl, destination, go_module, go_project, meta", my)

    new go_func to my.destination
        . = go_format_description (my.dependency) ?
        .name = go_derive_func_name_str (cat ("set", my.dependency.name))
        .visibility = "public"
        .throws = my.dependency.has_observers & my.dependency.is_observers_return_status

        go_create_import ("unsafe", "unsafe", my.go_module)

        my.arg_name = go_derive_argument_name (my.dependency)

        new go_argument to go_func
            .name = my.arg_name
            .type = go_derive_dependency_type (my.dependency)
        endnew

        new go_code to go_func
            if my.dependency.has_observers & my.dependency.is_observers_return_status
                my.result_var = "proxyResult := "
                my.enum_status = go_derive_enum_status_name (my.go_project)
                my.impl_handle_status = format_left ("
                    err := $(my.enum_status:)HandleStatus(proxyResult)
                    if err != nil {
                        return $(go_format_result_nil_args ("err", go_func, my.go_project):)
                    }
                ")
                my.method_return = format_left ("return nil")
            endif

            if defined (my.dependency.project)
                my.go_project.is_context_used = "1"
            endif

            . = format_left("\
                C.$(class_derive_c_method_release_dependency (my.impl, my.dependency))(obj.cCtx)
                $(my.result_var?:)C.$(class_derive_c_method_use_dependency (my.impl, my.dependency))(obj.cCtx,\
                        (*C.$(class_derive_c_instance_type(my.dependency)))(unsafe.Pointer($(my.arg_name:).Ctx())))
                $(my.impl_handle_status?:)
                runtime.KeepAlive($(my.arg_name:))
                runtime.KeepAlive(obj)
                $(my.method_return?:)
            ")
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create entity <go_func/> of from the interface entity <method/>.
# ---------------------------------------------------------------------------
function go_create_interface_func (interface, method, destination, go_project, meta)
    check_arguments (my, "interface, method, destination, go_project, meta", my)

    echo_debug ("Create method $(my.method.name:) for interface $(my.interface.name:)", my)

    my.go_func = go_create_func_declaration (my.interface, my.method, my.destination, my.go_project, my.meta)
    go_remove_error_arguments (my.go_func)
    return my.go_func
endfunction

# ---------------------------------------------------------------------------
#   Add all components related to the interface.
# ---------------------------------------------------------------------------
function go_create_interface_implementation (implementation, go_struct, go_module, go_project, meta)
    check_arguments (my, "implementation, go_struct, go_module, go_project, meta", my)

    for my.implementation.interface
        go_create_promoted (interface, my.go_struct, my.go_project, my.meta)

        for interface.constant
            go_create_func_from_constant (interface, constant, my.go_struct, my.go_project, my.meta)
        endfor

        for interface.method where wrapper_should_wrap_method(method)
            go_create_import_to_common (method, my.go_module)
            go_create_struct_func (my.implementation, method, my.go_struct, my.go_module, my.go_project, my.meta)
        endfor
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Create entity <go_promoted/> from the entity <inherit/>.
# ---------------------------------------------------------------------------
function go_create_promoted (inherit, destination, go_project, meta)
    check_arguments (my, "inherit, destination, go_project, meta", my)

    my.interface_name = go_derive_interface_name (my.inherit, my.go_project)
    echo_info ("Promote '$(my.destination.name:)' with '$(my.interface_name:)'", my)
    new go_promoted to my.destination
        .type = my.interface_name
    endnew

    #my.promoted_go_interface = my.go_project->go_interface(go_interface.name = my.interface_name) ?
    #if defined (my.promoted_go_interface)
    #    echo_debug ("Promote Go '$(my.destination.name:)' with '$(my.interface_name:)'", my)
    #    for my.promoted_go_interface.go_func
    #        echo_trace ("Copy Go function '$(go_func.name:)' to '$(my.destination.name:)'", my)
    #        copy go_func to my.destination
    #    endfor
    #else
    #    echo_debug ("Go interface '$(my.interface_name:)' not found", my)
    #endif
endfunction

# ---------------------------------------------------------------------------
#   Create entity <go_inherit/> from interface that defines C context.
# ---------------------------------------------------------------------------
function go_create_promoted_c_context (destination)
    check_arguments (my, "destination", my)

    new go_promoted to my.destination
        .type = "context"

        return go_promoted
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create entity <go_return/> from the entity <return/> if it is not
#   a status, otherwise nothing is created.
# ---------------------------------------------------------------------------
function go_create_return (return, destination, go_project, meta)
    check_arguments (my, "return, destination, go_project, meta", my)

    new go_return to my.destination
        go_map_instance (go_return, my.return)

        # When implementation wrapps an interface it could raise an error
        if !string_empty (my.return.interface)
            my.destination.throws = "1"
        endif

        return go_return
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create entity <go_return/> from the entity <argument/>.
# ---------------------------------------------------------------------------
function go_create_return_from_argument (class, method, argument, destination, go_project, meta)
    check_arguments (my, "class, method, argument, destination, go_project, meta", my)

    assert_attributes (my.argument, "name", my)

    new go_return to my.destination
        .name = go_derive_instance_name (my.argument)
        go_map_instance (go_return, my.argument)
        go_return.was_argument = "1"

        if string_equal (my.argument.class, "buffer") | string_equal (my.argument.class, "str buffer")
            go_return.length_getter = go_derive_buffer_length_getter (my.class, my.method, my.argument)
        endif

        return go_return
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create function which free struct resources.
# ---------------------------------------------------------------------------
function go_create_struct_close (go_struct, class, go_project, meta)
    check_arguments (my, "go_struct, class, go_project, meta", my)

    my.self_ctx = "obj.cCtx"

    if string_in (my.class.context, "public") & string_in (my.class.lifecycle, "none")
        my.dtor_invocation = "C..(c_global_method_dealloc)($(my.self_ctx:))"
    else
        my.dtor_invocation = "C.$(class_derive_c_destructor (my.class))($(my.self_ctx:))"
    endif

    my.func_clear = go_create_func_clear_declaration (my.go_struct, my.go_project, my.meta)
    new go_code to my.func_clear
        . = "\
            if obj == nil {
                return
            }
            runtime.SetFinalizer(obj, nil)
            obj.delete()
        "
    endnew

    my.func_clear = go_create_func_clear_declaration_private (my.go_struct, my.go_project, my.meta)
    new go_code to my.func_clear
        . = "\
            $(my.dtor_invocation:)
        "
    endnew
endfunction


# ---------------------------------------------------------------------------
#   Create <go_func/> from abstract entity <constructor/>.
# ---------------------------------------------------------------------------
function go_create_struct_constructor (class, constructor, destination, go_module, go_project, meta)
    check_arguments (my, "class, constructor, destination, go_module, go_project, meta", my)

    go_create_import ("", "runtime", my.go_module)

    my.struct_name = go_derive_struct_name (my.class, my.go_project)
    new go_func to my.destination
        . = go_format_description (my.constructor) ?
        .name = "$(my.constructor.name:Pascal)"
        .is_constructor = "1"
        .visibility = "public"

        for my.constructor.argument
            go_create_argument (argument, go_func, my.go_project, my.meta)
        endfor

        #   Wrap proxy call
        my.proxy_args = go_format_c_proxy_args (my.class, my.constructor)
        my.proxy_call = "C.$(class_derive_c_constructor (my.class, my.constructor.name))($(my.proxy_args:))"
        my.proxy_return_type = go_derive_struct_context_type (my.class) + "?"
        my.proxy_return_c_type = go_derive_struct_context_c_type (my.class) + "?"
        my.proxy_invocation = go_wrap_c_proxy_call (go_func, my.proxy_call, my.proxy_return_type, my.proxy_return_c_type, my.go_module, my.go_project)

        my.context_assignment = format_left ("
            obj := &$(my.struct_name:) {
                cCtx: proxyResult,
            }
            runtime.SetFinalizer(obj, (*$(my.struct_name:)).Delete)
            return obj
            ")

        new go_code to go_func
            my.method_body = ""
            my.method_body += my.proxy_invocation ? ""
            my.method_body += terminator + my.context_assignment ? ""

            . = my.method_body
        endnew

        new go_return to go_func
            .type = "*$(my.struct_name:)"
        endnew

        return go_func
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create entity <go_func/> of from the class entity <method/>.
# ---------------------------------------------------------------------------
function go_create_struct_default_constructor (go_struct, class, go_module, go_project, meta)
    check_arguments (my, "go_struct, class, go_module, go_project, meta", my)

    echo_debug ("Create constructor '$(my.go_struct.name:)'", my)

    go_create_import ("", "runtime", my.go_module)

    if string_in (my.class.context, "public") & string_in (my.class.lifecycle, "none")
        my.ctx_size_invocation = "C.$(class_derive_class_c_method_ctx_size (my.class))()"
        my.ctor_invocation = "C..(c_global_method_alloc)($(my.ctx_size_invocation:))"
    else
        my.ctor_invocation = "C.$(class_derive_c_constructor (my.class))()"
    endif

    my.struct_name = go_derive_struct_name (my.class, my.go_project)
    my.ctx_type = go_derive_struct_context_type (my.class)

    new go_func to my.go_struct
        .name = ""
        .is_constructor = "1"

        new go_code to go_func
            . = "
                ctx := $(my.ctor_invocation:)
                obj := &$(my.struct_name:) {
                    cCtx: ctx,
                }
                runtime.SetFinalizer(obj, (*$(my.struct_name:)).Delete)
                return obj
            "
        endnew

        new go_return to go_func
            .type = "*$(my.struct_name:)"
        endnew
    endnew

    new go_func to my.go_struct
        . = "
            /* Acquire C context.
            * Note. This method is used in generated code only, and SHOULD NOT be used in another way.
            */
        "
        .name = "WithCtx"
        .is_constructor = "1"
        .visibility = "private"

        new go_argument to go_func
            .name = "ctx"
            .type = my.ctx_type
        endnew

        new go_code to go_func
            . = "\
                obj := &$(my.struct_name:) {
                    cCtx: ctx,
                }
                runtime.SetFinalizer(obj, (*$(my.struct_name:)).Delete)
                return obj
            "
        endnew

        new go_return to go_func
            .type = "*$(my.struct_name:)"
        endnew
    endnew

    if string_in (my.class.lifecycle, "default")
        new go_func to my.go_struct
            . = "\
                /* Acquire retained C context.
                * Note. This method is used in generated code only, and SHOULD NOT be used in another way.
                */
            "
            .name = "Copy"
            .is_constructor = "1"
            .visibility = "private"

            new go_argument to go_func
                .name = "ctx"
                .type = go_derive_struct_context_type (my.class)
            endnew

            new go_code to go_func
                . = "\
                    obj := &$(my.struct_name:) {
                        cCtx: C.$(class_derive_c_method_shallow_copy (my.class))(ctx),
                    }
                    runtime.SetFinalizer(obj, (*$(my.struct_name:)).Delete)
                    return obj
                "
            endnew

            new go_return to go_func
                .type = "*$(my.struct_name:)"
            endnew
        endnew
    endif
endfunction

# ---------------------------------------------------------------------------
#   Create <go_field/> that handles underlying C context.
# ---------------------------------------------------------------------------
function go_create_struct_field_context (destination, instance, go_module)
    check_arguments (my, "destination, instance, go_module", my)

    go_create_import ("unsafe", "unsafe", my.go_module)

    new go_field to my.destination
        . = "/* Handle underlying C context. */"
        .name = "cCtx"
        .type = go_derive_struct_context_type (my.instance)
        .access = "readonly"
        .visibility = "public"
    endnew

    new go_func to my.destination
        . = "/* Handle underlying C context. */"
        .name = "Ctx"
        .visibility = "public"

        my.type = go_derive_struct_public_context_type ()
        new go_code to go_func
            .= "return $(my.type:)(unsafe.Pointer(obj.cCtx))"
        endnew

        new go_return to go_func
            .type = my.type
        endnew
    endnew

    return go_field
endfunction

# ---------------------------------------------------------------------------
#   Create entity <go_func/> of from the class entity <method/>.
# ---------------------------------------------------------------------------
function go_create_struct_func (class, method, destination, go_module, go_project, meta)
    check_arguments (my, "class, method, destination, go_module, go_project, meta", my)

    #   Create declaration
    my.go_func = go_create_func_declaration (my.class, my.method, my.destination, my.go_project, my.meta)

    #   Wrap proxy call
    my.proxy_args = go_format_c_proxy_args (my.class, my.method)
    my.proxy_call = "C.$(class_derive_c_method (my.class, my.method))($(my.proxy_args:))"
    my.proxy_return_type = go_derive_proxy_return_type (my.method)
    my.proxy_return_c_type = go_derive_proxy_return_c_type (my.method) ?
    my.proxy_invocation = go_wrap_c_proxy_call (my.go_func, my.proxy_call, my.proxy_return_type, my.proxy_return_c_type, my.go_module, my.go_project)

    #   Return result
    if count (my.go_func.go_return) = 1
        my.go_return = my.go_func->go_return

        my.return_err = ""
        if is_true (my.go_func.throws) & count (my.go_func.go_return, is_false (go_return.is_interface)) = 1
            my.return_err = ", nil"
        endif
        my.return_result = terminator + \
                format_left ("return $(go_wrap_c_returned_value (my.go_func->go_return, my.go_module, my.go_project))$(my.return_err:)")

    elsif count (my.go_func.go_return) > 1
        my.result_args = go_format_result_args (my.go_func, my.go_project)

        my.return_result = terminator + \
                format_left ("return $(my.result_args:)")
    else
        my.result_args = go_format_result_nil_args ("nil", my.go_func, my.go_project)
        my.return_result = terminator + \
                format_left ("return $(my.result_args:)")
    endif

    new go_code to my.go_func
        my.method_body = ""
        my.method_body += my.proxy_invocation ? ""
        my.method_body += my.return_result ? "/* no result */"

        . = my.method_body
    endnew

    #   Cleanup
    go_remove_error_arguments (my.go_func)

    return my.go_func
endfunction

# ---------------------------------------------------------------------------
#   Remove temporary create go arguments that handle information about
#   error context that is passed to the C proxy call.
# ---------------------------------------------------------------------------
function go_remove_error_arguments (go_func)
    check_arguments (my, "go_func", my)

    for my.go_func.go_argument where is_true (go_argument.is_error)
        delete go_argument
    endfor
endfunction

# ===========================================================================
#   Create modules.
# ===========================================================================

# ---------------------------------------------------------------------------
#   Create module with Go struct from the abstract 'class' notion.
# ---------------------------------------------------------------------------
function go_create_class_module (class, go_project, meta)
    check_arguments (my, "class, go_project, meta", my)

    echo_info ("Create <go_module/> from class: '$(my.class.name:)'", my)

    assert_attribute (my.class, "name", my)

    if string_in2 (my.class.name, "data, buffer, error, error message")
        #   Do not generate classes that can be mapped to the built-in types.
        return
    endif

    new go_module to my.go_project
        .name = go_derive_module_name (my.class)
        .package = my.go_project.package
        .package_dir = my.go_project.package_dir
        .source_file_name = 0.name + ".go"
        .source_file_path = cat_path (my.go_project.source_dir, 0.source_file_name)

        new go_license to go_module
            . = go_format_license (my.go_project->license) ?
        endnew

        go_create_cgo_include_instructions (go_module, my.go_project)

        for my.go_project.go_import
            copy go_import to go_module
        endfor

        new go_struct to go_module
            . = go_format_description (my.class) ?
            .name = go_derive_struct_name (my.class, my.go_project)

            go_map_attr_visibility (go_struct, my.class)

            if my.class.context <> "none"
                go_create_struct_field_context (go_struct, my.class, go_module)
                go_create_struct_default_constructor (go_struct, my.class, go_module, my.go_project, my.meta)
                go_create_struct_close (go_struct, my.class, my.go_project, my.meta)

                if ! string_in (my.class.lifecycle, "none")
                    for my.class.constructor where constructor.visibility <> "private"
                        go_create_struct_constructor (my.class, constructor, go_struct, go_module, my.go_project, my.meta)
                    endfor
                endif
            endif

            for my.class.constant where wrapper_should_wrap_class_constant(constant)
                go_create_constant (constant, my.class, go_struct, my.go_project, my.meta)
            endfor

            for my.class.dependency
                if defined (dependency.project)
                    go_create_import (dependency.project, "virgil/$(dependency.project:c)", go_module)
                endif
                go_create_func_from_dependency (dependency, my.class, go_struct, go_module, my.go_project, my.meta)
            endfor

            for my.class.method where wrapper_should_wrap_method(method)
                go_create_import_to_common (method, go_module)
                go_create_struct_func (my.class, method, go_struct, go_module, my.go_project, my.meta)
            endfor

            for go_struct.go_func
                for go_func.go_argument
                    if is_true (go_argument.is_interface)
                        go_create_import ("unsafe", "unsafe", go_module)
                    endif
                endfor
            endfor
        endnew
    endnew

    echo_debug ("Done", my)
endfunction

# ---------------------------------------------------------------------------
#   Create module with Go enum from the abstract 'enum' notion.
# ---------------------------------------------------------------------------
function go_create_enum_module (enum, go_project, meta)
    check_arguments (my, "enum, go_project, meta", my)

    echo_info ("Create <go_module/> from enum: '$(my.enum.name:)'", my)

    assert_attribute (my.enum, "name", my)

    new go_module to my.go_project
        .name = go_derive_enum_module_name (my.enum, my.go_project)
        .package = my.go_project.package
        .package_dir = my.go_project.package_dir
        .source_file_name = 0.name + ".go"
        .source_file_path = cat_path (my.go_project.source_dir, 0.source_file_name)

        new go_license to go_module
            . = go_format_license (my.go_project->license) ?
        endnew

        for my.go_project.go_import
            copy go_import to go_module
        endfor

        if my.enum.name = "status"
            go_create_cgo_include_instructions (go_module, my.go_project)

            new go_struct to go_module
                . = go_format_description (my.enum) ?
                .name = go_derive_enum_name (my.enum, my.go_project)

                go_map_enum_status (go_struct, my.enum, go_module, my.go_project, my.meta)
            endnew
        else
            new go_enum to go_module
                . = go_format_description (my.enum) ?
                .name = go_derive_enum_name (my.enum, my.go_project)
                .type = go_derive_enum_type (my.enum, my.go_project)

                go_map_attr_visibility (go_enum, my.enum)
                go_map_attr_scope (go_enum, my.enum)

                go_map_enum_default (go_enum, my.enum, my.go_project, my.meta)
            endnew
        endif
    endnew

    echo_debug ("Done", my)
endfunction

# ---------------------------------------------------------------------------
#   Create module with Go interface from the abstract 'interface' notion.
# ---------------------------------------------------------------------------
function go_create_interface_module (interface, go_project, meta)
    check_arguments (my, "interface, go_project, meta", my)

    echo_info ("Create <go_module/> from interface: '$(my.interface.name:)'", my)

    new go_module to my.go_project
        .name = "$(go_derive_module_name (my.interface):)"
        .package = my.go_project.package
        .package_dir = my.go_project.package_dir
        .source_file_name = 0.name + ".go"
        .source_file_path = cat_path (my.go_project.source_dir, 0.source_file_name)

        new go_license to go_module
            . = go_format_license (my.go_project->license) ?
        endnew

        for my.go_project.go_import
            copy go_import to go_module
        endfor

        new go_interface to go_module
            . = go_format_description (my.interface) ?
            .name = go_derive_interface_name (my.interface, my.go_project)

            go_map_attr_visibility (go_interface, my.interface)

            go_create_promoted_c_context (go_interface)
            #for my.interface.inherit
            #    go_create_promoted (inherit, go_interface, my.go_project, my.meta)
            #else
            #    go_create_promoted_c_context (go_interface)
            #endfor

            for my.interface.constant
                go_create_func_from_constant (my.interface, constant, go_interface, my.go_project, my.meta)
            endfor

            for my.interface.method where wrapper_should_wrap_method(method)
                go_create_interface_func (my.interface, method, go_interface, my.go_project, my.meta)
            endfor

            for go_interface.go_func where count (0.go_return) > 1
                # TODO no needs in result class
                #go_create_result_class (go_interface, go_field, my.go_project, my.meta)
            endfor

            for go_interface.go_func
                for go_func.go_return
                    if string_equal (go_return.type, "unsafe.Pointer")
                        go_create_import ("unsafe", "unsafe", go_module)
                    endif
                endfor
            endfor

            go_create_func_clear_declaration (go_interface, my.go_project, my.meta)
        endnew
    endnew

    echo_debug ("Done", my)
endfunction

# ---------------------------------------------------------------------------
#   Create module that contains Go specific project information.
# ---------------------------------------------------------------------------
function go_create_project_module (project, wrapper)
    check_arguments (my, "project, wrapper", my)

    assert_attribute (my.wrapper, "lang", my)
    assert_attributes (my.project, "name, prefix, framework", my)
    assert_item (my.project, "license", my)

    echo_info ("Create Go project for project: '$(my.project.name:)'", my)

    new go_project to my.wrapper
        . = my.project. ?
        .name = my.project.name
        .prefix = my.project.prefix
        .package = go_derive_package_name(my.project, my.wrapper)
        .package_dir = go_derive_package_dir(my.project, my.wrapper)
        .source_dir = cat_path (my.wrapper.source_dir, my.project.name)
        .c_umbrella_header = make_ref_c (make_id ("header", my.project.name, "public"))

        for my.project.cgo_link
            copy cgo_link to go_project
        endfor

        copy my.project->license to go_project

        new go_uid to go_project
            .name = go_project.package
            .uid = "go_import_name"
        endnew

        go_create_import("", "C", go_project)

        return go_project
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create module with Go structure from the abstract 'implementation' notion.
# ---------------------------------------------------------------------------
function go_create_implementation_module (implementation, go_project, meta)
    check_arguments (my, "implementation, go_project, meta", my)

    if my.implementation.scope <> "internal"
        echo_info ("Create <go_module/> from implementation: '$(my.implementation.name:)'", my)
    else
        echo_info ("Skip creating <go_module/> from internal implementation: '$(my.implementation.name:)'", my)
    endif

    new go_module to my.go_project
        .name = go_derive_module_name (my.implementation)
        .package = my.go_project.package
        .package_dir = my.go_project.package_dir
        .source_file_name = 0.name + ".go"
        .source_file_path = cat_path (my.go_project.source_dir, 0.source_file_name)

        new go_license to go_module
            . = go_format_license (my.go_project->license) ?
        endnew

        go_create_cgo_include_instructions (go_module, my.go_project)

        for my.go_project.go_import
            copy go_import to go_module
        endfor

        new go_struct to go_module
            . = go_format_description (my.implementation) ?
            .name = go_derive_struct_name (my.implementation, my.go_project)

            go_map_attr_visibility (go_struct, my.implementation)

            for my.implementation.constant where wrapper_should_wrap_class_constant(constant)
                go_create_constant (constant, my.implementation, go_struct, my.go_project, my.meta)
            endfor

            for my.implementation.dependency
                go_create_func_from_dependency (dependency, my.implementation, go_struct, go_module, my.go_project, my.meta)
            endfor

            for my.implementation.method where wrapper_should_wrap_method(method)
                go_create_import_to_common (method, go_module)
                go_create_struct_func (my.implementation, method, go_struct, go_module, my.go_project, my.meta)
            endfor

            if my.implementation.context <> "none"

                go_create_struct_field_context (go_struct, my.implementation, go_module)

                go_create_struct_default_constructor (go_struct, my.implementation, go_module, my.go_project, my.meta)
                go_create_struct_close (go_struct, my.implementation, my.go_project, my.meta)

                if my.implementation.lifecycle <> "none"
                    for my.implementation.constructor where wrapper_should_wrap_method(constructor)
                        go_create_struct_constructor (my.implementation, constructor, go_struct, go_module, my.go_project, my.meta)
                    endfor
                endif
            endif

            go_create_interface_implementation (my.implementation, go_struct, go_module, my.go_project, my.meta)
            go_update_implementation_helper_module (my.implementation, my.go_project, my.meta)
        endnew
    endnew

    echo_debug ("Done", my)
endfunction

# ---------------------------------------------------------------------------
#   Perform finalization for custom modules.
# ---------------------------------------------------------------------------
function go_finalize_custom_modules (source, go_project, meta)
    check_arguments (my, "source, go_project, meta", my)

    go_finalize_implementation_helper_modules (my.go_project, my.meta)
endfunction

# ---------------------------------------------------------------------------
#   Return formatted arguments list that is to by passed to the C method.
# ---------------------------------------------------------------------------
function go_format_c_proxy_args (class, method)
    check_arguments (my, "class, method", my)

    if is_false (my.method.is_static)
        my.proxy_args = "obj.cCtx"

    elsif defined (my.method.implementation)
        my.proxy_args = ""

    elsif defined (my.method.interface)
        my.proxy_args = "C.$(interface_derive_c_api_method_from_name(my.method.interface))(obj.cCtx)"
    endif

    for my.method.argument
        my.proxy_args ?= ""
        if my.proxy_args <> ""
            my.proxy_args += ", "
        endif

        my.arg_name = go_derive_instance_name (argument)
        my.arg_c_type = go_derive_instance_c_type (argument) ?

        my.proxy_arg = # undefined

        if string_equal (argument.class, "data")
            my.proxy_arg = "$(my.arg_name:)Data"

        elsif string_equal (argument.class, "buffer")
            my.proxy_arg = "$(my.arg_name:)Buf.ctx"

        elsif string_equal (argument.class, "str buffer")
            my.proxy_arg = "$(my.arg_name:)Buf"

        elsif string_equal (argument.class, "error")
            my.proxy_arg = "&$(my.arg_name:)"

        elsif has_one_of_attribute (argument, "class, api, interface, impl")
            if argument.access = "disown"
                my.proxy_arg = "$(my.arg_name:)Copy"
            else
                my.arg_c_type = class_derive_c_instance_type (argument)
                if string_equal (argument.class, "str")
                  my.proxy_arg = "$(my.arg_name:)Str"
                else
                  my.proxy_arg = "(*C.$(my.arg_c_type:))(unsafe.Pointer($(my.arg_name:).Ctx()))"
                endif
            endif

        elsif defined (argument.enum)
            my.enum_type = class_derive_c_instance_type (argument)
            my.proxy_arg = "C.$(my.enum_type:)($(my.arg_name:)) /*pa7*/"

        else
            if defined (my.arg_c_type)
                if string_equal (my.arg_c_type, "*C.byte")
                    my.proxy_arg = "helperBytesToBytePtr($(my.arg_name:))/*pa8*/"
                elsif string_equal (my.arg_c_type, "*C.char")
                    my.proxy_arg = "$(my.arg_name:)Str/*pa9*/"
                else
                    my.proxy_arg = "($(my.arg_c_type:))($(my.arg_name:))/*pa10*/"
                endif
            else
                my.proxy_arg = "$(my.arg_name:) /*pa11*/"
            endif
        endif

        if defined (my.proxy_arg) & argument.access = "disown"
            my.proxy_arg = "&" + my.proxy_arg
        endif

        my.proxy_args += my.proxy_arg ? ""
    endfor

    return my.proxy_args ? ""
endfunction

# ---------------------------------------------------------------------------
#   Return formatted string with code that makes proxy call:
#       - type mapping
#       - proxy call
#       - finalizing
# ---------------------------------------------------------------------------
function go_wrap_c_proxy_call (go_func, proxy_call, proxy_return_type, proxy_return_c_type, go_module, go_project)
    check_arguments (my, "go_func, proxy_call, proxy_return_type, go_module, go_project", my)

    #  Wrap errors.
    for my.go_func.go_argument where is_true (go_argument.is_error)
        my.errors_instantiation ?= terminator
        my.errors_instantiation += format_left("\
            var $(go_argument.name:) C.$(go_argument.type:)
            C.$(go_argument.method_reset:)(&$(go_argument.name:))
        ")

        my.errors_handling ?= terminator
        my.enum_status = go_derive_enum_status_name (my.go_argument.project ? my.go_project)
        my.errors_handling += format_left("\
            err := $(my.enum_status:)HandleStatus($(go_argument.name:).status)
            if err != nil {
                return $(go_format_result_nil_args ("err", my.go_func, my.go_project):)
            }
        ")
    endfor

    # Wrap strings.
    my.str_method_from_str = "C.$(make_ref_c (make_id ("project", "common", "class", "str", "method", "from str")))"
    for my.go_func.go_argument where string_equal (0.type, "string")
        go_create_import ("unsafe", "unsafe", go_module)

        my.string_name = "$(go_argument.name:)Str"

        if is_true (go_argument.is_string)
          # type = string
          my.strings_init ?= ""
          my.strings_init += format_left("\
              $(my.string_name:) := C.CString($(go_argument.name:))
              defer C.free(unsafe.Pointer($(my.string_name:)))
          ")
        else
          # class = str
          my.strings_init ?= ""
          my.strings_init += format_left("\
              $(go_argument.name:)Char := C.CString($(go_argument.name:))
              defer C.free(unsafe.Pointer($(go_argument.name:)Char))
              $(my.string_name:) := $(my.str_method_from_str:)($(go_argument.name:)Char)
          ")
        endif
    endfor

    # Wrap output buffers.
    my.buffer_method_init = "C..(c_project_common_class_buffer_method_init)"
    my.buffer_method_use = "C..(c_project_common_class_buffer_method_use)"
    my.str_buffer_method_init = "C.$(make_ref_c (make_id ("project", "common", "class", "str buffer", "method", "new with capacity")))"
    my.str_buffer_method_delete = "C.$(make_ref_c (make_id ("project", "common", "class", "str buffer", "method", "delete")))"
    for my.go_func.go_return where string_in (0.type, "Data, string") & is_true_both (0.is_buffer, 0.was_argument)
        if ! defined (go_return.length_getter)
            echo_debug_item (my.go_func)
        endif
        assert_attribute (go_return, "length_getter", my)

        my.buffer_name = go_return.name ? "result"

        my.buffers_instantiation ?= ""
        if go_return.type = "string"
          my.buffers_instantiation += terminator + format_left ("\
              $(my.buffer_name:)Buf := $(my.str_buffer_method_init:)((C.size_t)($(go_return.length_getter:)))
              defer $(my.str_buffer_method_delete:)($(my.buffer_name:)Buf)
          ")
        else
          my.buffer_err_args = go_format_result_nil_args ("$(my.buffer_name:)BufErr", my.go_func, my.go_project)
          my.buffers_instantiation += terminator + format_left ("\
              $(my.buffer_name:)Buf, $(my.buffer_name:)BufErr := newBuffer(int($(go_return.length_getter:)))
              if $(my.buffer_name:)BufErr != nil {
                  return $(my.buffer_err_args:)
              }
              defer $(my.buffer_name:)Buf.delete()
          ")
        endif

        my.buffers_init ?= ""
        my.buffers_shrink ?= ""
    endfor

    #  Wrap input data.
    my.data_method_data = "C..(c_project_common_class_data_method_data)"
    for my.go_func.go_argument where 0.type = "Data" & is_true (0.is_data)
        my.data_name = "$(go_argument.name:)Data"

        my.buffers_init ?= ""
        my.buffers_init += format_left("\
            $(my.data_name:) := helperWrapData ($(go_argument.name:))
        ")
    endfor

    #   Wrap input buffers.
    my.method_new_with_data = "C..(c_project_common_class_buffer_method_new_with_data)"

    for my.go_func.go_argument where 0.type = "Data" & is_true (0.is_buffer)
        my.buffer_name = go_argument.name

        my.buffers_init ?= ""
        #TODO
        #my.buffers_init += format_left("\
        #    var $(my.buffer_name:)Buf = \
        #        $(my.method_new_with_data:)($(my.method_data:)($(my.buffer_name:)Pointer, $(my.buffer_name:).count))
        #")

        if go_argument.access <> "disown"
            my.buffers_init += terminator + format_left("\
                defer C..(c_project_common_class_buffer_method_delete)($(my.buffer_name:)Buf)
            ")
        endif
    endfor

    # Keep alive
    if ! is_true (my.go_func.is_static) & ! is_true (my.go_func.is_constructor)
        go_create_import ("", "runtime", my.go_module)

        my.keep_alive ?= ""
        my.keep_alive += terminator + format_left("\
            runtime.KeepAlive(obj)")
    endif
    for my.go_func.go_argument where (is_true (0.is_class) | is_true (0.is_interface)) & ! string_in (0.type, "Data, str") & ! is_true (0.is_error)
        go_create_import ("", "runtime", my.go_module)

        my.keep_alive ?= ""
        my.keep_alive += terminator + format_left("\
            runtime.KeepAlive($(go_argument.name:))")
    endfor

    if my.proxy_return_type <> "Void"
        my.result_statement = "proxyResult := /*pr1*/"
    endif
    my.proxy_return_statement = (my.proxy_return_type = "auto") ?? "" ? "-> $(my.proxy_return_type:) /*pr2*/"

    if defined (my.buffers_init)
        my.buffers_init = format_left (my.buffers_init, 0)
    endif

    #   Create shallow copies for objects that is passed as "disown" argument.
    for my.go_func.go_argument where go_argument.access = "disown"
        go_create_import ("unsafe", "unsafe", my.go_module)

        my.shallow_copies ?= terminator
        my.shallow_copies += format_left("\
            $(go_argument.name:)Copy := C.$(go_argument.method_shallow_copy:)((*C.$(go_argument.c_type:))(unsafe.Pointer($(go_argument.name:).Ctx())))
        ", 0)
    endfor

    my.proxy_invocation = (my.proxy_return_type <> "Void") ?? "proxyResult := /*pr4*/" ? ""
    my.proxy_invocation += my.proxy_call
    my.proxy_invocation = terminator + format_left (my.proxy_invocation, 0)

    #   Defer returned buffer.
    for my.go_func.go_return where \
            is_true (go_return.is_buffer) & string_in (go_return.access, "disown, retain")

        my.buffers_cleanup ?= terminator
        my.buffers_cleanup += format_left ("\
            defer C..(c_project_common_class_buffer_method_delete)(proxyResult)
        ")
    endfor

    #   Handle returned status.
    if is_true (my.go_func.handle_proxy_status)
        my.errors_handling ?= ""
        my.enum_status = go_derive_enum_status_name (my.go_project)
        my.errors_handling += terminator + format_left("\
            err := $(my.enum_status:)HandleStatus(proxyResult)
            if err != nil {
                return $(go_format_result_nil_args ("err", my.go_func, my.go_project):)
            }
        ")
    endif

    return \
        (my.errors_instantiation ? "") + \
        (my.strings_init ? "") + \
        (my.buffers_instantiation ? "") + \
        (my.opened_scope ? "") + \
        (my.buffers_init ? "") + \
        (my.shallow_copies ? "") + \
        my.proxy_invocation + \
        (my.closed_scope ? "") + \
        (my.buffers_shrink ? "") + \
        (my.buffers_cleanup ? "") + \
        (my.errors_handling ? "") + \
        (my.keep_alive ? "")
endfunction

# ---------------------------------------------------------------------------
#   Return C type wrapped to the Go type.
# ---------------------------------------------------------------------------
function go_wrap_c_returned_value (go_return, go_module, go_project)
    check_arguments (my, "go_return, go_module", my)

    my.name = my.go_return.name ? "proxyResult"
    my.type = my.go_return.type

    scope my.go_return

    if is_true (0.is_data)
        return "helperExtractData($(my.name:)) /* r1 */"

    elsif is_true (0.is_buffer) & is_false (0.was_argument)
        go_create_import ("unsafe", "unsafe", my.go_module)
        return "C.GoBytes(unsafe.Pointer(C..(c_project_common_class_buffer_method_bytes)($(my.name:))), C.int(C..(c_project_common_class_buffer_method_len)($(my.name:)))) /* r2 */"

    elsif is_true (0.is_primitive_type) & is_true_any (0.is_array, 0.is_reference)
        go_create_import ("unsafe", "unsafe", my.go_module)
        return "unsafe.Pointer($(my.name:)) /* r3 */"

    elsif is_true (0.is_interface)
        if string_in (go_return.access, "readonly, readwrite")
            return "$(my.go_project.name:Pascal)ImplementationWrap$(my.go_return.type:)Copy($(my.name:)) /* r4.1 */"
        else
            return "$(my.go_project.name:Pascal)ImplementationWrap$(my.go_return.type:)($(my.name:)) /* r4 */"
        endif

    elsif is_true (0.is_class) & is_false (0.is_buffer)
        if string_in (go_return.access, "readonly, readwrite")
            return "new$(my.type:)Copy($(my.name:)) /* r5 */"
        else
            return "new$(my.type:)WithCtx($(my.name:)) /* r6 */"
        endif

    elsif is_true (0.is_class) & is_true (0.is_buffer)
        if string_equal(0.type, "string")
            my.str_buffer_method_chars = "$(make_ref_c (make_id ("project", "common", "class", "str buffer", "method", "chars")))"
            return "C.GoString(C.$(my.str_buffer_method_chars:)($(my.name:)Buf)) /* r7.1 */"
        else
            return "$(my.name:)Buf.getData() /* r7 */"
        endif

    elsif is_true (0.is_enum)
        return "$(my.type:)($(my.name:)) /* r8 */"
    endif

    endscope
    if defined (my.go_return.c_type)
        return "$(my.go_return.type:)($(my.name:)) /* r9 */"
    else
        return "$(my.name:) /* r10 */"
    endif
endfunction

# ---------------------------------------------------------------------------
#   Create module and return it's class that handles implementation helper.
# ---------------------------------------------------------------------------
function go_get_implementation_helper_struct (go_project, meta)
    check_arguments (my, "go_project, meta", my)

    my.name = "$(my.go_project.name:Pascal)Implementation"

    my.implementation_helper_module = my.go_project->go_module(name = my.name) ?

    if defined (my.implementation_helper_module)
        return my.implementation_helper_module->go_struct
    endif

    new go_module to my.go_project
        . = "/* Create factory that turns C implementation object to the Go implementation object. */"
        .name = my.name
        .package = my.go_project.package
        .package_dir = my.go_project.package_dir
        .source_file_name = "$(my.go_project.name:c)_implementation.go"
        .source_file_path = cat_path (my.go_project.source_dir, 0.source_file_name)

        new go_license to go_module
            . = go_format_license (my.go_project->license) ?
        endnew

        go_create_cgo_include_instructions (go_module, my.go_project)

        for my.go_project.go_import
            copy go_import to go_module
        endfor

        new go_struct to go_module
            .name = my.name
            .visibility = "public"

            return go_struct
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Return interface method that wraps C implementation object to the
#   Go object.
# ---------------------------------------------------------------------------
function go_get_implementation_helper_interface_func (go_struct, interface, go_project)
    check_arguments (my, "go_struct, interface, go_project", my)

    my.interface_func_name = "Wrap$(my.interface.name:Pascal)"

    my.wrap_interface_func = my.go_struct->go_func (name = my.interface_func_name) ?

    if defined (my.wrap_interface_func)
        return my.wrap_interface_func
    endif

    new go_func to my.go_struct
        my.interface_name = go_derive_interface_name (my.interface, my.go_project)
        . = "\
            /* Wrap C implementation object to the Go object that implements interface $(my.interface_name:). */
        "
        .name = my.interface_func_name
        .throws = "1"
        .is_static = "1"
        .is_primary = "1"

        new go_argument to go_func
            .name = "ctx"
            #TODO
            .type = go_derive_struct_default_context_type()
        endnew

        new go_return to go_func
            .type = go_derive_interface_name (my.interface, my.go_project)
        endnew

        new go_code to go_func
            my.method_of_class = my.interface.of_class ? my.interface.name
            my.method_is_implemented = make_ref_c (make_id ("class", my.method_of_class, "method", "is_implemented"))
            .temp_code = format_left("\
                if (!C.$(my.method_is_implemented:)(ctx)) {
                    return nil, &$(go_derive_enum_status_name (my.go_project):){-1,\"Given C implementation does not implement interface $(my.interface_name:).\"}
                }

                implTag := C..(c_class_impl_method_tag)(ctx)
                switch (implTag) {
            ")
        endnew

        my.return_func = go_func
    endnew

    new go_func to my.go_struct
        my.interface_name = go_derive_interface_name (my.interface, my.go_project)
        . = "\
            /* Wrap C implementation object to the Go object that implements interface $(my.interface_name:). */
        "
        .name = "$(my.interface_func_name:)Copy"
        .throws = "1"
        .is_static = "1"

        new go_argument to go_func
            .name = "ctx"
            .type = go_derive_struct_default_context_type()
        endnew

        new go_return to go_func
            .type = go_derive_interface_name (my.interface, my.go_project)
        endnew

        new go_code to go_func
            my.method_of_class = my.interface.of_class ? my.interface.name
            my.method_is_implemented = make_ref_c (make_id ("class", my.method_of_class, "method", "is_implemented"))
            . = format_left("\
                shallowCopy := C..(c_class_impl_method_shallow_copy)(ctx)
                return $(my.go_struct.name:)$(my.interface_func_name:)(shallowCopy)
            ")
        endnew
    endnew

    return my.return_func
endfunction

# ---------------------------------------------------------------------------
#   Add wrapper "case" statement for implementation/interface pair.
# ---------------------------------------------------------------------------
function go_update_implementation_helper_module (implementation, go_project, meta)
    check_arguments (my, "implementation, go_project, meta", my)

    my.helper_class = go_get_implementation_helper_struct (my.go_project, my.meta)
    my.refs = meta_refs (my.meta)

    my.c_type = go_derive_c_type (my.implementation)

    for my.implementation.interface
        my.wrap_interface_method = \
                go_get_implementation_helper_interface_func (my.helper_class, interface, my.go_project)

        my.wrap_interface_method->go_code.temp_code += format_left("\
            case C.$(my.refs.c_implementation_constant_tag):
                return new$(go_derive_struct_name (my.implementation, my.go_project))WithCtx((*C.$(my.c_type:))(ctx)), nil
        ")
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Add methods ending within implementation helper class.
# ---------------------------------------------------------------------------
function go_finalize_implementation_helper_modules (go_project, meta)
    check_arguments (my, "go_project, meta", my)

    my.helper_class = go_get_implementation_helper_struct (my.go_project, my.meta)

    for my.helper_class.go_func where is_true(go_func.is_primary)
        go_func->go_code.temp_code += format_left ("\
            default:
                return nil, &$(go_derive_enum_status_name (my.go_project):){-1,\"Unexpected C implementation cast to the Go implementation.\"}
            }
        ")

        go_func->go_code. = go_func->go_code.temp_code
        go_func->go_code.temp_code = # undefined
    endfor

    new go_module to my.go_project
        . = "/* Helper. */"
        .name = "helper"
        .package = my.go_project.package
        .package_dir = my.go_project.package_dir
        .source_file_name = "$(0.name:).go"
        .source_file_path = cat_path (my.go_project.source_dir, 0.source_file_name)

        new go_license to go_module
            . = go_format_license (my.go_project->license) ?
        endnew

        go_create_cgo_include_instructions (go_module, my.go_project)

        for my.go_project.go_import
            copy go_import to go_module
        endfor

        go_create_import ("unsafe", "unsafe", go_module)

        new go_struct to go_module
            .name = "helper"
            .visibility = "private"

            new go_func to go_struct
                .name = "BytesToBytePtr"
                .is_static = "1"

                new go_argument to go_func
                    .name = "data"
                    .type = "[]byte"
                endnew

                new go_return to go_func
                    .type = "*C.uint8_t"
                endnew

                #TODO
                new go_code to go_func
                    . = format_left("\
                        return (*C.uint8_t)(&data[0])
                    ")
                endnew
            endnew

            new go_func to go_struct
                .name = "WrapData"
                .is_static = "1"

                new go_argument to go_func
                    .name = "data"
                    .type = "[]byte"
                endnew

                new go_return to go_func
                    .type = "C.vsc_data_t"
                endnew

                new go_code to go_func
                    . = format_left("\
                        if len(data) == 0 {
                            return C..(c_project_common_class_data_method_empty)()
                        }
                        return C..(c_project_common_class_data_method_data)((*C.uint8_t)(&data[0]), C.size_t(len(data)))
                    ")
                endnew
            endnew

            new go_func to go_struct
                .name = "ExtractData"
                .is_static = "1"

                new go_argument to go_func
                    .name = "data"
                    .type = "C.vsc_data_t"
                endnew

                new go_return to go_func
                    .type = "[]byte"
                endnew

                new go_code to go_func
                    . = format_left("\
                        return C.GoBytes(unsafe.Pointer(data.bytes), C.int(data.len))
                    ")
                endnew
            endnew
        endnew

        new go_struct to go_module
            .name = "buffer"
            .visibility = "private"

            new go_field to go_struct
                .name = "memory"
                .type = "[]byte"
            endnew

            new go_field to go_struct
                .name = "ctx"
                .type = "*C..(c_project_common_class_buffer_struct_buffer)"
            endnew

            new go_field to go_struct
                .name = "data"
                .type = "[]byte"
            endnew

            new go_func to go_struct
                .name = "newBuffer"
                .is_static = "1"
                .is_skip_struct_name = "1"
                .throws = "1"

                new go_argument to go_func
                    .name = "cap"
                    .type = "int"
                endnew

                new go_return to go_func
                    .type = "*buffer"
                endnew

                new go_code to go_func
                    . = format_left("\
                        capacity := C.size_t(cap)
                        if capacity == 0 {
                            return nil, &$(go_derive_enum_status_name (my.go_project):){-1,\"Buffer with zero capacity is not allowed.\"}
                        }

                        ctxLen := C.vsc_buffer_ctx_size()
                        memory := make([]byte, int(ctxLen + capacity))
                        ctx := (*C..(c_project_common_class_buffer_struct_buffer))(unsafe.Pointer(&memory[0]))
                        data := memory[int(ctxLen):]

                        C.vsc_buffer_init(ctx)
                        C.vsc_buffer_use(ctx, (*C.byte)(unsafe.Pointer(&data[0])), capacity)

                        return &buffer {
                            memory: memory,
                            ctx: ctx,
                            data: data,
                        }, nil
                    ")
                endnew
            endnew

            new go_func to go_struct
                .name = "getData"

                new go_return to go_func
                    .type = "[]byte"
                endnew

                new go_code to go_func
                    . = format_left("\
                        newSize := int(C..(c_project_common_class_buffer_method_len)(obj.ctx))
                        if newSize > len(obj.data) {
                            panic (\"Underlying C buffer corrupt the memory.\")
                        }
                        return obj.data[:newSize]
                    ")
                endnew
            endnew

            new go_func to go_struct
                .name = "cap"

                new go_return to go_func
                    .type = "int"
                endnew

                new go_code to go_func
                    . = format_left("\
                        return int(C..(c_project_common_class_buffer_method_capacity)(obj.ctx))
                    ")
                endnew
            endnew

            new go_func to go_struct
                .name = "len"

                new go_return to go_func
                    .type = "int"
                endnew

                new go_code to go_func
                    . = format_left("\
                        return int(C..(c_project_common_class_buffer_method_len)(obj.ctx))
                    ")
                endnew
            endnew

            my.func_clear = go_create_func_clear_declaration_private (go_struct, my.go_project, my.meta)
            new go_code to my.func_clear
                . = format_left("\
                    C..(c_project_common_class_buffer_method_delete)(obj.ctx)
                ")
            endnew
        endnew
    endnew

    new go_module to my.go_project
        . = "/* Platform. */"
        .name = "platform"
        .package = my.go_project.package
        .package_dir = my.go_project.package_dir
        .source_file_name = "$(0.name:).go"
        .source_file_path = cat_path (my.go_project.source_dir, 0.source_file_name)

        new go_license to go_module
            . = go_format_license (my.go_project->license) ?
        endnew

        go_create_cgo_instructions (go_module, my.go_project)

        for my.go_project.go_import
            copy go_import to go_module
        endfor
    endnew

    go_create_context_module (my.go_project, my.meta)
endfunction

.endtemplate
