.template 0
#   Copyright (C) 2015-2020 Virgil Security, Inc.
#
#   All rights reserved.
#
#   Redistribution and use in source and binary forms, with or without
#   modification, are permitted provided that the following conditions are
#   met:
#
#       (1) Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#
#       (2) Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in
#       the documentation and/or other materials provided with the
#       distribution.
#
#       (3) Neither the name of the copyright holder nor the names of its
#       contributors may be used to endorse or promote products derived from
#       this software without specific prior written permission.
#
#   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR
#   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#   DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
#   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
#   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
#   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
#   STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
#   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#   POSSIBILITY OF SUCH DAMAGE.
#
#   Lead Maintainer: Virgil Security Inc. <support@virgilsecurity.com>

# ---------------------------------------------------------------------------
#   Contains API for Swift wrapper generation.
# ---------------------------------------------------------------------------
#   This is a code generator built using the iMatix GSL code generation
#   language. See https://github.com/zeromq/gsl for details.
# ---------------------------------------------------------------------------

gsl from "common.gsl"
gsl from "interface.gsl"
gsl from "component.gsl"
gsl from "c_component.gsl"
gsl from "swift_codegen.gsl"
gsl from "projects_api.gsl"


# ===========================================================================
#   Name and type derivation.
# ===========================================================================


# ---------------------------------------------------------------------------
#   Return Swift type for class context.
# ---------------------------------------------------------------------------
function swift_derive_class_context_type (class)
    if defined (my.class) & string_equal (my.class.context, "public")
        return "UnsafeMutablePointer<$(class_derive_c_type(my.class))>"
    else
        return "OpaquePointer"
    endif
endfunction

# ---------------------------------------------------------------------------
#   Return .(UID) of dependency type.
# ---------------------------------------------------------------------------
function swift_derive_dependency_type (dependency)
    check_arguments (my, "dependency", my)

    my.project_uid = component_derive_project_uid (my.dependency)

    if defined (my.dependency.interface)
        my.type_uid = make_id ("protocol", "$(my.dependency.interface:Pascal)")

    elsif defined (my.dependency.api)
        my.type_uid = make_id ("protocol", "$(my.dependency.api:Pascal)")

    elsif defined (my.dependency.class)
        my.type_uid = make_id ("class", "$(my.dependency.class:Pascal)")

    elsif defined (my.dependency.impl)
        my.type_uid = make_id ("class", "$(my.dependency.impl:Pascal)")

    else
        echo_debug_item (my.dependency, my)
        echo_fatal ("Unhanded dependency type.", my)
    endif

    return make_ref_swift (make_id(my.project_uid, my.type_uid))
endfunction

# ---------------------------------------------------------------------------
#   Return formatted module name.
# ---------------------------------------------------------------------------
function swift_derive_module_name (type)
    check_arguments (my, "type", my)

    assert_attribute (my.type, "name", my)

    return "$(my.type.name:Pascal)"
endfunction

# ---------------------------------------------------------------------------
#   Return formatted constant name from raw name.
# ---------------------------------------------------------------------------
function swift_derive_constant_name_str (name)
    check_arguments (my, "name", my)

    return "$(my.name:Camel)"
endfunction

# ---------------------------------------------------------------------------
#   Return formatted constant name.
# ---------------------------------------------------------------------------
function swift_derive_constant_name (constant, swift_project)
    check_arguments (my, "constant", my)

    assert_attribute (my.constant, "name", my)

    return swift_derive_constant_name_str (my.constant.name)
endfunction

# ---------------------------------------------------------------------------
#   Return formatted property name from raw name.
# ---------------------------------------------------------------------------
function swift_derive_property_name_str (name)
    check_arguments (my, "name", my)

    return "$(my.name:Camel)"
endfunction

# ---------------------------------------------------------------------------
#   Return formatted property name.
# ---------------------------------------------------------------------------
function swift_derive_property_name (property)
    check_arguments (my, "property", my)

    assert_attribute (my.property, "name", my)

    return swift_derive_property_name_str (my.property.name)
endfunction

# ---------------------------------------------------------------------------
#   Return mapped constant type.
# ---------------------------------------------------------------------------
function swift_derive_constant_type (constant, swift_project)
    check_arguments (my, "constant, swift_project", my)

    assert_attribute (my.constant, "type", my)

    if my.constant.type = "boolean"
        return "Bool"
    else
        return "Int"
    endif
endfunction

# ---------------------------------------------------------------------------
#   Return formatted instance name.
# ---------------------------------------------------------------------------
function swift_derive_instance_name (instance)
    check_arguments (my, "instance", my)

    assert_attribute (my.instance, "name", my)

    return "$(my.instance.name:Camel)"
endfunction

# ---------------------------------------------------------------------------
#   Derive Swift integer type correspond to it's size.
#   Size: {1, 2, 4, 8}.
# ---------------------------------------------------------------------------
function swift_derive_integer_type (size)
    if defined (my.size)
        if my.size = "1"
            return "Int8"

        elsif my.size = "2"
            return "Int16"

        elsif my.size = "4"
            return "Int32"

        elsif my.size = "8"
            return "Int64"
        else
            echo_fatal ("Unsupported size 'my.size' for Swift integers", my)
        endif
    else
        return "Int32"
    endif
endfunction

# ---------------------------------------------------------------------------
#   Derive Swift unsigned integer type correspond to it's size.
#   Size: {1, 2, 4, 8}.
# ---------------------------------------------------------------------------
function swift_derive_unsigned_type (size)
    if defined (my.size)
        if my.size = "1"
            return "UInt8"

        elsif my.size = "2"
            return "UInt16"

        elsif my.size = "4"
            return "UInt32"

        elsif my.size = "8"
            return "UInt64"
        else
            echo_fatal ("Unsupported size 'my.size' for Swift unsigned integers", my)
        endif
    else
        return "UInt32"
    endif
endfunction

# ---------------------------------------------------------------------------
#   Return formatted method name from raw name.
# ---------------------------------------------------------------------------
function swift_derive_method_name_str (name)
    check_arguments (my, "name", my)

    return "$(my.name:Camel)"
endfunction

# ---------------------------------------------------------------------------
#   Return formatted method name.
# ---------------------------------------------------------------------------
function swift_derive_method_name (method, swift_project)
    check_arguments (my, "method", my)

    return swift_derive_method_name_str (my.method.name)
endfunction

# ---------------------------------------------------------------------------
#   Return formatted name of the Swift protocol.
# ---------------------------------------------------------------------------
function swift_derive_protocol_name (interface, swift_project)
    check_arguments (my, "interface, swift_project", my)

    assert_attribute_one_of (my.interface, "name, interface", my)

    return "$(my.interface.name ? my.interface.interface:Pascal)"
endfunction

# ---------------------------------------------------------------------------
#   Return formatted name of the Swift class.
# ---------------------------------------------------------------------------
function swift_derive_class_name_str (name)
    check_arguments (my, "name", my)

    return "$(my.name:Pascal)"
endfunction

# ---------------------------------------------------------------------------
#   Return formatted name of the Swift class.
# ---------------------------------------------------------------------------
function swift_derive_class_name (class, swift_project)
    check_arguments (my, "class", my)

    assert_attribute_one_of (my.class, "name", my)

    return swift_derive_class_name_str (my.class.name)
endfunction

# ---------------------------------------------------------------------------
#   Return formatted name of the Swift enum.
# ---------------------------------------------------------------------------
function swift_derive_enum_status_name (project_name)
    check_arguments (my, "project_name", my)

    return "$(my.project_name:Pascal)Error"
endfunction

# ---------------------------------------------------------------------------
#   Return formatted name of the Swift enum.
# ---------------------------------------------------------------------------
function swift_derive_enum_name (enum, swift_project)
    check_arguments (my, "enum, swift_project", my)

    assert_attribute_one_of (my.enum, "name", my)

    if my.enum.name = "status"
        return swift_derive_enum_status_name (my.swift_project.name)
    else
        return "$(my.enum.name:Pascal)"
    endif

endfunction

# ---------------------------------------------------------------------------
#   Return formatted name of the Objective-C protocol.
# ---------------------------------------------------------------------------
function swift_derive_protocol_objc_name (swift_protocol, swift_project)
    check_arguments (my, "swift_protocol, swift_project", my)

    return "$(my.swift_project.prefix:UPPER)$(my.swift_protocol.name:)"
endfunction

# ---------------------------------------------------------------------------
#   Return formatted name of the Objective-C class.
# ---------------------------------------------------------------------------
function swift_derive_class_objc_name (swift_class, swift_project)
    check_arguments (my, "swift_class, swift_project", my)

    return "$(my.swift_project.prefix:UPPER)$(my.swift_class.name:)"
endfunction

# ---------------------------------------------------------------------------
#   Return formatted name of the Objective-C enum.
# ---------------------------------------------------------------------------
function swift_derive_enum_objc_name (swift_enum, swift_project)
    check_arguments (my, "swift_enum, swift_project", my)

    return "$(my.swift_project.prefix:UPPER)$(my.swift_enum.name:)"
endfunction

# ---------------------------------------------------------------------------
#   Return formatted argument name from raw name.
# ---------------------------------------------------------------------------
function swift_derive_argument_name_str (name, swift_project)
    check_arguments (my, "name", my)

    return "$(my.name:Camel)"
endfunction

# ---------------------------------------------------------------------------
#   Return formatted argument name.
# ---------------------------------------------------------------------------
function swift_derive_argument_name (argument, swift_project)
    check_arguments (my, "argument", my)

    return swift_derive_argument_name_str (my.argument.name)
endfunction

# ---------------------------------------------------------------------------
#   Derive Swift type from the <instance/> type attributes.
# ---------------------------------------------------------------------------
function swift_derive_instance_type (instance)
    check_arguments (my, "instance", my)

    if defined (my.instance.type)
        if my.instance.type = "nothing"
            my.primitive_type = "Void"

        elsif my.instance.type = "boolean"
            my.primitive_type = "Bool"

        elsif my.instance.type = "integer"
            my.primitive_type = swift_derive_integer_type (my.instance.size ?)

        elsif my.instance.type = "unsigned"
            my.primitive_type = swift_derive_unsigned_type (my.instance.size ?)

        elsif my.instance.type = "byte"
            my.primitive_type = "UInt8"

        elsif my.instance.type = "size"
            my.primitive_type = "Int"

        elsif my.instance.type = "char"
            if count(my.instance.string)
                my.primitive_type = "String"
            else
                my.primitive_type = "Character"
            endif
        else
            echo_fatal ("Unsupported instance type '$(my.instance.type)' for Swift language.", my)
        endif

        if is_true (my.instance.is_reference)
            if string_in (my.instance.access, "readonly")
                my.primitive_type = "UnsafePointer<$(my.primitive_type:)>"
            else
                my.primitive_type = "UnsafeMutablePointer<$(my.primitive_type:)>"
            endif
        endif

        if count (my.instance.array)
            if string_in (my.instance.access, "readonly")
                my.primitive_type = "UnsafePointer<$(my.primitive_type:)>"
            else
                my.primitive_type = "UnsafeMutablePointer<$(my.primitive_type:)>"
            endif
        endif

        return my.primitive_type

    elsif defined (my.instance.class)

        if my.instance.class = "any"
            return "Any"

        elsif my.instance.class = "data"
            return "Data"

        elsif my.instance.class = "buffer"
            return "Data"

        elsif my.instance.class = "error"
            return class_derive_c_instance_type (my.instance)

        elsif is_ref (my.instance.class) | defined (my.instance.library)
            return swift_lang_ref (my.instance.class)

        else
            my.project_uid = component_derive_project_uid (my.instance)
            my.type_uid = make_id ("class", "$(my.instance.class:Pascal)")
            return make_ref_swift (make_id(my.project_uid, my.type_uid))
        endif

    elsif defined (my.instance.impl)
        my.project_uid = component_derive_project_uid (my.instance)
        my.type_uid = make_id ("class", "$(my.instance.impl:Pascal)")
        return make_ref_swift (make_id(my.project_uid, my.type_uid))

    elsif defined (my.instance.interface)
        my.project_uid = component_derive_project_uid (my.instance)
        my.type_uid = make_id ("protocol", "$(my.instance.interface:Pascal)")
        return make_ref_swift (make_id(my.project_uid, my.type_uid))

    elsif defined (my.instance.enum)
        my.project_uid = component_derive_project_uid (my.instance)
        my.type_uid = make_id ("enum", "$(my.instance.enum:Pascal)")
        return make_ref_swift (make_id(my.project_uid, my.type_uid))

    else
        my.instance_dump = component_instance_dump (my.instance)

        echo_warning ("Unreachable code, component_resolve_instance() must handle this. $(my.instance_dump:)", my)

        return "Unknown"
    endif
endfunction

# ---------------------------------------------------------------------------
#   Return proxy type of the method return value.
# ---------------------------------------------------------------------------
function swift_derive_proxy_return_type (method)
    check_arguments (my, "method", my)

    if ! count (my.method.return)
        return "Void"
    endif

    my.return = my.method->return

    if defined (my.return.type)
        return swift_derive_instance_type (my.return)

    elsif defined (my.return.enum)
        return make_ref_c (make_id ("class", my.return.enum, "enum", my.return.enum))

    elsif has_one_of_attribute (my.return, "interface, class, impl")
        return "auto"
    endif

    return "Any"
endfunction

# ---------------------------------------------------------------------------
#   Return name of the class that handles multiple method's return values.
# ---------------------------------------------------------------------------
function swift_derive_result_class_name (swift_parent, swift_method)
    check_arguments (my, "swift_parent, swift_method", my)

    return "$(my.swift_method.interface ? my.swift_parent.name:Pascal)$(my.swift_method.name:Pascal)Result"
endfunction

# ---------------------------------------------------------------------------
#   Return C type wrapped to the Swift type.
# ---------------------------------------------------------------------------
function swift_wrap_c_returned_value (swift_return, swift_project)
    check_arguments (my, "swift_return", my)

    my.name = my.swift_return.name ? "proxyResult"
    my.type = my.swift_return.type

    scope my.swift_return

    if is_true (0.is_data)
        return "Data.init(bytes: $(my.name:).bytes, count: $(my.name:).len)"

    elsif is_true (0.is_buffer) & is_false (0.was_argument)
        return "Data.init(bytes: .(c_project_common_class_buffer_method_bytes)($(my.name:)), " + \
                         "count: .(c_project_common_class_buffer_method_len)($(my.name:)))"

    elsif is_true (0.is_primitive_type) & is_true_any (0.is_array, 0.is_reference)
        return "$(my.name:)!"

    elsif is_true (0.is_interface)
        my.impl_helper_class = "$(my.swift_project.name:Pascal)Implementation"
        if string_in (swift_return.access, "readonly, readwrite")
            return "$(my.impl_helper_class:).wrap$(my.swift_return.type:)(use: $(my.name:)!)"
        else
            return "$(my.impl_helper_class:).wrap$(my.swift_return.type:)(take: $(my.name:)!)"
        endif


    elsif is_true (0.is_class) & is_false (0.is_buffer)
        if string_in (swift_return.access, "readonly, readwrite")
            return "$(my.type:).init(use: $(my.name:)!)"
        else
            return "$(my.type:).init(take: $(my.name:)!)"
        endif

    elsif is_true (0.is_enum)
        return "$(my.type:).init(fromC: $(my.name:))"
    endif

    endscope
    return my.name
endfunction

# ---------------------------------------------------------------------------
#   Return formatted string with code that makes proxy call:
#       - type mapping
#       - proxy call
#       - finalizing
# ---------------------------------------------------------------------------
function swift_wrap_c_proxy_call (swift_method, proxy_call, proxy_return_type, swift_project)
    check_arguments (my, "swift_method, proxy_call, proxy_return_type, swift_project", my)

    #   Wrap errors.
    for my.swift_method.swift_argument where is_true (swift_argument.is_error)
        my.errors_instantiation ?= terminator
        my.errors_instantiation += format_left("\
            var $(swift_argument.name:): $(swift_argument.type:) = $(swift_argument.type:)()
            $(swift_argument.method_reset:)(&$(swift_argument.name:))
        ")

        my.errors_handling ?= terminator
        my.enum_status = swift_derive_enum_status_name (my.swift_argument.project ? my.swift_project.name)
        my.errors_handling += format_left("\
            try $(my.enum_status:).handleStatus(fromC: $(swift_argument.name:).status)
        ")
    endfor

    #   Wrap output buffers.
    for my.swift_method.swift_return where 0.type = "Data" & is_true_both (0.is_buffer, 0.was_argument)
        if ! defined (swift_return.length_getter)
            echo_debug_item (my.swift_method)
        endif
        assert_attribute (swift_return, "length_getter", my)

        my.buffer_name = swift_return.name ? "result"

        my.buffers_instantiation ?= ""
        my.buffers_instantiation += terminator + format_left ("\
            let $(my.buffer_name:)Count = $(swift_return.length_getter:)
            var $(my.buffer_name:) = Data(count: $(my.buffer_name:)Count)
            var $(my.buffer_name:)Buf = .(c_project_common_class_buffer_method_new)()
            defer {
                .(c_project_common_class_buffer_method_delete)($(my.buffer_name:)Buf)
            }
        ")

        my.buffers_init ?= ""
        my.buffers_init += terminator + format_left("\
                .(c_project_common_class_buffer_method_use)($(my.buffer_name:)Buf, \
                        $(my.buffer_name:)Pointer.bindMemory(to: byte.self).baseAddress, $(my.buffer_name:)Count)
        ")

        my.buffers_shrink ?= ""
        my.buffers_shrink += format_left ("\
            $(my.buffer_name:).count = .(c_project_common_class_buffer_method_len)($(my.buffer_name:)Buf)
        ")
    endfor

    #   Wrap input buffers.
    my.method_new_with_data = ".(c_project_common_class_buffer_method_new_with_data)"
    my.method_data = ".(c_project_common_class_data_method_data)"

    for my.swift_method.swift_argument where 0.type = "Data" & is_true (0.is_buffer)
        my.buffer_name = swift_argument.name

        my.buffers_init ?= ""
        my.buffers_init += format_left("\
            var $(my.buffer_name:)Buf = \
                $(my.method_new_with_data:)($(my.method_data:)($(my.buffer_name:)Pointer, $(my.buffer_name:).count))
        ")

        if swift_argument.access <> "disown"
            my.buffers_init += terminator + format_left("\
                defer {
                    .(c_project_common_class_buffer_method_delete)($(my.buffer_name:)Buf)
                }
            ")
        endif
    endfor

    #   Create opened scopes for data and buffers and string.
    my.scope_count = 0

    if my.proxy_return_type <> "Void"
        my.result_statement = "let proxyResult = "
    endif
    my.proxy_return_statement = (my.proxy_return_type = "auto") ?? "" ? "-> $(my.proxy_return_type:) "

    for my.swift_method.swift_argument where 0.type = "Data"
        my.opened_scope ?= terminator
        my.opened_scope += format_left("\
            $(my.result_statement?:)$(swift_argument.name:).withUnsafeBytes({ \
                ($(swift_argument.name:)Pointer: UnsafeRawBufferPointer) $(my.proxy_return_statement:)in

        ", my.scope_count)
        my.result_statement = # undefined
        my.scope_count += 1
    endfor

    for my.swift_method.swift_return where 0.type = "Data" & is_true_both (0.is_buffer, 0.was_argument)
        my.opened_scope ?= terminator
        my.opened_scope += format_left("\
            $(my.result_statement?:)$(swift_return.name:).withUnsafeMutableBytes({ \
                ($(swift_return.name:)Pointer: UnsafeMutableRawBufferPointer) $(my.proxy_return_statement:)in

        ", my.scope_count)

        my.result_statement = # undefined
        my.scope_count += 1
    endfor

    if defined (my.buffers_init)
        my.buffers_init = format_left (my.buffers_init, my.scope_count)
    endif

    #   Create shallow copies for objects that is passed as "disown" argument.
    for my.swift_method.swift_argument where swift_argument.access = "disown"
        my.shallow_copies ?= terminator
        my.shallow_copies += format_left("\
            var $(swift_argument.name:)Copy = $(swift_argument.method_shallow_copy:)($(swift_argument.name:).c_ctx)
        ", my.scope_count)
    endfor

    if my.scope_count > 0
        my.proxy_invocation = (my.proxy_return_type <> "Void") ?? "return " ? ""
    else
        my.proxy_invocation = (my.proxy_return_type <> "Void") ?? "let proxyResult = " ? ""
    endif
    my.proxy_invocation += my.proxy_call
    my.proxy_invocation = terminator + format_left (my.proxy_invocation, my.scope_count)

    #   Create closed scopes for data and buffers.
    while my.scope_count > 0
        my.closed_scope ?= ""
        my.scope_count -= 1
        my.closed_scope += format_left("})", my.scope_count)
    endwhile

    #   Defer returned buffer.
    for my.swift_method.swift_return where \
            is_true (swift_return.is_buffer) & string_in (swift_return.access, "disown, retain")

        my.buffers_cleanup ?= terminator
        my.buffers_cleanup += format_left ("\
            defer {
                .(c_project_common_class_buffer_method_delete)(proxyResult)
            }
        ")
    endfor

    #   Handle returned status.
    if is_true (my.swift_method.handle_proxy_status)
        my.errors_handling ?= ""
        my.enum_status = swift_derive_enum_status_name (my.swift_project.name)
        my.errors_handling += terminator + format_left("\
            try $(my.enum_status:).handleStatus(fromC: proxyResult)
        ")
    endif

    return (my.errors_instantiation ? "") + (my.buffers_instantiation ? "") + (my.opened_scope ? "") + \
            (my.buffers_init ? "") + (my.shallow_copies ? "") + my.proxy_invocation + (my.closed_scope ? "") + \
            (my.buffers_shrink ? "") + (my.buffers_cleanup ? "") + (my.errors_handling ? "")
endfunction

# ---------------------------------------------------------------------------
#   Return formatted arguments list that is used to be passed to the Swift
#   proxy method.
# ---------------------------------------------------------------------------
function swift_format_proxy_args (swift_method)
    check_arguments (my, "swift_method", my)

    my.proxy_args = ""

    for my.swift_method.swift_argument
        my.proxy_args += "$(swift_argument.name:): $(swift_argument.name:)"
        if ! last ()
            my.proxy_args += ", "
        endif
    endfor

    return my.proxy_args
endfunction

# ---------------------------------------------------------------------------
#   Return formatted arguments list that is used to proxy returned
#   "result class".
# ---------------------------------------------------------------------------
function swift_format_result_class_init_args (swift_method, swift_project)
    check_arguments (my, "swift_method, swift_project", my)

    my.init_args = ""

    for my.swift_method.swift_return
        my.init_args += "$(swift_return.name:): $(swift_wrap_c_returned_value (swift_return, my.swift_project))"
        if ! last ()
            my.init_args += ", "
        endif
    endfor

    return my.init_args
endfunction

# ---------------------------------------------------------------------------
#   Return formatted arguments list that is to by passed to the C method.
# ---------------------------------------------------------------------------
function swift_format_c_proxy_args (class, method)
    check_arguments (my, "class, method", my)

    if is_false (my.method.is_static)
        my.proxy_args = "self.c_ctx"

    elsif defined (my.method.implementation)
        my.proxy_args = ""

    elsif defined (my.method.interface)
        my.proxy_args = "$(interface_derive_c_api_method_from_name(my.method.interface))(self.c_ctx)"
    endif

    for my.method.argument
        my.proxy_args ?= ""
        if my.proxy_args <> ""
            my.proxy_args += ", "
        endif

        my.arg_name = swift_derive_instance_name (argument)

        my.proxy_arg = # undefined

        if string_equal (argument.class, "data")
            my.proxy_arg = ".(c_project_common_class_data_method_data)($(my.arg_name:)Pointer.bindMemory(to:\
                     byte.self).baseAddress, $(my.arg_name:).count)"

        elsif string_equal (argument.class, "buffer")
            my.proxy_arg = "$(my.arg_name:)Buf"

        elsif string_equal (argument.class, "error")
            my.proxy_arg = "&$(my.arg_name:)"

        elsif has_one_of_attribute (argument, "class, api, interface, impl")
            if argument.access = "disown"
                my.proxy_arg = "$(my.arg_name:)Copy"
            else
                my.proxy_arg = "$(my.arg_name:).c_ctx"
            endif

        elsif defined (argument.enum)
            my.enum_type = class_derive_c_instance_type (argument)
            my.proxy_arg = "$(my.enum_type:)(rawValue: UInt32($(my.arg_name:).rawValue))"

        else
            my.proxy_arg = "$(my.arg_name:)"
        endif

        if defined (my.proxy_arg) & argument.access = "disown"
            my.proxy_arg = "&" + my.proxy_arg
        endif

        my.proxy_args += my.proxy_arg ? ""
    endfor

    return my.proxy_args ? ""
endfunction

# ---------------------------------------------------------------------------
#   Return invocation of the getter function that returns buffer length.
# ---------------------------------------------------------------------------
function class_derive_buffer_length_getter (class, method, argument)
    assert_attributes (my, "class, method, argument")

    assert_item (my.argument, "length", my)

    my.length = my.argument->length
    assert_attribute_one_of (my.length, "constant, argument, method", my)

    for my.length.proxy
        if ! defined (proxy.[to])
            echo_debug_item (my.argument, my)
            assert_attributes (proxy, "to", my)
        endif

        my.proxy_args ?= ""

        if ! first ()
            my.proxy_args += ", "
        endif

        if defined (proxy.argument)

            my.proxy_args += swift_derive_argument_name_str (proxy.[to])
            my.proxy_args += ": " + swift_derive_argument_name_str (proxy.argument)

            if string_in (proxy.cast, "data_length")
                my.proxy_args += ".count"
            endif

        elsif defined (proxy.constant)

            my.proxy_args += swift_derive_argument_name_str (proxy.[to])
            my.proxy_args += ": " + swift_lang_ref (proxy.constant)
        else
            echo_debug_item (my.argument, my)
            echo_fatal ("Buffer length argument can be proxied. Undefined type.", my)
        endif
    endfor

    my.specified_proxy_object = get_one_of_attribute (my.length, "class, interface, impl") ?
    if defined (my.specified_proxy_object)
        if my.specified_proxy_object = "self"
            my.specified_proxy_object = my.class.name
        endif
        my.proxy_object = swift_derive_class_name_str (my.specified_proxy_object)
    else
        my.proxy_object = "self"
    endif

    if defined (my.length.method)
        my.proxy_method = swift_derive_method_name_str (my.length.method)
        return "$(my.proxy_object:).$(my.proxy_method:)($(my.proxy_args?:))"

    elsif defined (my.length.constant)
        my.proxy_constant = swift_derive_constant_name_str (my.length.constant)
        return "$(my.proxy_object:).$(my.proxy_constant:)"

    elsif defined (my.length.argument)
        my.proxy_argument = swift_derive_argument_name_str (my.length.argument)

        if string_in (my.length.cast, "data_length")
            my.proxy_argument += ".count"
        endif

        return my.proxy_argument
    endif
endfunction

# ===========================================================================
#   Attribute mapping.
# ===========================================================================

# ---------------------------------------------------------------------------
#   Map attribute 'access' of <component/> to <swift_component/>.
# ---------------------------------------------------------------------------
function swift_map_attr_access (swift_component, component)
    check_arguments (my, "swift_component, component", my)

    assert_attribute (my.component, "access", my)

    my.swift_component.access = my.component.access
endfunction

# ---------------------------------------------------------------------------
#   Map attribute 'visibility' of <component/> to <swift_component/>.
# ---------------------------------------------------------------------------
function swift_map_attr_visibility (swift_component, component)
    check_arguments (my, "swift_component, component", my)

    #   TODO: make mapping more accurate.
    my.swift_component.visibility = my.component.visibility ? "public"
endfunction

# ---------------------------------------------------------------------------
#   Map attribute 'scope' of <component/> to <swift_component/>.
# ---------------------------------------------------------------------------
function swift_map_attr_scope (swift_component, component)
    check_arguments (my, "swift_component, component", my)

    #   TODO: make mapping more accurate.
    my.swift_component.scope = my.component.scope ? "public"
endfunction

# ---------------------------------------------------------------------------
#   Return true if swift method handle status returned from the C proxy.
# ---------------------------------------------------------------------------
function swift_derive_handle_proxy_status(method)
    check_arguments (my, "method", my)

    return count (my.method.return, string_equal (return.enum, "status"))
endfunction

# ---------------------------------------------------------------------------
#   Return true if swift method must throws.
# ---------------------------------------------------------------------------
function swift_derive_method_throws(method)
    check_arguments (my, "method", my)

    if count (my.method.return, string_equal (return.enum, "status"))
        return "1"
    elsif count (my.method.argument, string_equal (argument.class, "error") & argument.access = "readwrite")
        return "1"
    else
        return "0"
    endif
endfunction

# ---------------------------------------------------------------------------
#   Map <instance/> attributes to the <swift_instance type=""/> attributes.
# ---------------------------------------------------------------------------
function swift_map_instance_type (swift_instance, instance)
    check_arguments (my, "swift_instance, instance", my)

    my.swift_instance.type = swift_derive_instance_type (my.instance)

    if defined (my.instance.type)
        my.swift_instance.is_primitive_type = "1"

    elsif defined (my.instance.class)
        my.swift_instance.is_class = "1"

        if my.instance.class = "any"
            my.swift_instance.is_any = "1"

        elsif my.instance.class = "data"
            my.swift_instance.is_data = "1"

        elsif my.instance.class = "buffer"
            my.swift_instance.is_buffer = "1"

        elsif my.instance.class = "error"
            my.swift_instance.is_error = "1"
            my.swift_instance.method_reset = make_ref_c (make_id ("class error method reset"))
        endif

    elsif defined (my.instance.interface)
        my.swift_instance.is_interface = "1"

    elsif defined (my.instance.enum)
        my.swift_instance.is_enum = "1"

    elsif defined (my.instance.impl)
        my.swift_instance.is_class = "1"
    endif

    my.swift_instance.is_array = count (my.instance.array) ?? "1" ?
    my.swift_instance.is_string = count (my.instance.string) ?? "1" ?
    my.swift_instance.is_reference = my.instance.is_reference ?
endfunction

# ---------------------------------------------------------------------------
#   Map <instance/> attributes to the <swift_instance type=""/> attributes.
# ---------------------------------------------------------------------------
function swift_map_instance_method_shallow_copy (swift_instance, instance)
endfunction

# ---------------------------------------------------------------------------
#   Map <instance/> attributes to the <swift_instance/> attributes.
# ---------------------------------------------------------------------------
function swift_map_instance (swift_instance, instance)
    check_arguments (my, "swift_instance, instance", my)

    swift_map_attr_access (my.swift_instance, my.instance)
    swift_map_instance_type (my.swift_instance, my.instance)

    if item_in(my.instance, "argument") & my.instance.access = "disown" & \
            has_one_of_attribute(my.instance, "interface, impl, class")
        my.swift_instance.method_shallow_copy = insatnce_derive_c_method_shallow_copy(my.instance)
    endif
endfunction


# ===========================================================================
#   Component resolution.
# ===========================================================================

# ---------------------------------------------------------------------------
#   Resolve UIDs for given component and all inner components.
# ---------------------------------------------------------------------------
function swift_module_resolve_uids (swift_component, parent_uid)
    check_arguments (my, "swift_component", my)

    if defined (my.parent_uid) & string.prefixed (my.parent_uid, "swift_module")
        my.parent_uid = # Undefined
    endif

    my.component_name = name (my.swift_component)
    if  defined (my.parent_uid) & string.prefixed (my.component_name, "swift_")
        regexp.match ("swift_(.+)", my.component_name, my.component_name)
    endif

    my.swift_component.uid = make_id (my.parent_uid, my.component_name, my.swift_component.name)

    for my.swift_component. as inner_component where is_item (inner_component) & defined (inner_component.name)
        swift_module_resolve_uids (inner_component, my.swift_component.uid)
    endfor
endfunction


# ===========================================================================
#   Module resolution.
# ===========================================================================

# ---------------------------------------------------------------------------
#   Add auto-resolving attributes:
#       - uid.
# ---------------------------------------------------------------------------
function swift_module_resolve (swift_module, swift_project)
    check_arguments (my, "swift_module, swift_project", my)

    echo_trace ("Resolving <$(name (my.swift_module)) name=\"$(my.swift_module.name:)\"/>", my)

    assert_attribute (my.swift_module, "name", my)

    #   Resolve UIDs
    swift_module_resolve_uids (my.swift_module)
endfunction


# ===========================================================================
#   Component creation.
# ===========================================================================


# ---------------------------------------------------------------------------
#   Create entity <swift_inherit/> from NSObject.
# ---------------------------------------------------------------------------
function swift_create_inherit_nsobject (destination)
    check_arguments (my, "destination", my)

    new swift_inherit to my.destination
        .type = "NSObject"

        return swift_inherit
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create entity <swift_inherit/> from protocol that defines C context.
# ---------------------------------------------------------------------------
function swift_create_inherit_c_context (destination)
    check_arguments (my, "destination", my)

    new swift_inherit to my.destination
        .type = "CContext"

        return swift_inherit
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create entity <swift_inherit/> from the entity <inherit/>.
# ---------------------------------------------------------------------------
function swift_create_inherit (inherit, destination, swift_project, meta)
    check_arguments (my, "inherit, destination, swift_project, meta", my)

    new swift_inherit to my.destination
        .type = swift_derive_protocol_name (my.inherit, my.swift_project)

        return swift_inherit
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Add new <swift_class/> that encapsulate multiple objects returned by
#   method.
# ---------------------------------------------------------------------------
function swift_create_result_class (parent, swift_method, destination, swift_project, meta)
    check_arguments (my, "parent, swift_method, destination, swift_project, meta", my)

    assert_attributes (my.parent, "name, visibility", my)
    assert_attribute (my.swift_method, "name", my)

    if item_in (my.parent, "swift_class") & defined (my.swift_method.interface)
        for my.swift_method.swift_return
            delete swift_return
        endfor

        new swift_return to my.swift_method
            .type = swift_derive_result_class_name (my.parent, my.swift_method)
        endnew

        return
    endif

    new swift_class to my.destination
        . = "/// Encapsulate result of method $(my.parent.name:).$(my.swift_method.name:)()"
        .name = swift_derive_result_class_name (my.parent, my.swift_method)
        .objc_name = swift_derive_class_objc_name (swift_class, my.swift_project)
        .visibility = my.parent.visibility

        swift_create_inherit_nsobject (swift_class)

        for my.swift_method.swift_return
            new swift_property to swift_class
                .name = swift_return.name
                .type = swift_return.type
                .access = "readonly"
                .visibility = "public"
            endnew

            delete swift_return
        endfor

        new swift_return to my.swift_method
            .type = swift_class.name
        endnew

        new swift_constructor to swift_class
            . = "/// Initialize all properties."
            .visibility = "internal"

            for swift_class.swift_property
                copy swift_property as swift_argument to swift_constructor
            endfor

            new swift_code to swift_constructor
                my.method_body ?= ""

                for swift_class.swift_property
                    my.method_body += format_left ("\
                        self.$(swift_property.name:) = $(swift_property.name:)
                    ")
                endfor

                my.method_body += format_left ("super.init()")

                . = my.method_body
            endnew
        endnew

        return swift_class
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create entity <swift_property/> from the entity <instance/>.
# ---------------------------------------------------------------------------
function swift_create_property_from_constant (constant, destination, swift_project, meta)
    check_arguments (my, "constant, destination, swift_project, meta", my)

    new swift_property to my.destination
        . = swift_format_description (my.constant) ?
        .name = swift_derive_constant_name (my.constant, my.swift_project)
        .type = swift_derive_constant_type (my.constant, my.swift_project)
        .value = my.constant.value ?
        .visibility = "public"
        .access = "readonly"

        return swift_property
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create entity <swift_property/> from the entity <instance/>.
# ---------------------------------------------------------------------------
function swift_create_property_from_instance (instance, destination, swift_project, meta)
    check_arguments (my, "instance, destination, swift_project, meta", my)

    assert_attribute (my.instance, "access", my)

    new swift_property to my.destination
        . = swift_format_description (my.instance) ?
        .name = swift_derive_instance_name (my.instance, my.swift_project)

        swift_map_instance (swift_property, my.instance)

        new swift_getter to swift_property
        endnew

        if my.instance.access <> "readonly"
            new swift_setter to swift_property
            endnew
        endif

        return swift_property
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create entity <swift_argument/> from the entity <argument/>.
# ---------------------------------------------------------------------------
function swift_create_argument (argument, destination, swift_project, meta)
    check_arguments (my, "argument, destination, swift_project, meta", my)

    assert_attributes (my.argument, "name", my)

    new swift_argument to my.destination
        .name = swift_derive_instance_name (my.argument)

        swift_map_instance (swift_argument, my.argument)

        return swift_argument
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create entity <swift_return/> from the entity <argument/>.
# ---------------------------------------------------------------------------
function swift_create_return_from_argument (class, method, argument, destination, swift_project, meta)
    check_arguments (my, "class, method, argument, destination, swift_project, meta", my)

    assert_attributes (my.argument, "name", my)

    new swift_return to my.destination
        .name = swift_derive_instance_name (my.argument)
        swift_map_instance (swift_return, my.argument)
        swift_return.was_argument = "1"

        if string_equal (my.argument.class, "buffer")
            swift_return.length_getter = class_derive_buffer_length_getter (my.class, my.method, argument)
        endif

        return swift_return
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create entity <swift_return/> from the entity <return/> if it is not
#   a status, otherwise nothing is created.
# ---------------------------------------------------------------------------
function swift_create_return (return, destination, swift_project, meta)
    check_arguments (my, "return, destination, swift_project, meta", my)

    new swift_return to my.destination
        swift_map_instance (swift_return, my.return)
        return swift_return
    endnew
endfunction


# ---------------------------------------------------------------------------
#   Remove temporary create swift arguments that handle information about
#   error context that is passed to the C proxy call.
# ---------------------------------------------------------------------------
function swift_remove_error_arguments (swift_method)
    check_arguments (my, "swift_method", my)

    for my.swift_method.swift_argument where is_true (swift_argument.is_error)
        delete swift_argument
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Create entity <swift_method/> with <method/> declaration.
# ---------------------------------------------------------------------------
function swift_create_method_declaration (class, method, destination, swift_project, meta)
    check_arguments (my, "class, method, destination, swift_project, meta", my)

    new swift_method to my.destination
        . = swift_format_description (my.method) ?
        .name = swift_derive_method_name (my.method, my.swift_project)
        .throws = swift_derive_method_throws (my.method)
        .handle_proxy_status = swift_derive_handle_proxy_status (my.method)
        .interface = my.method.interface ? #   When method comes from an interface.
        .objc = "1"

        if ! defined (my.method.interface)
            #   Method can be static only if it doesn't come from an interface.
            .modifier = is_true (my.method.is_static) ?? "static" ?
        endif

        swift_map_attr_visibility (swift_method, my.method)

        for my.method.argument
            if argument.access <> "writeonly"
                swift_create_argument (argument, swift_method, my.swift_project, my.meta)
            endif

            if string_in (argument.class, "buffer") & string_in (argument.access, "readwrite, writeonly")
                swift_create_return_from_argument (my.class, my.method, argument, swift_method, my.swift_project, my.meta)
            endif
        endfor

        for my.method.return where ! string_equal (return.enum, "status")
            swift_create_return (return, swift_method, my.swift_project, my.meta)
        endfor

        return swift_method
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Return true if Swift method throw exception and return primitive type it
#   can not be used within Objective-C, so it should be wrapped separately.
# ---------------------------------------------------------------------------
function swift_method_is_objc_incompatible_case1 (swift_method)
    check_arguments (my, "swift_method", my)

    return is_true(my.swift_method.throws) & \
            count (my.swift_method.swift_return) = 1 & \
            is_true(my.swift_method->swift_return.is_primitive_type)
endfunction

# ---------------------------------------------------------------------------
#   Create <swift_method/> with declaration that is compatible with objc.
#   Case 1:
#       If Swift method throw exception and return primitive type it can not
#       be used within Objective-C, so it should be wrapped separately.
# ---------------------------------------------------------------------------
function swift_create_objc_compatible_method_declaration_case1 (swift_method, destination)
    check_arguments (my, "swift_method, destination", my)

    if !swift_method_is_objc_incompatible_case1(my.swift_method)
        echo_fatal(\
            "Given Swift method <method name=\"$(my.swift_method.name:)\"/>" + \
            " does not require Objective-C Case1 compatibility.", my)
    endif

    new swift_method to my.destination
        . = my.swift_method. ?
        .name = my.swift_method.name
        .throws = my.swift_method.throws
        .objc = "1"
        .handle_proxy_status = my.swift_method.handle_proxy_status # must be "false"
        .interface = my.swift_method.interface ?
        .modifier = my.swift_method.modifier ?
        .visibility = my.swift_method.visibility

        for my.swift_method.swift_argument
            copy swift_argument to swift_method
        endfor

        new swift_return to swift_method
            .type = "NSNumber"
            .is_primitive_type = "1"
        endnew

        return swift_method
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create implementation body Objective-C compatibility method.
#   Case 1:
#       If Swift method throw exception and return primitive type it can not
#       be used within Objective-C, so it should be wrapped separately.
# ---------------------------------------------------------------------------
function swift_create_objc_compatible_method_body_case1 (swift_method)
    check_arguments (my, "swift_method", my)

    if !swift_method_is_objc_incompatible_case1(my.swift_method)
        echo_fatal(\
            "Given Swift method <method name=\"$(my.swift_method.name:)\"/>" + \
            " does not require Objective-C Case1 compatibility.", my)
    endif

    new swift_code to my.swift_method
        . = "\
            return NSNumber(value: try self.$(my.swift_method.name:)($(swift_format_proxy_args (my.swift_method))))
        "
    endnew
endfunction


# ---------------------------------------------------------------------------
#   Return true if given method is not compatible with Objective-C.
#   Case 1:
#       If Swift method throw exception and return primitive type it can not
#       be used within Objective-C, so it should be wrapped separately.
# ---------------------------------------------------------------------------
function swift_method_is_objc_incompatible (swift_method)
    check_arguments (my, "swift_method", my)

    return swift_method_is_objc_incompatible_case1 (my.swift_method)
endfunction

# ---------------------------------------------------------------------------
#   Create <swift_method/> with declaration that is compatible with objc.
# ---------------------------------------------------------------------------
function swift_create_objc_compatible_method_declaration (swift_method, destination)
    check_arguments (my, "swift_method, destination", my)

    if !swift_method_is_objc_incompatible(my.swift_method)
        echo_fatal(\
            "Given Swift method <method name=\"$(my.swift_method.name:)\"/>" + \
            " does not require Objective-C compatibility.", my)
    endif

    my.swift_method.objc = "0"

    if swift_method_is_objc_incompatible_case1 (my.swift_method)
        return swift_create_objc_compatible_method_declaration_case1 (my.swift_method, my.destination)
    endif
endfunction

# ---------------------------------------------------------------------------
#   Create <swift_method/> with declaration that is compatible with objc.
# ---------------------------------------------------------------------------
function swift_create_objc_compatible_method_body (swift_method)
    check_arguments (my, "swift_method", my)

    if !swift_method_is_objc_incompatible(my.swift_method)
        echo_fatal(\
            "Given Swift method <method name=\"$(my.swift_method.name:)\"/>" + \
            " does not require Objective-C compatibility.", my)
    endif

    if swift_method_is_objc_incompatible_case1 (my.swift_method)
        return swift_create_objc_compatible_method_body_case1 (my.swift_method)
    endif
endfunction

# ---------------------------------------------------------------------------
#   Create entity <swift_method/> of from the interface entity <method/>.
# ---------------------------------------------------------------------------
function swift_create_interface_method (interface, method, destination, swift_project, meta)
    check_arguments (my, "interface, method, destination, swift_project, meta", my)

    my.swift_method = swift_create_method_declaration (my.interface, my.method, my.destination, my.swift_project, my.meta)
    swift_remove_error_arguments (my.swift_method)
    return my.swift_method
endfunction

# ---------------------------------------------------------------------------
#   Create entity <swift_method/> of from the class entity <method/>.
# ---------------------------------------------------------------------------
function swift_create_class_method (class, method, destination, swift_project, meta)
    check_arguments (my, "class, method, destination, swift_project, meta", my)

    #   Create declaration
    my.swift_method = swift_create_method_declaration (my.class, my.method, my.destination, my.swift_project, my.meta)

    #   Wrap proxy call
    my.proxy_args = swift_format_c_proxy_args (my.class, my.method)
    my.proxy_call = "$(class_derive_c_method (my.class, my.method))($(my.proxy_args:))"
    my.proxy_return_type = swift_derive_proxy_return_type (my.method)
    my.proxy_invocation = swift_wrap_c_proxy_call (my.swift_method, my.proxy_call, my.proxy_return_type, my.swift_project)

    #   Return result
    if count (my.swift_method.swift_return) = 1
        my.swift_return = my.swift_method->swift_return

        my.return_result = terminator + \
                format_left ("return $(swift_wrap_c_returned_value (my.swift_method->swift_return, my.swift_project))")

    elsif count (my.swift_method.swift_return) > 1
        my.result_class = swift_derive_result_class_name (my.destination, my.swift_method)
        my.result_class_init_args = swift_format_result_class_init_args (my.swift_method, my.swift_project)

        my.return_result = terminator + \
                format_left ("return $(my.result_class:)($(my.result_class_init_args:))")
    endif

    new swift_code to my.swift_method
        my.method_body = ""
        my.method_body += my.proxy_invocation ? ""
        my.method_body += my.return_result ? ""

        . = my.method_body
    endnew

    #   Cleanup
    swift_remove_error_arguments (my.swift_method)

    #   Add Objective-C compatibile method if needed.
    if swift_method_is_objc_incompatible (my.swift_method)
        my.objc_compatible_method = swift_create_objc_compatible_method_declaration (my.swift_method, my.destination)
        swift_create_objc_compatible_method_body (my.objc_compatible_method)
    endif

    return my.swift_method
endfunction

# ---------------------------------------------------------------------------
#   Create Swift computed property that makes proxy to retrieve constant.
# ---------------------------------------------------------------------------
function swift_create_proxy_property_from_constant (constant, interface, destination, swift_project, meta)
    check_arguments (my, "constant, interface, destination, swift_project, meta", my)

    my.swift_constant = swift_create_property_from_constant (my.constant, my.destination, my.swift_project, my.meta)

    my.api_getter = interface_derive_c_api_method (my.interface)
    my.constant_getter = interface_derive_c_constant_method (my.interface, my.constant)

    new computed to my.swift_constant
        . = "\
            return $(my.constant_getter:)($(my.api_getter:)(self.c_ctx))
        "
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Add all components related to the interface.
# ---------------------------------------------------------------------------
function swift_create_interface_implementation (implementation, swift_class, swift_project, meta)
    check_arguments (my, "implementation, swift_class, swift_project, meta", my)

    for my.implementation.interface
        swift_create_inherit (interface, my.swift_class, my.swift_project, my.meta)

        for interface.constant
            swift_create_property_from_constant (constant, my.swift_class, my.swift_project, my.meta)
        endfor

        for interface.method where wrapper_should_wrap_method(method)
            swift_create_class_method (my.implementation, method, my.swift_class, my.swift_project, my.meta)
        endfor
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Create <swift_property/> that handles underlying C context.
# ---------------------------------------------------------------------------
function swift_create_class_property_context (destination, class)
    check_arguments (my, "destination", my)

    new swift_property to my.destination
        . = "/// Handle underlying C context."
        .name = "c_ctx"
        .type = swift_derive_class_context_type (my.class)
        .access = "readonly"
        .visibility = "public"

        return swift_property
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create enumeration <swift_constant/> from the entity <constant/>
# ---------------------------------------------------------------------------
function swift_create_enum_constant (constant, swift_enum, swift_project, meta)
    check_arguments (my, "constant, swift_enum, swift_project, meta", my)

    assert_attribute (my.constant, "name", my)

    new swift_constant to my.swift_enum
        . = swift_format_description (my.constant) ?
        .name = swift_derive_constant_name (my.constant, my.swift_project)
        .value = my.constant.value ?
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Add entities specific for "status" enum.
# ---------------------------------------------------------------------------
function swift_map_enum_status (swift_enum, enum, swift_project, meta)
    check_arguments (my, "swift_enum, enum, swift_project, meta")

    new swift_inherit to my.swift_enum
        .type = "Error"
    endnew

    for my.enum.constant where 0.name <> "success"
        swift_create_enum_constant (constant, my.swift_enum, my.swift_project, my.meta)
    endfor

    new swift_method to my.swift_enum
        . = "/// Check given C status, and if it's not \"success\" then throw correspond exception."
        .name = "handleStatus"
        .visibility = "internal"
        .modifier = "static"
        .throws = "1"
        .objc = "1"

        new swift_argument to swift_method
            .name = "code"
            .ext_name = "fromC"
            .type = make_ref_c (make_id ("class", my.enum.name, "enum", my.enum.name))
        endnew

        my.success_constant = \
                make_ref_c (make_id ("class", my.enum.name, "enum", my.enum.name, "constant success"))

        new swift_code to swift_method
            . = "\
                if code != $(my.success_constant:) {
                    throw $(my.swift_enum.name:)(fromC: code)
                }
            "
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Add entities for regular enum (not status codes).
# ---------------------------------------------------------------------------
function swift_map_enum_default (swift_enum, enum, swift_project, meta)
    check_arguments (my, "swift_enum, enum, swift_project, meta")

    for my.enum.constant
        swift_create_enum_constant (constant, my.swift_enum, my.swift_project, my.meta)
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Add constructor init(fromC: c_enum_type)
# ---------------------------------------------------------------------------
function swift_create_enum_constructor (swift_enum, enum, swift_project, meta)
    check_arguments (my, "swift_enum, enum, swift_project, meta")

    new swift_constructor to my.swift_enum
        . = "/// Create enumeration value from the correspond C enumeration value."
        .visibility = "internal"

        my.arg_enum_name = swift_derive_argument_name (my.enum, my.swift_project)

        new swift_argument to swift_constructor
            .name = my.arg_enum_name
            .ext_name = "fromC"
            .type = make_ref_c (make_id ("class", my.enum.name, "enum", my.enum.name))
        endnew

        new swift_code to swift_constructor
            . = "\
                self.init(rawValue: Int($(my.arg_enum_name:).rawValue))!
            "
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create default <swift_constructor/> that initialize underlying C context.
# ---------------------------------------------------------------------------
function swift_create_class_default_constructor (swift_class, class, swift_project, meta)
    check_arguments (my, "swift_class, class, swift_project, meta", my)

    if string_in (my.class.context, "public") & string_in (my.class.lifecycle, "none")
        #
        #   This case was used for class "error" when it was mapped to the Swift class.
        #   At this very moment class "error" transformed to exceptions.
        #
        my.ctx_size_invocation = "$(class_derive_class_c_method_ctx_size (my.class))()"
        my.ctor_invocation = ".(c_global_method_alloc)($(my.ctx_size_invocation:))!" + \
                ".bindMemory(to: $(class_derive_c_type(my.class)).self, capacity:1)"
    else
        my.ctor_invocation = "$(class_derive_c_constructor (my.class))()"
    endif

    new swift_constructor to my.swift_class
        . = "/// Create underlying C context."
        .override = "1"
        .visibility = "public"

        new swift_code to swift_constructor
            . = "\
                self.c_ctx = $(my.ctor_invocation:)
                super.init()
            "
        endnew
    endnew

    new swift_constructor to my.swift_class
        . = "
            /// Acquire C context.
            /// Note. This method is used in generated code only, and SHOULD NOT be used in another way.
        "
        .visibility = "public"

        new swift_argument to swift_constructor
            .name = "c_ctx"
            .ext_name = "take"
            .type = swift_derive_class_context_type (my.class)
        endnew

        new swift_code to swift_constructor
            . = "\
                self.c_ctx = c_ctx
                super.init()
            "
        endnew
    endnew

    if string_in (my.class.lifecycle, "default")
        new swift_constructor to my.swift_class
            . = "\
                /// Acquire retained C context.
                /// Note. This method is used in generated code only, and SHOULD NOT be used in another way.
            "
            .visibility = "public"

            new swift_argument to swift_constructor
                .name = "c_ctx"
                .ext_name = "use"
                .type = swift_derive_class_context_type (my.class)
            endnew

            new swift_code to swift_constructor
                . = "\
                    self.c_ctx = $(class_derive_c_method_shallow_copy (my.class))(c_ctx)
                    super.init()
                "
            endnew
        endnew
    endif
endfunction

# ---------------------------------------------------------------------------
#   Create <swift_constructor/> from abstract entity <constructor/>.
# ---------------------------------------------------------------------------
function swift_create_class_constructor (class, constructor, destination, swift_project, meta)
    check_arguments (my, "class, constructor, destination, swift_project, meta", my)

    new swift_constructor to my.destination
        . = swift_format_description (my.constructor) ?
        .visibility = "public"

        for my.constructor.argument
            swift_create_argument (argument, swift_constructor, my.swift_project, my.meta)
        endfor

        #   Wrap proxy call
        my.proxy_args = swift_format_c_proxy_args (my.class, my.constructor)
        my.proxy_call = "$(class_derive_c_constructor (my.class, my.constructor.name))($(my.proxy_args:))"
        my.proxy_return_type = swift_derive_class_context_type (my.class) + "?"
        my.proxy_invocation = swift_wrap_c_proxy_call (swift_constructor, my.proxy_call, my.proxy_return_type, my.swift_project)

        my.context_assignment = format_left ("self.c_ctx = proxyResult!")

        new swift_code to swift_constructor
            my.method_body = ""
            my.method_body += my.proxy_invocation ? ""
            my.method_body += terminator + my.context_assignment ? ""

            . = my.method_body
        endnew

        return swift_constructor
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create <swift_destructor/>.
# ---------------------------------------------------------------------------
function swift_create_class_destructor (swift_class, class, swift_project, meta)
    check_arguments (my, "swift_class, class, swift_project, meta", my)

    my.self_ctx = "self.c_ctx"

    if string_in (my.class.context, "public") & string_in (my.class.lifecycle, "none")
        my.dtor_invocation = ".(c_global_method_dealloc)($(my.self_ctx:))"
    else
        my.dtor_invocation = "$(class_derive_c_destructor (my.class))($(my.self_ctx:))"
    endif


    new swift_destructor to my.swift_class
        . = "/// Release underlying C context."

        new swift_code to swift_destructor
            . = "\
                $(my.dtor_invocation:)
            "
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Add <swift_method/> with setter only that proxy dependency to the
#   C context.
# ---------------------------------------------------------------------------
function swift_create_method_from_dependency (dependency, impl, destination, swift_project, meta)
    check_arguments (my, "dependency, impl, destination, swift_project, meta", my)

    new swift_method to my.destination
        . = swift_format_description (my.dependency) ?
        .name = swift_derive_method_name_str (cat ("set", my.dependency.name))
        .visibility = "public"
        .throws = my.dependency.has_observers & my.dependency.is_observers_return_status
        .objc = "1"

        my.arg_name = swift_derive_argument_name (my.dependency)

        new swift_argument to swift_method
            .name = my.arg_name
            .type = swift_derive_dependency_type (my.dependency)
        endnew

        new swift_code to swift_method
            if my.dependency.has_observers & my.dependency.is_observers_return_status
                my.result_var = "let proxyResult = "
                my.enum_status = swift_derive_enum_status_name (my.swift_project.name)
                my.impl_handle_status = "try $(my.enum_status:).handleStatus(fromC: proxyResult)"
            endif

            . = format_left("\
                $(class_derive_c_method_release_dependency (my.impl, my.dependency))(self.c_ctx)
                $(my.result_var?:)$(class_derive_c_method_use_dependency (my.impl, my.dependency))(self.c_ctx,\
                        $(my.arg_name:).c_ctx)
                $(my.impl_handle_status?:)
            ")
        endnew
    endnew
endfunction


# ---------------------------------------------------------------------------
#   Create class <swift_constant/> from the entity <constant/>
# ---------------------------------------------------------------------------
function swift_create_class_constant (constant, swift_class, swift_project, meta)
    check_arguments (my, "constant, swift_class, swift_project, meta", my)

    assert_attribute (my.constant, "name", my)
    assert_attribute (my.constant, "value", my)

    new swift_constant to my.swift_class
        . = swift_format_description (my.constant) ?
        .name = swift_derive_constant_name (my.constant, my.swift_project)
        .type = swift_derive_constant_type (my.constant, my.swift_project)
        .value = my.constant.value
        .visibility = "public"
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create module and return it's class that handles implementation helper.
# ---------------------------------------------------------------------------
function swift_get_implementation_helper_class (swift_project, meta)
    check_arguments (my, "swift_project, meta", my)

    my.name = "$(my.swift_project.name:Pascal)Implementation"

    my.implementation_helper_module = my.swift_project->swift_module(name = my.name) ?

    if defined (my.implementation_helper_module)
        return my.implementation_helper_module->swift_class
    endif

    new swift_module to my.swift_project
        . = "/// Create factory that turns C implementation object to the Swift implementation object."
        .name = my.name
        .source_file_name = 0.name + ".swift"
        .source_file_path = cat_path (my.swift_project.source_dir, 0.source_file_name)

        new swift_license to swift_module
            . = swift_format_license (my.swift_project->license) ?
        endnew

        for my.swift_project.swift_import
            copy swift_import to swift_module
        endfor

        new swift_class to swift_module
            .name = my.name
            .objc_name = swift_derive_class_objc_name (swift_class, my.swift_project)
            .visibility = "public"

            swift_create_inherit_nsobject (swift_class)

            return swift_class
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Return interface method that wraps C implementation object to the
#   Swift object.
# ---------------------------------------------------------------------------
function swift_get_implementation_helper_interface_method (swift_class, interface, swift_project)
    check_arguments (my, "swift_class, interface, swift_project", my)

    my.interface_method_name = "wrap$(my.interface.name:Pascal)"

    my.wrap_interface_method = \
            my.swift_class->swift_method (name = my.interface_method_name & is_true(swift_method.is_primary)) ?

    if defined (my.wrap_interface_method)
        return my.wrap_interface_method
    endif

    new swift_method to my.swift_class
        my.protocol_name = swift_derive_protocol_name (my.interface, my.swift_project)
        . = "\
            /// Wrap C implementation object to the Swift object that implements protocol $(my.protocol_name:).
        "
        .name = my.interface_method_name
        .modifier = "static"
        .objc = "1"
        .is_primary = "1"

        new swift_argument to swift_method
            .name = "c_ctx"
            .ext_name = "take"
            .type = "OpaquePointer"
        endnew

        new swift_return to swift_method
            .type = swift_derive_protocol_name (my.interface, my.swift_project)
        endnew

        new swift_code to swift_method
            my.method_of_class = my.interface.of_class ? my.interface.name
            my.method_is_implemented = make_ref_c (make_id ("class", my.method_of_class, "method", "is_implemented"))
            .temp_code = format_left("\
                if (!$(my.method_is_implemented:)(c_ctx)) {
                    fatalError(\"Given C implementation does not implement interface $(my.protocol_name:).\")
                }

                let implTag = .(c_class_impl_method_tag)(c_ctx)
                switch(implTag) {
            ")
        endnew

        my.wrap_interface_method = swift_method
    endnew

    new swift_method to my.swift_class
        my.protocol_name = swift_derive_protocol_name (my.interface, my.swift_project)
        . = "\
            /// Wrap C implementation object to the Swift object that implements protocol $(my.protocol_name:).
        "
        .name = my.interface_method_name
        .modifier = "static"
        .objc = "1"

        new swift_argument to swift_method
            .name = "c_ctx"
            .ext_name = "use"
            .type = "OpaquePointer"
        endnew

        new swift_return to swift_method
            .type = swift_derive_protocol_name (my.interface, my.swift_project)
        endnew

        new swift_code to swift_method
            my.method_of_class = my.interface.of_class ? my.interface.name
            my.method_is_implemented = make_ref_c (make_id ("class", my.method_of_class, "method", "is_implemented"))
            . = format_left("
                let shallowCopy = .(c_class_impl_method_shallow_copy)(c_ctx)!
                return $(my.swift_class.name:).$(my.interface_method_name:)(take:shallowCopy)
            ")
        endnew
    endnew

    return my.wrap_interface_method
endfunction


# ---------------------------------------------------------------------------
#   Add wrapper "case" statement for implementation/interface pair.
# ---------------------------------------------------------------------------
function swift_update_implementation_helper_module (implementation, swift_project, meta)
    check_arguments (my, "implementation, swift_project, meta", my)

    my.helper_class = swift_get_implementation_helper_class(my.swift_project, my.meta)
    my.refs = meta_refs (my.meta)

    for my.implementation.interface
        my.wrap_interface_method = \
                swift_get_implementation_helper_interface_method (my.helper_class, interface, my.swift_project)

        my.wrap_interface_method->swift_code.temp_code += format_left("\
            case $(my.refs.c_implementation_constant_tag):
                return $(swift_derive_class_name (my.implementation, my.swift_project))(take: c_ctx)
        ")
    endfor
endfunction


# ===========================================================================
#   Create modules.
# ===========================================================================

# ---------------------------------------------------------------------------
#   Create module that contains Swift specific project information.
# ---------------------------------------------------------------------------
function swift_create_project_module (project, wrapper)
    check_arguments (my, "project, wrapper", my)

    assert_attribute (my.wrapper, "lang", my)
    assert_attributes (my.project, "name, prefix, framework", my)
    assert_item (my.project, "license", my)

    echo_info ("Create Swift project for project: '$(my.project.name:)'", my)

    new swift_project to my.wrapper
        . = my.project. ?
        .name = my.project.name
        .prefix = my.project.prefix
        .framework = my.project.framework
        .namespace = "$(my.project.namespace:Pascal)"
        .namespace_dir = swift_project.namespace
        .source_dir = cat_path (my.wrapper.source_dir, 0.namespace_dir)

        copy my.project->license to swift_project

        new swift_uid to swift_project
            .name = swift_project.namespace
            .uid = "swift_framework_name"
        endnew

        new swift_import to swift_project
            .framework = "Foundation"
        endnew

        new swift_import to swift_project
            .framework = swift_project.framework
        endnew

        for my.project.require where defined (require.project) & string_equal (require.feature, "library")
            my.required_swift_project = my.wrapper->swift_project (name = require.project) ?

            if defined (my.required_swift_project)
                new swift_import to swift_project
                    .framework = my.required_swift_project.namespace
                endnew
            endif
        endfor

        return swift_project
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create custom modules:
#       - module with base protocol that handles C context.
# ---------------------------------------------------------------------------
function swift_create_custom_modules (source, swift_project, meta)
    check_arguments (my, "source, swift_project, meta", my)

    if !count (my.source.class, scope = "public" & !string_in (name, "data, buffer")) & \
            !count (my.source.interface, scope = "public")
        return
    endif

    my.name = "CContext"

    new swift_module to my.swift_project
        . = "/// This is base protocol for all types that wrap C interfaces."
        .name = my.name
        .source_file_name = 0.name + ".swift"
        .source_file_path = cat_path (my.swift_project.source_dir, 0.source_file_name)

        new swift_license to swift_module
            . = swift_format_license (my.swift_project->license) ?
        endnew

        new swift_import to swift_module
            .framework = "Foundation"
        endnew

        new swift_protocol to swift_module
            .name = my.name
            .objc_name = swift_derive_protocol_objc_name (swift_protocol, my.swift_project)
            .visibility = "public"

            swift_create_class_property_context (swift_protocol)
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create module with Swift protocol from the abstract 'interface' notion.
# ---------------------------------------------------------------------------
function swift_create_interface_module (interface, swift_project, meta)
    check_arguments (my, "interface, swift_project, meta", my)

    echo_info ("Create <swift_module/> from interface: '$(my.interface.name:)'", my)

    new swift_module to my.swift_project
        .name = swift_derive_module_name (my.interface)
        .source_file_name = 0.name + ".swift"
        .source_file_path = cat_path (my.swift_project.source_dir, 0.source_file_name)

        new swift_license to swift_module
            . = swift_format_license (my.swift_project->license) ?
        endnew

        for my.swift_project.swift_import
            copy swift_import to swift_module
        endfor

        new swift_protocol to swift_module
            . = swift_format_description (my.interface) ?
            .name = swift_derive_protocol_name (my.interface, my.swift_project)
            .objc_name = swift_derive_protocol_objc_name (swift_protocol, my.swift_project)

            swift_map_attr_visibility (swift_protocol, my.interface)

            for my.interface.inherit
                swift_create_inherit (inherit, swift_protocol, my.swift_project, my.meta)
            else
                swift_create_inherit_c_context (swift_protocol)
            endfor

            for my.interface.constant
                swift_create_property_from_constant (constant, swift_protocol, my.swift_project, my.meta)
            endfor

            for my.interface.method where wrapper_should_wrap_method(method)
                my.swift_method = \
                        swift_create_interface_method (my.interface, method, swift_protocol, my.swift_project, my.meta)

                if swift_method_is_objc_incompatible (my.swift_method)
                    swift_create_objc_compatible_method_declaration (my.swift_method, swift_protocol)
                endif
            endfor

            for swift_protocol.swift_method where count (0.swift_return) > 1
                swift_create_result_class (swift_protocol, swift_method, swift_module, my.swift_project, my.meta)
            endfor
        endnew
    endnew

    echo_debug ("Done", my)
endfunction

# ---------------------------------------------------------------------------
#   Create module with Swift class from the abstract 'implementation' notion.
# ---------------------------------------------------------------------------
function swift_create_implementation_module (implementation, swift_project, meta)
    check_arguments (my, "implementation, swift_project, meta", my)

    if my.implementation.scope <> "internal"
        echo_info ("Create <swift_module/> from implementation: '$(my.implementation.name:)'", my)
    else
        echo_info ("Skip creating <swift_module/> from internal implementation: '$(my.implementation.name:)'", my)
    endif

    new swift_module to my.swift_project
        .name = swift_derive_module_name (my.implementation)
        .source_file_name = 0.name + ".swift"
        .source_file_path = cat_path (my.swift_project.source_dir, 0.source_file_name)

        new swift_license to swift_module
            . = swift_format_license (my.swift_project->license) ?
        endnew

        for my.swift_project.swift_import
            copy swift_import to swift_module
        endfor

        new swift_class to swift_module
            . = swift_format_description (my.implementation) ?
            .name = swift_derive_class_name (my.implementation, my.swift_project)
            .objc_name = swift_derive_class_objc_name (swift_class, my.swift_project)

            swift_map_attr_visibility (swift_class, my.implementation)

            swift_create_inherit_nsobject (swift_class)

            for my.implementation.constant where wrapper_should_wrap_class_constant(constant)
                swift_create_class_constant (constant, swift_class, my.swift_project, my.meta)
            endfor

            for my.implementation.dependency
                swift_create_method_from_dependency (dependency, my.implementation, swift_class, my.swift_project, my.meta)
            endfor

            for my.implementation.method where wrapper_should_wrap_method(method)
                swift_create_class_method (my.implementation, method, swift_class, my.swift_project, my.meta)
            endfor

            if my.implementation.context <> "none"
                swift_create_class_property_context (swift_class, my.implementation)

                swift_create_class_default_constructor (swift_class, my.implementation, my.swift_project, my.meta)
                swift_create_class_destructor (swift_class, my.implementation, my.swift_project, my.meta)

                if my.implementation.lifecycle <> "none"
                    for my.implementation.constructor where 0.declaration = "public" & 0.visibility = "public"
                        swift_create_class_constructor (\
                            my.implementation, constructor, swift_class, my.swift_project, my.meta)
                    endfor
                endif
            endif

            swift_create_interface_implementation (my.implementation, swift_class, my.swift_project, my.meta)
            swift_update_implementation_helper_module (my.implementation, my.swift_project, my.meta)

            for swift_class.swift_method where count (0.swift_return) > 1
                swift_create_result_class (swift_class, swift_method, swift_module, my.swift_project, my.meta)
            endfor
        endnew
    endnew

    echo_debug ("Done", my)
endfunction

# ---------------------------------------------------------------------------
#   Add methods ending within implementation helper class.
# ---------------------------------------------------------------------------
function swift_finalize_implementation_helper_modules (swift_project, meta)
    check_arguments (my, "swift_project, meta", my)

    my.helper_class = swift_get_implementation_helper_class(my.swift_project, my.meta)

    for my.helper_class.swift_method where is_true(swift_method.is_primary)
        swift_method->swift_code.temp_code += format_left ("\
            default:
                fatalError(\"Unexpected C implementation cast to the Swift implementation.\")
            }
        ")

        swift_method->swift_code. = swift_method->swift_code.temp_code
        swift_method->swift_code.temp_code = # undefined
    endfor
endfunction


# ---------------------------------------------------------------------------
#   Perform finalization for custom modules.
# ---------------------------------------------------------------------------
function swift_finalize_custom_modules (source, swift_project, meta)
    check_arguments (my, "source, swift_project, meta", my)

    swift_finalize_implementation_helper_modules (my.swift_project, my.meta)
endfunction

# ---------------------------------------------------------------------------
#   Create module with Swift class from the abstract 'class' notion.
# ---------------------------------------------------------------------------
function swift_create_class_module (class, swift_project, meta)
    check_arguments (my, "class, swift_project, meta", my)

    echo_info ("Create <swift_module/> from class: '$(my.class.name:)'", my)

    assert_attribute (my.class, "name", my)

    if string_in (my.class.name, "data, buffer, error")
        #   Do not generate classes that can be mapped to the built-in types.
        return
    endif

    new swift_module to my.swift_project
        .name = swift_derive_module_name (my.class)
        .source_file_name = 0.name + ".swift"
        .source_file_path = cat_path (my.swift_project.source_dir, 0.source_file_name)

        new swift_license to swift_module
            . = swift_format_license (my.swift_project->license) ?
        endnew

        for my.swift_project.swift_import
            copy swift_import to swift_module
        endfor

        new swift_class to swift_module
            . = swift_format_description (my.class) ?
            .name = swift_derive_class_name (my.class, my.swift_project)
            .objc_name = swift_derive_class_objc_name (swift_class, my.swift_project)

            swift_map_attr_visibility (swift_class, my.class)

            swift_create_inherit_nsobject (swift_class)

            if my.class.context <> "none"
                swift_create_class_property_context (swift_class, my.class)

                swift_create_class_default_constructor (swift_class, my.class, my.swift_project, my.meta)
                swift_create_class_destructor (swift_class, my.class, my.swift_project, my.meta)

                if my.class.lifecycle <> "none"
                    for my.class.constructor where 0.declaration = "public" & 0.visibility = "public"
                        swift_create_class_constructor (my.class, constructor, swift_class, my.swift_project, my.meta)
                    endfor
                endif
            endif

            for my.class.constant where wrapper_should_wrap_class_constant(constant)
                swift_create_class_constant (constant, swift_class, my.swift_project, my.meta)
            endfor

            for my.class.dependency
                swift_create_method_from_dependency (dependency, my.class, swift_class, my.swift_project, my.meta)
            endfor

            for my.class.method where wrapper_should_wrap_method(method)
                swift_create_class_method (my.class, method, swift_class, my.swift_project, my.meta)
            endfor

            for swift_class.swift_method where count (0.swift_return) > 1
                swift_create_result_class (swift_class, swift_method, swift_module, my.swift_project, my.meta)
            endfor
        endnew
    endnew

    echo_debug ("Done", my)
endfunction

# ---------------------------------------------------------------------------
#   Create module with Swift enum from the abstract 'enum' notion.
# ---------------------------------------------------------------------------
function swift_create_enum_module (enum, swift_project, meta)
    check_arguments (my, "enum, swift_project, meta", my)

    echo_info ("Create <swift_module/> from enum: '$(my.enum.name:)'", my)

    assert_attribute (my.enum, "name", my)

    new swift_module to my.swift_project
        .name = swift_derive_enum_name (my.enum, my.swift_project)
        .source_file_name = 0.name + ".swift"
        .source_file_path = cat_path (my.swift_project.source_dir, 0.source_file_name)

        new swift_license to swift_module
            . = swift_format_license (my.swift_project->license) ?
        endnew

        new swift_import to swift_module
            .framework = "Foundation"
        endnew

        new swift_import to swift_module
            .framework = my.swift_project.framework
        endnew

        new swift_enum to swift_module
            . = swift_format_description (my.enum) ?
            .name = swift_derive_enum_name (my.enum, my.swift_project)
            .objc_name = swift_derive_enum_objc_name (swift_enum, my.swift_project)

            swift_map_attr_visibility (swift_enum, my.enum)
            swift_map_attr_scope (swift_enum, my.enum)

            new swift_inherit to swift_enum
                .type = "Int"
            endnew

            if my.enum.name = "status"
                swift_map_enum_status (swift_enum, my.enum, my.swift_project, my.meta)
            else
                swift_map_enum_default (swift_enum, my.enum, my.swift_project, my.meta)
            endif

            swift_create_enum_constructor (swift_enum, my.enum, my.swift_project, my.meta)
        endnew
    endnew

    echo_debug ("Done", my)
endfunction

.endtemplate
