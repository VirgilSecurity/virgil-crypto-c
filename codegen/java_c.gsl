.template 0
#   Copyright (C) 2015-2020 Virgil Security Inc.
#
#   All rights reserved.
#
#   Redistribution and use in source and binary forms, with or without
#   modification, are permitted provided that the following conditions are
#   met:
#
#       (1) Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#
#       (2) Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in
#       the documentation and/or other materials provided with the
#       distribution.
#
#       (3) Neither the name of the copyright holder nor the names of its
#       contributors may be used to endorse or promote products derived from
#       this software without specific prior written permission.
#
#   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR
#   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#   DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
#   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
#   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
#   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
#   STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
#   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#   POSSIBILITY OF SUCH DAMAGE.
#
#   Lead Maintainer: Virgil Security Inc. <support@virgilsecurity.com>

# ---------------------------------------------------------------------------
#   Contains API for Java java_project generation.
# ---------------------------------------------------------------------------
#   This is a code generator built using the iMatix GSL code generation
#   language. See https://github.com/zeromq/gsl for details.
# ---------------------------------------------------------------------------

gsl from "common.gsl"

# ---------------------------------------------------------------------------
#   Define is instance an error.
# ---------------------------------------------------------------------------
function java_is_error (instance)
    check_arguments (my, "instance", my)

    return string_equal (argument.class, "error")
endfunction

# ---------------------------------------------------------------------------
#   Return formatted argument name from raw name.
# ---------------------------------------------------------------------------
function java_derive_c_argument_name_str (name, java_project)
    check_arguments (my, "name", my)

    return "$(my.name:c)"
endfunction

# ---------------------------------------------------------------------------
#   Return formatted argument name from raw name.
# ---------------------------------------------------------------------------
function java_derive_c_class_name_str (name, java_project)
    check_arguments (my, "name", my)

    return "$(my.name:c)"
endfunction

# ---------------------------------------------------------------------------
#   Return name of the C context module
# ---------------------------------------------------------------------------
function java_derive_c_context_module_name (java_project)
    check_arguments (my, "java_project", my)

    return "$(my.java_project.name:Pascal)JNI_c"
endfunction

# ---------------------------------------------------------------------------
#   Return .(UID) that refers to the C type of the class.
# ---------------------------------------------------------------------------
function java_derive_c_type (instance)
    check_arguments (my, "instance", my)

    if item_in (my.instance, "interface")
        my.project_uid = c_component_derive_instance_project_uid (my.instance)
        my.type_uid = c_component_derive_instance_type_uid ("struct", "impl", "impl")
        return "$(make_ref_c (make_id(my.project_uid, my.type_uid)):) /*1*/"

    elsif item_in (my.instance, "class")
        return "$(make_ref_c (make_id ("class", my.instance.name, "struct", my.instance.name))) /*2*/"

    elsif defined (my.instance.class)
        if my.instance.class = "data"
            return ".(c_project_common_class_data_struct_data) /*3*/"

        elsif my.instance.class = "error"
            return "$(make_ref_c (make_id ("class", my.instance.class, "struct", my.instance.class))) /*4*/"

        else
            my.project_uid = c_component_derive_instance_project_uid (my.instance)
            my.type_uid = c_component_derive_instance_type_uid ("struct", my.instance.class, my.instance.class)
            return "$(make_ref_c (make_id(my.project_uid, my.type_uid)):) */*5*/"
        endif

    elsif defined (my.instance.interface)
        my.project_uid = c_component_derive_instance_project_uid (my.instance)
        my.type_uid = c_component_derive_instance_type_uid ("struct", "impl", "impl")
        return "$(make_ref_c (make_id(my.project_uid, my.type_uid)):) */*6*/"
    elsif defined (my.instance.impl)
        return "$(make_ref_c (make_id ("class", my.instance.impl, "struct", my.instance.impl))) * /*7*/"
    elsif defined (my.instance.type)
        if count (my.instance.array)
            return "$(my.instance.type:) *"
        else
            return my.instance.type
        endif
    elsif defined (my.instance.enum)
        my.project_uid = c_component_derive_instance_project_uid (my.instance)
        my.type_uid = make_id ("class", my.instance.enum, "enum", my.instance.enum)
        return "$(make_ref_c (make_id(my.project_uid, my.type_uid)):) /*8*/"
    endif

    return "$(make_ref_c (make_id ("class", my.instance.name, "struct", my.instance.name))) /*9*/"
endfunction

# ---------------------------------------------------------------------------
#   Derive C type from the <instance/> type attributes.
# ---------------------------------------------------------------------------
function java_derive_c_instance_type (instance)
    check_arguments (my, "instance", my)

    if defined (my.instance.type)
        if is_true (my.instance.is_reference)
            return "jlong"
        elsif count (my.instance.array)
            return "jbyteArray"
        else
            if my.instance.type = "byte"
                return "jbyte"

            elsif my.instance.type = "integer"
                return "jint"

            elsif my.instance.type = "unsigned"
                return "jlong"

            elsif my.instance.type = "size"
                return "jint"

            elsif string_in (my.instance.type, "char, string")
                return "jstring"

            elsif my.instance.type = "boolean"
                return "jboolean"

            else
                return "jbyte /*$(my.instance.type:)*/"
                #echo_fatal ("Unsupported instance type '$(my.instance.type)' for Java language.", my)
            endif
        endif

    elsif defined (my.instance.interface)

        return "jobject"

    elsif defined (my.instance.class)

        if my.instance.class = "any"
            return "jobject"

        elsif my.instance.class = "data"
            return "jbyteArray"

        elsif my.instance.class = "buffer"
            return "jbyteArray"

        elsif my.instance.class = "str" | my.instance.class = "str buffer"
            return "jstring"

        else
            return "jobject"

        endif

    elsif defined (my.instance.enum)

        return "jobject"

    elsif defined (my.instance.impl)

        return "jobject"

    endif

   return "NULL"
   #echo_fatal ("Unsupported instance '$(my.instance)' for Java language.", my)

endfunction

# ---------------------------------------------------------------------------
#   Derive JNI field descriptor from the <instance/> type attributes.
# ---------------------------------------------------------------------------
function java_derive_c_field_descriptor (instance, java_project)
    check_arguments (my, "instance", my)

    if defined (my.instance.type)
        if is_true (my.instance.is_reference)
            return "J"
        elsif count (my.instance.array)
            return "_3B"
        else
            if my.instance.type = "byte"
                return "B"

            elsif my.instance.type = "integer"
                return "I"

            elsif my.instance.type = "unsigned"
                return "J"

            elsif my.instance.type = "size"
                return "I"

            elsif string_in (my.instance.type, "char, string")
                return "Ljava_lang_String_2"

            elsif my.instance.type = "boolean"
                return "Z"

            else
                return "B"
            endif
        endif

    elsif defined (my.instance.interface)

        return "L$(my.java_project.package:c)_$(my.instance.interface:Pascal)_2"

    elsif defined (my.instance.class)

        if my.instance.class = "data"
            return "_3B"

        elsif my.instance.class = "buffer"
            return "_3B"

        elsif my.instance.class = "str | my.instance.class = str buffer"
            return "S"

        else
            return "L$(my.java_project.package:c)_$(my.instance.class:Pascal)_2"

        endif

    elsif defined (my.instance.enum)

        return "L$(my.java_project.package:c)_$(my.instance.enum:Pascal)_2"

    elsif defined (my.instance.impl)

        return "L$(my.java_project.package:c)_$(my.instance.impl:Pascal)_2"

    endif

   return "D"

endfunction

# ---------------------------------------------------------------------------
#   Return proxy type of the method return value.
# ---------------------------------------------------------------------------
function java_derive_c_return_type (method)
    check_arguments (my, "method", my)

    if ! count (my.method.return)
        return "void"
    endif

    my.return = my.method->return

    if defined (my.return.type)
        return java_derive_c_instance_type (my.return)

    elsif defined (my.return.enum)
        return make_ref_c (make_id ("class", my.return.enum, "enum", my.return.enum))

    elsif has_one_of_attribute (my.return, "interface, class, impl")
        return java_derive_c_type (my.return)
    endif

    return "Any"
endfunction

# ---------------------------------------------------------------------------
#   Return .(UID) of dependency type.
# ---------------------------------------------------------------------------
function java_derive_c_dependency_type (dependency)
    check_arguments (my, "dependency", my)

    my.project_uid = component_derive_project_uid (my.dependency)

    if defined (my.dependency.interface)
        my.type_uid = make_id ("protocol", "$(my.dependency.interface:Pascal)")

    elsif defined (my.dependency.api)
        my.type_uid = make_id ("protocol", "$(my.dependency.api:Pascal)")

    elsif defined (my.dependency.class)
        my.type_uid = make_id ("class", "$(my.dependency.class:Pascal)")

    elsif defined (my.dependency.impl)
        my.type_uid = make_id ("class", "$(my.dependency.impl:Pascal)")

    else
        echo_debug_item (my.dependency, my)
        echo_fatal ("Unhanded dependency type.", my)
    endif

    return make_ref_swift (make_id(my.project_uid, my.type_uid))
endfunction

# ---------------------------------------------------------------------------
#   Return formatted instance name.
# ---------------------------------------------------------------------------
function java_derive_c_instance_name (instance)
    check_arguments (my, "instance", my)

    assert_attribute (my.instance, "name", my)

    return "$(my.instance.name:c)"
endfunction

# ---------------------------------------------------------------------------
#   Return .(UID) that refers to the C class method.
# ---------------------------------------------------------------------------
function java_class_derive_c_method (class, method)
    check_arguments (my, "class, method", my)

    my.method_name = my.method.name
    if item_in (my.method, "constructor")
        my.method_name = "new $(my.method.name:)"
    endif

    if string_equal (my.method.of_class, "global") | string_equal (my.class.of_class, "global")
        return make_ref_c (make_id ("global method", my.method_name))

    else
        my.of_class = my.method.of_class ? my.class.of_class ? my.class.name
        return make_ref_c (make_id ("class", my.of_class, "method", my.method_name))
    endif
endfunction

# ---------------------------------------------------------------------------
#   Return formatted method name.
# ---------------------------------------------------------------------------
function java_derive_c_method_name (method, interface, java_project)
    check_arguments (my, "method, interface, java_project", my)

    if item_in (my.method, "constructor")
        my.c_method_name = java_derive_c_method_name_str ("new", my.interface, my.java_project)

        for my.method.argument
            my.field_descriptor = java_derive_c_field_descriptor (argument, my.java_project)
            my.c_method_name = "$(my.c_method_name:)$(my.field_descriptor:)"
        endfor
    else
        my.c_method_name = java_derive_c_method_name_str (my.method.name, my.interface, my.java_project)
    endif

    return my.c_method_name

endfunction

# ---------------------------------------------------------------------------
#   Return formatted method name.
# ---------------------------------------------------------------------------
function java_derive_c_method_name_str (method_name, interface, java_project)
    check_arguments (my, "method_name, interface, java_project", my)

    my.jniClassName = java_derive_jni_context_class_name (my.java_project)
    my.h_module = java_obtain_h_module(my.java_project)

    if string_equal (my.method_name, "new")
        my.suffix = "__"
    endif

    return "Java_$(my.java_project.package:c)_$(my.jniClassName:)_$(my.interface.name:Camel)_1$(my.method_name:Camel)$(my.suffix?:)"
endfunction

# ---------------------------------------------------------------------------
#   Return formatted method name.
# ---------------------------------------------------------------------------
function java_derive_c_real_method_name (method, proxy_name, java_project)
    check_arguments (my, "method, proxy_name, java_project", my)

    return "$(my.java_project.prefix:)_$(my.proxy_name:c)_$(my.method:c)"
endfunction

# ---------------------------------------------------------------------------
#   Return formatted constant name.
# ---------------------------------------------------------------------------
function java_derive_c_real_constant_name (constant, proxy_name, java_project)
    check_arguments (my, "constant, proxy_name, java_project", my)

    my.constant_name = "$(my.constant:c)"
    return "$(my.java_project.prefix:)_$(my.proxy_name:c)_$(my.constant_name:UPPER)"
endfunction

# ---------------------------------------------------------------------------
#   Return formatted class context variable name.
# ---------------------------------------------------------------------------
function java_derive_c_context_variable_name (class)
    check_arguments (my, "class", my)

    return "$(my.class.name:c)_ctx"
endfunction

# ---------------------------------------------------------------------------
#   Return formatted arguments list that is to by passed to the JNI method.
# ---------------------------------------------------------------------------
function java_format_c_args (class, method)
    check_arguments (my, "class, method", my)

    my.class_ctx = java_derive_c_context_variable_name (my.class)

    if string_in (my.class.context, "none")
        my.jni_args = ""
    elsif is_false (my.method.is_static)
        my.ctx_type = java_derive_c_type (my.class)
        my.jni_args = "$(my.class_ctx:) /*a1*/"
    elsif defined (my.method.implementation)
        my.jni_args = ""
    elsif defined (my.method.interface)
        my.ctx_type = java_derive_c_type (my.class)
        my.jni_args = "$(interface_derive_c_api_method_from_name(my.method.interface))(($(my.ctx_type:)) $(my.class_ctx:) /*a2*/)"
    endif

    for my.method.argument
        my.jni_args ?= ""
        if my.jni_args <> ""
            my.jni_args += ", "
        endif

        my.arg_name = java_derive_c_instance_name (argument)

        my.jni_arg = # undefined

        if string_in (argument.class, "data, buffer") | count (argument.array)
            my.jni_arg = "$(my.arg_name) /*a3*/"

        elsif java_is_error (argument)
            my.jni_arg = "&$(my.arg_name:) /*a4*/"

        elsif has_one_of_attribute (argument, "class, api, interface, impl")
            if argument.access = "disown"
                my.jni_arg = "$(my.arg_name:c)_copy /*a5*/"
            else
                my.jni_arg = "$(my.arg_name:c) /*a6*/"
            endif

        elsif defined (argument.enum)
            my.jni_arg = "$(my.arg_name:c) /*a7*/"
        elsif string_in (argument.type, "char, string")
            my.jni_arg = "$(java_derive_instance_name (argument)) /*a8*/"
        else
            my.jni_arg = "j$(java_derive_instance_name (argument)) /*a9*/"
        endif

        if defined (my.jni_arg) & argument.access = "disown"
            my.jni_arg = "&" + my.jni_arg
        endif

        my.jni_args += my.jni_arg ? ""
    endfor

    return my.jni_args ? ""
endfunction

# ---------------------------------------------------------------------------
#   Remove temporary create java arguments that handle information about
#   error context that is passed to the C proxy call.
# ---------------------------------------------------------------------------
function java_remove_c_error_arguments (c_method)
    check_arguments (my, "c_method", my)

    for my.c_method.c_argument where is_true (c_argument.is_error)
        delete c_argument
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Return .(UID) that refers to the C instance shallow copy method.
# ---------------------------------------------------------------------------
function java_derive_c_method_shallow_copy (instance)
    check_arguments (my, "instance", my)

    if has_one_of_attribute(my.instance, "interface")
        return make_ref_c (make_id ("class", "impl", "method", "shallow copy"))

    elsif has_one_of_attribute(my.instance, "class, impl")
        return make_ref_c (make_id ("class", my.instance.class ? my.instance.impl, "method", "shallow copy"))
    endif

    return "/* shallow copy method not defined */"
endfunction

# ---------------------------------------------------------------------------
#   Return invocation of the getter function that returns buffer length.
# ---------------------------------------------------------------------------
function java_derive_buffer_length_getter (class, method, argument, java_project)
    assert_attributes (my, "class, method, argument, java_project")

    assert_item (my.argument, "length", my)

    my.length = my.argument->length
    assert_attribute_one_of (my.length, "constant, argument, method", my)

    if string_equal (my.class.context, "none")
        my.proxy_args = ""
    else
        my.ctx_type = java_derive_c_type (my.class)
        my.proxy_args ?= "($(my.ctx_type:) *) c_ctx /*3*/"
    endif

    for my.length.proxy
        if ! defined (proxy.[to])
            echo_debug_item (my.argument, my)
            assert_attributes (proxy, "to", my)
        endif

        if my.proxy_args <> ""
            my.proxy_args += ", "
        endif

        if defined (proxy.argument)

            my.proxy_args += java_derive_c_argument_name_str (proxy.argument)

            if string_in (proxy.cast, "data_length, str_length")
                my.proxy_args += ".len"
            endif

            my.proxy_args += "/*a*/"

        elsif defined (proxy.constant)

            my.proxy_args += java_lang_ref (proxy.constant)
            my.proxy_args += "/*b*/"
        else
            echo_debug_item (my.argument, my)
            echo_fatal ("Buffer length argument can be proxied. Undefined type.", my)
        endif
    endfor

    my.specified_proxy_object = get_one_of_attribute (my.length, "class, interface, impl") ?
    if defined (my.specified_proxy_object)
        if my.specified_proxy_object = "self"
            my.specified_proxy_object = my.class.name
        endif
        my.proxy_object = my.specified_proxy_object
    else
        my.proxy_object = my.class.name
    endif

    if defined (my.length.method)
        my.proxy_method = java_derive_c_real_method_name (my.length.method, my.proxy_object, my.java_project)
        return "$(my.proxy_method:)($(my.proxy_args?:))"

    elsif defined (my.length.constant)
        if regexp.match ("\\d+", my.length.constant)
            return my.length.constant
        else
            my.proxy_constant = java_derive_c_real_constant_name(my.length.constant, my.proxy_object, my.java_project)
            return "$(my.proxy_constant:)"
        endif
    elsif defined (my.length.argument)
        if string_in (my.length.cast, "data_length, str_length")
            my.proxy_argument = "$(java_derive_argument_name_str (my.length.argument):).len"
        else
            my.proxy_argument = "j$(java_derive_argument_name_str (my.length.argument):)"
        endif
        return my.proxy_argument
    endif
endfunction

# ---------------------------------------------------------------------------
#   Obtain C module.
# ---------------------------------------------------------------------------
function java_obtain_c_module (java_project)
    check_arguments (my, "java_project", my)

    my.c_module_name = java_derive_c_context_module_name (my.java_project)
    return my.java_project->java_module(java_module.name = my.c_module_name)?
endfunction

# ---------------------------------------------------------------------------
#   Create entity <c_argument/> from the entity <argument/>.
# ---------------------------------------------------------------------------
function java_create_c_argument (argument, destination, java_project, meta)
    check_arguments (my, "argument, destination, java_project, meta", my)

    assert_attributes (my.argument, "name", my)

    my.name = java_derive_instance_name (my.argument)

    new c_argument to my.destination
        .name = "j$(my.name:)"
        java_map_attr_access (c_argument, my.argument)
        java_map_c_instance_type (c_argument, my.argument)

        return c_argument
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create entity <java_argument/> from C context.
# ---------------------------------------------------------------------------
function java_create_c_context_argument (destination, java_project, meta)
    check_arguments (my, "destination, java_project, meta", my)

    new c_argument to my.destination
        .name = "c_ctx"
        .type = "jlong"
        .is_primitive_type = "1"
        .is_reference = "0"

        return c_argument
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create entity <c_method/> of from the class entity <method/>.
# ---------------------------------------------------------------------------
function java_create_class_c_default_constructor (java_class, class, java_project, meta)
    check_arguments (my, "java_class, class, java_project, meta", my)

    echo_debug ("Create C constructor '$(my.java_class.name:)'", my)

    my.h_module = java_obtain_h_module(my.java_project)
    my.c_module = java_obtain_c_module(my.java_project)
    my.c_method_name = java_derive_c_method_name_str ("new", my.class, my.java_project)

    if ! defined (my.h_module->c_method(c_method.name = my.c_method_name)?)

        # Define method header
        new c_method to my.h_module
            .name = my.c_method_name
            .declaration = "1"
            .is_jni = "1"

            new c_return to c_method
                .type = "jlong"
            endnew
        endnew

        # Define method implementation
        if string_in (my.class.context, "public") & string_in (my.class.lifecycle, "none")
            my.ctx_size_invocation = "$(class_derive_class_c_method_ctx_size (my.class))()"
            my.ctor_invocation = ".(c_global_method_alloc)($(my.ctx_size_invocation:))"
        else
            my.ctor_invocation = "$(class_derive_c_constructor (my.class))()"
        endif

        new c_method to my.c_module
            .name = my.c_method_name
            .is_jni = "1"

            new c_code to c_method
                . = "
                    jlong c_ctx = 0;
                    *($(class_derive_c_type(my.class)) **)&c_ctx = $(my.ctor_invocation:);
                    return c_ctx;
                "
            endnew

            new c_return to c_method
                .type = "jlong"
            endnew
        endnew
    endif

endfunction

# ---------------------------------------------------------------------------
#   Create entity <c_method/> of from the class entity <method/>.
# ---------------------------------------------------------------------------
function java_create_c_class_constructor (class, constructor, java_class, java_method, java_project, meta)
    check_arguments (my, "class, constructor, java_class, java_method, java_project, meta", my)

    echo_debug ("Create C constructor for '$(my.class.name:)'", my)

    my.h_module = java_obtain_h_module(my.java_project)
    my.c_module = java_obtain_c_module(my.java_project)
    my.c_method_name = java_derive_c_method_name (my.constructor, my.class, my.java_project)

    # Define method header
    new c_method to my.h_module
        .name = my.c_method_name
        .declaration = "1"
        .is_jni = "1"

        for my.constructor.argument
            java_create_c_argument (argument, c_method, my.java_project, my.meta)
        endfor

        new c_return to c_method
            .type = "jlong"
        endnew
    endnew

    # Define method implementation

    #   Wrap proxy call
    new c_method to my.c_module
        .name = my.c_method_name
        .is_jni = "1"

        for my.constructor.argument
            java_create_c_argument (argument, c_method, my.java_project, my.meta)
        endfor

        new c_code to c_method
            . = java_create_c_class_method_call (my.class, my.constructor, my.java_class, my.java_method, c_method, my.java_project, my.meta)
        endnew

        new c_return to c_method
            .type = "jlong"
        endnew
    endnew

endfunction

# ---------------------------------------------------------------------------
#   Create custom modules:
#       - module with base protocol that handles C context.
# ---------------------------------------------------------------------------
function java_create_custom_modules (source, java_project, meta)
    check_arguments (my, "source, java_project, meta", my)

    if !count (my.source.class, scope = "public" & !string_in (name, "data, buffer")) & \
            !count (my.source.interface, scope = "public")
        return
    endif

    java_create_jni_context_module (my.java_project, my.meta)

    my.name = java_derive_jni_context_class_name(my.java_project)

    echo_info ("Create C context module <java_module/> for project: '$(my.java_project.name:)'", my)

    new java_module to my.java_project
        . = "/* Header for class $(my.name:). */"
        .name = java_derive_h_context_module_name (my.java_project)
        .package = my.java_project.package
        .source_type = "H"
        .source_dir = my.java_project.jni_source_dir
        .source_file_name = "$(my.name:).h"
        .source_file_path = cat_path (.source_dir, 0.source_file_name)

        new c_license to java_module
            . = java_format_license (my.java_project->license) ?
        endnew

        new c_include to java_module
            .include = "jni.h"
        endnew

    endnew

    echo_info ("Create C context module <java_c_module/>: '$(my.java_project:)'", my)

    new java_module to my.java_project
        . = "/* Implementation for class $(my.name:). */"
        .name = java_derive_c_context_module_name (my.java_project)
        .package = my.java_project.package
        .source_type = "C"
        .source_dir = my.java_project.jni_source_dir
        .source_file_name = "$(my.name:).c"
        .source_file_path = cat_path (.source_dir, 0.source_file_name)

        new c_license to java_module
            . = java_format_license (my.java_project->license) ?
        endnew

        new c_include to java_module
            .include = "$(my.name:).h"
            .same_directory = "1"
        endnew

        new c_include to java_module
            .include = my.java_project.c_umbrella_header
            .same_directory = "1"
        endnew

        new c_include to java_module
            .include = "string.h"
        endnew
    endnew

endfunction


# ---------------------------------------------------------------------------
#   Create entity <c_method/> of from the instance entity <method/>.
# ---------------------------------------------------------------------------
function java_wrap_c_method_arguments (method, java_project, meta)
    # Wrap Java strings
    for my.method.argument where defined (0.type) & string_in (0.type, "char, string")
        my.init_strings ?= "// Wrap Java strings"

        my.init_strings += format_left("\
            const char *$(argument.name:c) = (*jenv)->GetStringUTFChars(jenv, j$(argument.name:Camel), NULL);
        ") + terminator
    endfor

    # Wrap Java interfaces
    for my.method.argument where defined (0.interface) & ! string_in (0.class, "data, buffer, error, str") & ! string_equal (0.class, "str buffer")
        my.init_interfaces ?= "// Wrap Java interfaces"
        my.class_path = my.java_project.package_dir
        #TODO get class name by ctx
        my.class_name = java_derive_class_name_str (argument.interface)
        my.class_type = java_derive_c_type (argument)

        my.init_interfaces += format_left("\
            jclass $(argument.name:c)_cls = (*jenv)->GetObjectClass(jenv, j$(argument.name:Camel));
            if (NULL == $(argument.name:c)_cls) {
                .(c_class_assert_macros_assert)(\"Class $(my.class_name:) not found.\");
            }
            jfieldID $(argument.name:c)_fidCtx = (*jenv)->GetFieldID(jenv, $(argument.name:c)_cls, \"cCtx\", \"J\");
            if (NULL == $(argument.name:c)_fidCtx) {
                .(c_class_assert_macros_assert)(\"Class '$(my.class_name:)' has no field 'cCtx'.\");
            }
            jlong $(argument.name:c)_c_ctx = (*jenv)->GetLongField(jenv, j$(argument.name:Camel), $(argument.name:c)_fidCtx);
            $(my.class_type:) $(argument.name:c) = *($(my.class_type:)*)&$(argument.name:c)_c_ctx;
        ") + terminator
    endfor

    # Wrap Java classes
    for my.method.argument where is_instance_of_generic_class(argument) & ! string_equal (0.class, "str") & ! string_equal (0.class, "str buffer")
        my.init_classes ?= "// Wrap Java classes"
        my.class_path = my.java_project.package_dir
        my.class_name = java_derive_class_name_str(argument.class ? argument.impl)
        my.class_type = java_derive_c_type (argument)

        my.init_classes += format_left("\
            jclass $(argument.name:c)_cls = (*jenv)->FindClass(jenv, \"$(my.class_path:)/$(my.class_name:)\");
            if (NULL == $(argument.name:c)_cls) {
                .(c_class_assert_macros_assert)(\"Class $(my.class_name:) not found.\");
            }
            jfieldID $(argument.name:c)_fidCtx = (*jenv)->GetFieldID(jenv, $(argument.name:c)_cls, \"cCtx\", \"J\");
            if (NULL == $(argument.name:c)_fidCtx) {
                .(c_class_assert_macros_assert)(\"Class '$(my.class_name:)' has no field 'cCtx'.\");
            }
            jlong $(argument.name:c)_c_ctx = (*jenv)->GetLongField(jenv, j$(argument.name:Camel), $(argument.name:c)_fidCtx);
            $(my.class_type:) $(argument.name:c) = *($(my.class_type:)*) &$(argument.name:c)_c_ctx;
        ") + terminator
    endfor

    my.init_objects = my.init_strings? ""
    my.init_objects += my.init_interfaces? ""
    my.init_objects += my.init_classes? ""
    return my.init_objects
endfunction

function java_create_c_class_method_call (class, method, java_class, java_method, c_method, java_project, meta)

    # Cast context
    if ! string_equal (my.class.context, "none") & ! is_true (my.method.is_static)
        my.init_context ?= terminator + "// Cast class context"
        my.ctx_type = java_derive_c_type (my.class)
        my.ctx_name = java_derive_c_context_variable_name (my.class)
        my.init_context += format_left("\
            $(my.ctx_type:)* $(my.ctx_name:) = *($(my.ctx_type:)**) &c_ctx;
        ") + terminator
    endif

    # Wrap arrays
    for my.method.argument where count (0.array)
        my.wrap_array ?= terminator + "// Wrap arrays"
        my.arr_jni_name = "j$(java_derive_c_instance_name (argument))"
        my.arr_name = java_derive_c_instance_name (argument)
        my.arr_type = java_derive_c_type (argument)

        my.wrap_array += format_left("\
            $(my.arr_type:) $(my.arr_name:) = ($(my.arr_type:)) (*jenv)->GetByteArrayElements(jenv, $(my.arr_jni_name:), NULL);
        ") + terminator

        my.free_resources ?= terminator + "// Free resources"
        my.free_resources += format_left("\
            //TODO: Fix $(my.arr_name:) memory leak
            //(*jenv)->ReleaseByteArrayElements(jenv, $(my.arr_jni_name:), $(my.arr_name:), 0);
        ") + terminator
    endfor

    # Wrap enums
    for my.method.argument where defined (0.enum)
        my.wrap_enum ?= terminator + "// Wrap enums"
        my.enum_name = java_derive_c_instance_name (argument)
        my.enum_jni_name = "j$(argument.name:Camel)"
        my.enum_type = java_derive_c_type (argument)
        my.wrap_enum += format_left("\
            jclass $(my.enum_name:)_cls = (*jenv)->GetObjectClass(jenv, $(my.enum_jni_name:));
            jmethodID $(my.enum_name:)_methodID = (*jenv)->GetMethodID(jenv, $(my.enum_name:)_cls, \"getCode\", \"()I\");
            $(my.enum_type:) $(my.enum_name:) = ($(my.enum_type:)) (*jenv)->CallIntMethod(jenv, $(my.enum_jni_name:), $(my.enum_name:)_methodID);
        ") + terminator
    endfor

    # Wrap input data.
    my.struct_data = ".(c_project_common_class_data_struct_data)"
    my.method_data_init = ".(c_project_common_class_data_method_data)"

    for my.method.argument where defined (0.class) & 0.class = "data"
        my.init_data ?= terminator + "// Wrap input data"
        my.data_name = java_derive_c_instance_name (argument)
        my.data_jni_name = "j$(argument.name:Camel)"
        my.init_data += format_left("\
            byte* $(my.data_name:)_arr = (byte*) (*jenv)->GetByteArrayElements(jenv, $(my.data_jni_name:), NULL);
            $(my.struct_data:) $(my.data_name:) = $(my.method_data_init:)($(my.data_name:)_arr, (*jenv)->GetArrayLength(jenv, $(my.data_jni_name:)));
        ") + terminator
        my.free_resources ?= terminator + "// Free resources"
        my.free_resources += format_left("\
            (*jenv)->ReleaseByteArrayElements(jenv, $(my.data_jni_name:), (jbyte*) $(my.data_name:)_arr, 0);
        ") + terminator
    endfor

    # Wrap strings
    for my.method.argument where defined (0.class) & (string_equal (0.class, "str") |  string_equal (0.class, "str buffer"))
        my.init_data ?= ""
        my.init_data += terminator + "// Wrap strings"
        my.free_resources ?= terminator + "// Free resources"

        my.str_name = java_derive_c_instance_name (argument)
        my.str_jni_name = "j$(argument.name:Camel)"

        if argument.class = "str"
            # Input argument
            my.struct_str = "$(make_ref_c (make_id ("project", "common", "class", "str", "struct", "str")))"
            my.method_str_from_str = "$(make_ref_c (make_id ("project", "common", "class", "str", "method", "from str")))"
            my.init_data += format_left("\
                const char *$(my.str_name:)_chr = (*jenv)->GetStringUTFChars(jenv, $(my.str_jni_name:), NULL);
                $(my.struct_str:) $(my.str_name:) = $(my.method_str_from_str:)($(my.str_name:)_chr);
            ") + terminator

            my.free_resources += format_left("\
                (*jenv)->ReleaseStringUTFChars(jenv, $(my.str_jni_name:), (jbyte*) $(my.str_name:)_chr);
            ") + terminator
        else
            # Output argument
            my.struct_str_buffer = "$(make_ref_c (make_id ("project", "common", "class", "str buffer", "struct", "str buffer")))"
            my.method_str_buffer_init = "$(make_ref_c (make_id ("project", "common", "class", "str buffer", "method", "new with capacity")))"
            my.method_str_buffer_delete = "$(make_ref_c (make_id ("project", "common", "class", "str buffer", "method", "delete")))"
            my.length_getter = java_derive_buffer_length_getter (my.class, my.method, argument, my.java_project)

            my.init_data += format_left("\
                $(my.struct_str_buffer:) *$(my.str_name:) = $(my.method_str_buffer_init:)($(my.length_getter:));
            ") + terminator
            
            my.free_resources += format_left("\
                $(my.method_str_buffer_delete:)($(my.str_name:));
            ") + terminator
        endif
    endfor

    # Wrap input buffers
    my.struct_buffer = ".(c_project_common_class_buffer_struct_buffer)"
    my.method_buffer_len = ".(c_project_common_class_buffer_method_len)"
    my.method_buffer_bytes = ".(c_project_common_class_buffer_method_bytes)"

    for my.method.argument where defined (0.class) & 0.class = "buffer"
        my.init_data ?= terminator + "// Wrap input buffers"
        my.buffer_name = java_derive_c_instance_name (argument)

        if string_in (argument.access, "readonly, retain, readwrite, disown")
            my.buffer_jni_name = "j$(argument.name:Camel)"
            my.data_name = "$(my.buffer_name:)_data"
            my.method_buffer_init = ".(c_project_common_class_buffer_method_new_with_data)"

            my.init_data += format_left("\
                byte* $(my.data_name:)_arr = (byte*) (*jenv)->GetByteArrayElements(jenv, $(my.buffer_jni_name:), NULL);
                $(my.struct_data:) $(my.data_name:) = $(my.method_data_init:)($(my.data_name:)_arr, (*jenv)->GetArrayLength(jenv, $(my.buffer_jni_name:)));
                $(my.struct_buffer:) *$(my.buffer_name:) = $(my.method_buffer_init:)($(my.data_name:));
            ") + terminator
        else
            my.method_buffer_init = ".(c_project_common_class_buffer_method_new_with_capacity)"
            my.length_getter = java_derive_buffer_length_getter (my.class, my.method, argument, my.java_project)

            my.init_data += format_left("\
                $(my.struct_buffer:) *$(my.buffer_name:) = $(my.method_buffer_init:)($(my.length_getter:));
            ") + terminator
        endif

        my.free_resources ?= terminator + "// Free resources"
        if !string_in (argument.access, "disown")
            my.free_resources += format_left("\
                .(c_project_common_class_buffer_method_delete)($(my.buffer_name:));
            ") + terminator
        endif
    endfor

    # Wrap errors
    if count (my.java_method.java_return) > 0
        if is_true (my.java_method->java_return.is_primitive_type)
            my.throw_return = "return 0"
        else
            my.throw_return = "return NULL"
        endif
    else
        my.throw_return = "return"
    endif

    my.exception = java_derive_default_exception_name (my.java_project)
    my.error_method_reset = make_ref_c (make_id ("class error method reset"))
    my.success_constant = \
                make_ref_c (make_id ("class status", "enum status", "constant success"))
    for my.method.argument where java_is_error (argument)
        my.errors_instantiation ?= terminator + "// Wrap errors"

        my.error_type = java_derive_c_type (argument)
        my.errors_instantiation += format_left ("\
            struct $(my.error_type:) $(argument.name:);
            $(my.error_method_reset:)(&$(argument.name:));
        ")

        my.errors_handling ?= terminator
        my.errors_handling += format_left("\
            if ($(argument.name:).status != $(my.success_constant:)) {
                throw$(my.exception:)(jenv, jobj, $(argument.name:).status);
                $(my.throw_return:);
            }
        ")
    endfor

    my.init_objects = java_wrap_c_method_arguments (my.method, my.java_project, my.meta)?

    # Make call
    my.proxy_args = java_format_c_args (my.class, my.method)
    my.proxy_call = "$(java_class_derive_c_method (my.class, my.method))($(my.proxy_args:))"

    # Handle an error
    for my.method.return where string_in (return.enum, "error, status")
        my.throws = "1"
    endfor

    # Create shallow copies for objects that is passed as "disown" argument.
    for my.method.argument where argument.access = "disown" & !string_in (argument.class, "data, buffer")
        my.method_shallow_copy = java_derive_c_method_shallow_copy (argument)
        my.class_type = java_derive_c_type (argument)

        my.shallow_copies ?= terminator + "//Shallow copy"
        my.shallow_copies += format_left("\
            $(my.class_type:) $(argument.name:c)_copy = $(my.method_shallow_copy:)($(argument.name:c));
        ", my.scope_count)
    endfor

    my.operation_call = "// Make call"
    if defined (my.throws)
        my.error_type = make_ref_c (make_id ("class", "status", "enum", "status"))
        my.exception = java_derive_default_exception_name (my.java_project)

        my.operation_call = format_left("\
            $(my.error_type:) status = $(my.proxy_call:);
            if (status != $(my.success_constant:)) {
                throw$(my.exception:)(jenv, jobj, status);
                $(my.throw_return:);
            }
        ")
    else
        my.proxy_return_type = java_derive_c_return_type (my.method)
        if my.proxy_return_type <> "void"
            my.proxy_result = "const $(my.proxy_return_type:) proxyResult = "
        elsif item_in (my.method, "constructor")
            my.proxy_result = "jlong proxyResult = (jlong) "
        else
            my.proxy_result = ""
        endif
        my.operation_call = format_left("\
            $(my.proxy_result:)$(my.proxy_call:);
        ")
    endif

    # Build return
    if count (my.java_method.java_return) > 0
        my.java_return_class_path = my.java_project.package_dir
        my.java_return_class_name = my.java_method->java_return.type

        if count (my.c_method.c_return) > 1
            # Instantiate Java object
            my.prepare_result = format_left("\
                jclass cls = (*jenv)->FindClass(jenv, \"$(my.java_return_class_path:)/$(my.java_return_class_name:)\");
                if (NULL == cls) {
                    .(c_class_assert_macros_assert)(\"Class $(my.java_return_class_name:) not found.\");
                }
                jmethodID methodID = (*jenv)->GetMethodID(jenv, cls, \"<init>\", \"()V\");
                jobject newObj = (*jenv)->NewObject(jenv, cls, methodID);
            ")
            # Fill object fields
            for my.method.argument
                if string_in (argument.class, "buffer") & string_in (argument.access, "readwrite, writeonly")
                    my.result_buffer_name = java_derive_c_instance_name (argument)
                    my.field_id = "fid$(argument.name:Pascal)"
                    my.field_arr = "j$(argument.name:Pascal)Arr"
                    my.java_field_name = "$(argument.name:Camel)"

                    my.prepare_result += format_left("\
                        jfieldID $(my.field_id:) = (*jenv)->GetFieldID(jenv, cls, \"$(my.java_field_name:)\", \"[B\");
                        jbyteArray $(my.field_arr:) = (*jenv)->NewByteArray(jenv, $(my.method_buffer_len:)($(my.result_buffer_name:)));
                        (*jenv)->SetByteArrayRegion (jenv, $(my.field_arr:), 0, $(my.method_buffer_len:)($(my.result_buffer_name:)), (jbyte*) $(my.method_buffer_bytes:)($(my.result_buffer_name:)));
                        (*jenv)->SetObjectField(jenv, newObj, $(my.field_id:), $(my.field_arr:));
                    ")
                endif
            endfor

            my.return_result = format_left("\
                return newObj;
            ")
        else
            my.c_return_type = c_method->c_return.type

            if string_in (my.c_return_type, "jbyte, jint, jlong, jboolean")
                # Just return the value
                my.operation_call = format_left("\
                    $(my.c_return_type:) ret = ($(my.c_return_type:)) $(my.proxy_call:);
                ")
            elsif string_in (my.c_return_type, "jbyteArray")
                # Create and fill a byte array
                if defined (my.method->return) & string_equal (my.method->return.class, "buffer")
                    my.result_buffer_name = "proxyResult"
                else
                    for my.method.argument
                        if string_in (argument.class, "buffer") & string_in (argument.access, "readwrite, writeonly")
                            my.result_buffer_name = java_derive_c_instance_name (argument)
                        endif
                    endfor
                endif

                if defined (my.result_buffer_name)
                    # Buffer
                    my.prepare_result = format_left("\
                        jbyteArray ret = (*jenv)->NewByteArray(jenv, .(c_project_common_class_buffer_method_len)($(my.result_buffer_name:)));
                        (*jenv)->SetByteArrayRegion (jenv, ret, 0, .(c_project_common_class_buffer_method_len)($(my.result_buffer_name:)), (jbyte*) .(c_project_common_class_buffer_method_bytes)($(my.result_buffer_name:)));
                    ")
                else
                    # Data
                    my.prepare_result = format_left("\
                        jbyteArray ret = NULL;
                        if (proxyResult.len > 0) {
                            ret = (*jenv)->NewByteArray(jenv, proxyResult.len);
                            (*jenv)->SetByteArrayRegion (jenv, ret, 0, proxyResult.len, (jbyte*) proxyResult.bytes);
                        }
                    ")
                endif
            elsif string_in (my.c_return_type, "jstring")
                # Create and fill a char array
                if defined (my.method->return) & string_equal (my.method->return.class, "str buffer")
                    my.result_str_name = "proxyResult"
                else
                    for my.method.argument
                        if string_equal (argument.class, "str buffer")
                            my.result_str_name = java_derive_c_instance_name (argument)
                        endif
                    endfor
                endif

                if defined (my.result_str_name)
                    # Buffer
                    my.method_str_buffer_chars = "$(make_ref_c (make_id ("project", "common", "class", "str buffer", "method", "chars")))"
                    my.prepare_result = format_left("\
                        jstring ret = (*jenv)->NewStringUTF(jenv, $(my.method_str_buffer_chars:)($(my.result_str_name:)));
                    ")
                endif
            elsif string_in (my.c_return_type, "jobject")

                if defined (my.method->return) & string_in (my.method->return.access, "readwrite, readonly")
                    my.proxy_shallow_copy_call = "$(java_derive_c_method_shallow_copy (my.method->return))(($(my.proxy_return_type:)) proxyResult);"
                endif

                if is_true (my.java_method->java_return.is_class)
                    my.class_full_name = "$(my.java_return_class_path:)/$(my.java_return_class_name:)"
                    my.prepare_result = format_left("\
                        jclass result_cls = (*jenv)->FindClass(jenv, \"$(my.class_full_name:)\");
                        if (NULL == result_cls) {
                            .(c_class_assert_macros_assert)(\"Class $(my.java_return_class_name:) not found.\");
                        }
                        jmethodID result_methodID = (*jenv)->GetStaticMethodID(jenv, result_cls, \"getInstance\", \"(J)L$(my.class_full_name:);\");
                        if (NULL == result_methodID) {
                            .(c_class_assert_macros_assert)(\"Class $(my.java_return_class_name:) has no 'getInstance' method.\");
                        }
                        $(my.proxy_shallow_copy_call?:)
                        jobject ret = (*jenv)->CallStaticObjectMethod(jenv, result_cls, result_methodID, (jlong) proxyResult);
                    ")
                elsif is_true (my.java_method->java_return.is_interface)
                    my.prepare_result = format_left("\
                        $(my.proxy_shallow_copy_call?:)
                        jobject ret = wrap$(my.java_return_class_name:)(jenv, jobj, proxyResult);
                    ")
                elsif is_true (my.java_method->java_return.is_enum)
                    my.prepare_result = format_left("\
                        jclass cls = (*jenv)->FindClass(jenv, \"$(my.java_return_class_path:)/$(my.java_return_class_name:)\");
                        if (NULL == cls) {
                            .(c_class_assert_macros_assert)(\"Enum $(my.java_return_class_name:) not found.\");
                        }

                        jmethodID methodID = (*jenv)->GetStaticMethodID(jenv, cls, \"fromCode\", \"(I)L$(my.java_return_class_path:)/$(my.java_return_class_name:);\");
                        if (NULL == methodID) {
                            .(c_class_assert_macros_assert)(\"Enum $(my.java_return_class_name:) has no method 'fromCode'.\");
                        }
                        jobject ret = (*jenv)->CallStaticObjectMethod(jenv, cls, methodID, proxyResult);
                    ")
                else
                    my.prepare_result = format_left("\
                        // TDB: Unknown type
                    ")
                endif
            endif

            my.return_result = format_left("\
                return ret;
            ")
        endif
    elsif item_in (my.method, "constructor")
        my.return_result = format_left("\
            return proxyResult;
        ")
    endif

    my.c_code = "$(my.errors_instantiation?:)"
    my.c_code += "$(my.init_context?:)"
    my.c_code += "$(my.wrap_array?:)"
    my.c_code += "$(my.wrap_enum?:)"
    my.c_code += "$(my.init_objects?:)"
    my.c_code += "$(my.init_data?:)"
    my.c_code += "$(my.shallow_copies?:)"
    my.c_code += "$(my.operation_call?:)"
    my.c_code += "$(my.errors_handling?:)"
    my.c_code += "$(my.prepare_result?:)"
    my.c_code += "$(my.free_resources?:)"
    my.c_code += "$(my.return_result?:)"

    return my.c_code
endfunction

# ---------------------------------------------------------------------------
#   Create entity <c_return/> from the entity <return/>if it is not
#   an error, otherwise nothing is created.
# ---------------------------------------------------------------------------
function java_create_c_return (return, destination, java_project, meta)
    check_arguments (my, "return, destination, java_project, meta", my)

    new c_return to my.destination
        java_map_attr_access (c_return, my.return)
        java_map_c_instance_type (c_return, my.return)

        return c_return
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create entity <c_return/> from the entity <argument/>.
# ---------------------------------------------------------------------------
function java_create_c_return_from_argument (class, method, argument, destination, java_project, meta)
    check_arguments (my, "class, method, argument, destination, java_project, meta", my)

    assert_attributes (my.argument, "name", my)

    new c_return to my.destination
        .name = java_derive_instance_name (my.argument)
        java_map_attr_access (c_return, my.argument)
        java_map_c_instance_type (c_return, my.argument)
        c_return.was_argument = "1"

        #if string_equal (my.argument.class, "buffer")
        #    c_return.length_getter = java_derive_buffer_length_getter (my.class, my.method, argument, my.java_project)
        #endif

        return c_return
    endnew
endfunction

function java_create_c_exception_throw_method (enum, java_project, meta)
    check_arguments (my, "enum, java_project, meta", my)

    my.c_module = java_obtain_c_module (my.java_project)

    my.exception_path = my.java_project.package_dir
    my.exception_name = java_derive_exception_name (my.enum, my.java_project)
    my.exception = "$(my.exception_path:)/$(my.exception_name:)"

    new c_method to my.c_module
        .name = "throw$(my.exception_name:)"
        .is_jni = "0"

        # C context
        new c_argument to c_method
            .type = "jint"
            .name = "statusCode"
        endnew

        new c_return to c_method
            .type = "jint"
        endnew

        new c_code to c_method
            . = "\
                jclass cls = (*jenv)->FindClass(jenv, \"$(my.exception:)\");
                if (NULL == cls) {
                    .(c_class_assert_macros_assert)(\"Class PheException not found.\");
                    return 0;
                }

                jmethodID methodID = (*jenv)->GetMethodID(jenv, cls, \"<init>\", \"(I)V\");
                if (NULL == methodID) {
                    .(c_class_assert_macros_assert)(\"Class $(my.exception:) has no constructor.\");
                    return 0;
                }
                jthrowable obj = (*jenv)->NewObject(jenv, cls, methodID, statusCode);
                if (NULL == obj) {
                    .(c_class_assert_macros_assert)(\"Can't instantiate $(my.exception:).\");
                    return 0;
                }
                return (*jenv)->Throw(jenv, obj);
            "
        endnew
    endnew

    echo_debug ("Done", my)
endfunction

# ---------------------------------------------------------------------------
#   Create entity <c_method/> of from the class entity <method/>.
# ---------------------------------------------------------------------------
function java_create_c_class_method (class, method, java_class, java_method, java_project, meta)
    check_arguments (my, "class, method, java_class, java_method, java_project, meta", my)

    echo_debug ("Create C method '$(my.method.name:)' for class '$(my.class.name:)'", my)

    my.h_module = java_obtain_h_module (my.java_project)
    my.c_module = java_obtain_c_module (my.java_project)

    my.c_method_name = java_derive_c_method_name (my.method, my.class, my.java_project)

    new c_method to my.h_module
        .name = my.c_method_name
        .declaration = "1"
        .is_jni = "1"

        if (! string_in (my.class.context, "none")) & is_false (my.method.is_static)
            java_create_c_context_argument (c_method, my.java_project, my.meta)
        endif

        for my.method.argument
            if argument.access <> "writeonly"
                java_create_c_argument (argument, c_method, my.java_project, my.meta)
            endif

            if (string_in (argument.class, "buffer") & string_in (argument.access, "readwrite, writeonly")) \
                | string_equal (argument.class, "str buffer")

                java_create_h_return_from_argument (my.class, my.method, argument, c_method, my.java_project, my.meta)
            endif
        endfor

        for my.method.return where ! string_equal (return.enum, "status")
            java_create_c_return (return, c_method, my.java_project, my.meta)
        endfor

        java_remove_c_error_arguments (c_method)
    endnew

    new c_method to my.c_module
        .name = my.c_method_name
        .declaration = "1"
        .is_jni = "1"

        if (! string_in (my.class.context, "none")) & is_false (my.method.is_static)
            java_create_c_context_argument (c_method, my.java_project, my.meta)
        endif

        for my.method.argument
            if argument.access <> "writeonly"
                java_create_c_argument (argument, c_method, my.java_project, my.meta)
            endif

            if (string_in (argument.class, "buffer") & string_in (argument.access, "readwrite, writeonly")) \
                | string_equal (argument.class, "str buffer")

                java_create_c_return_from_argument (my.class, my.method, argument, c_method, my.java_project, my.meta)
            endif
        endfor

        for my.method.return where ! string_equal (return.enum, "status")
            java_create_c_return (return, c_method, my.java_project, my.meta)
        endfor

        new c_code to c_method
            . = java_create_c_class_method_call (my.class, my.method, my.java_class, my.java_method, c_method, my.java_project, my.meta)
        endnew

        java_remove_c_error_arguments (c_method)
    endnew

endfunction

# ---------------------------------------------------------------------------
#   Map <instance/> attributes to the <c_instance type=""/> attributes.
# ---------------------------------------------------------------------------
function java_map_c_instance_type (c_instance, instance)
    check_arguments (my, "c_instance, instance", my)

    my.c_instance.type = java_derive_c_instance_type (my.instance)

    if defined (my.instance.type)
        my.c_instance.is_primitive_type = "1"

    elsif defined (my.instance.class)
        my.c_instance.is_class = "1"

        if my.instance.class = "any"
            my.c_instance.is_any = "1"

        elsif my.instance.class = "data"
            my.c_instance.is_data = "1"

        elsif my.instance.class = "buffer"
            my.c_instance.is_buffer = "1"

        elsif my.instance.class = "str buffer"
            my.c_instance.is_buffer = "1"

        elsif my.instance.class = "error"
            my.c_instance.is_error = "1"
            my.c_instance.method_reset = make_ref_c (make_id ("class error method reset"))
        endif

    elsif defined (my.instance.interface)
        my.c_instance.is_interface = "1"

    elsif defined (my.instance.enum)
        my.c_instance.is_enum = "1"

    elsif defined (my.instance.impl)
        my.c_instance.is_class = "1"
    endif

    my.c_instance.is_array = count (my.instance.array) ?? "1" ?
    my.c_instance.is_reference = my.instance.is_reference ?
endfunction

function java_create_c_class_close (class, java_project, meta)
    check_arguments (my, "class, java_project, meta", my)

    echo_debug ("Create C method 'close' for class '$(my.class.name:Camel)'", my)

    my.h_module = java_obtain_h_module (my.java_project)
    my.c_module = java_obtain_c_module (my.java_project)

    my.c_method_name = java_derive_c_method_name_str ("close", my.class, my.java_project)

    if ! defined (my.h_module->c_method(c_method.name = my.c_method_name)?)
        # Define destructor method header
        new c_method to my.h_module
            .name = my.c_method_name
            .declaration = "1"
            .is_jni = "1"

            new c_argument to c_method
                .type = "jlong"
            endnew
        endnew

        # Define destuctor method implementation
        my.ctx_type = java_derive_c_type (my.class)
        if string_in (my.class.context, "public") & string_in (my.class.lifecycle, "none")
            my.dtor_invocation = ".(c_global_method_dealloc)(*($(my.ctx_type:) **) &c_ctx /*4*/)"
        else
            my.dtor_invocation = "$(class_derive_c_destructor (my.class))(*($(my.ctx_type:) **) &c_ctx /*5*/)"
        endif

        new c_method to my.c_module
            .name = my.c_method_name
            .declaration = "1"
            .is_jni = "1"

            new c_argument to c_method
                .name = "c_ctx"
                .type = "jlong"
            endnew

            new c_code to c_method
                . = "$(my.dtor_invocation:);"
            endnew
        endnew
    endif

endfunction

function java_create_c_proxy_method_from_constant (constant, interface, destination, java_project, meta)
    check_arguments (my, "constant, destination, java_project, meta", my)

    echo_debug ("Create C method for interface '$(my.interface.name:Pascal)' constant '$(my.constant.name:Pascal)", my)

    my.h_module = java_obtain_h_module(my.java_project)
    my.c_module = java_obtain_c_module(my.java_project)
    my.c_method_name = java_derive_c_method_name_str (java_derive_getter_name_by_constant (my.constant, my.java_project), my.interface, my.java_project)

    if ! defined (my.h_module->c_method(c_method.name = my.c_method_name)?)
        # Define destructor method header
        new c_method to my.h_module
            .name = my.c_method_name
            .declaration = "1"
            .is_jni = "1"

            new c_argument to c_method
                .type = "jlong"
            endnew
        endnew

        my.api_getter = interface_derive_c_api_method (my.interface)
        my.constant_getter = interface_derive_c_constant_method (my.interface, my.constant)

        new c_method to my.c_module
            .name = my.c_method_name
            .declaration = "1"
            .is_jni = "1"

            new c_argument to c_method
                .name = "c_ctx"
                .type = "jlong"
            endnew

            new c_code to c_method
                . = "\
                    return $(my.constant_getter:)($(my.api_getter:)(c_ctx))
                "
            endnew
        endnew
    endif
endfunction

# ---------------------------------------------------------------------------
#   Return method that wraps C implementation object to the
#   Java object.
# ---------------------------------------------------------------------------
function java_get_c_implementation_helper_interface_method (interface, java_project)
    check_arguments (my, "interface, java_project", my)

    my.c_module = java_obtain_c_module(my.java_project)

    my.interface_method_name = "wrap$(my.interface.name:Pascal)"
    my.class_name_getter = "get$(my.interface.name:Pascal)ClassName"

    my.wrap_interface_method = my.c_module->c_method (name = my.class_name_getter) ?

    if defined (my.wrap_interface_method)
        return my.wrap_interface_method
    endif

    my.interface_name = java_derive_interface_name (my.interface, my.java_project)
    my.ctx_type = "$(java_derive_c_type(my.interface):)*"

    new c_method to my.c_module

        . = "\
            /// Get Java class name by instance $(my.interface_name:).
        "
        .name = my.class_name_getter
        .modifier = "static"
        .is_jni = "0"

        new c_argument to c_method
            .name = "c_obj"
            .type = my.ctx_type
            .is_const = "1"
        endnew

        new c_return to c_method
            .type = "char*"
        endnew

        new c_code to c_method
            my.class_path = my.java_project.package_dir
            my.method_of_class = my.interface.of_class ? my.interface.name
            my.method_is_implemented = make_ref_c (make_id ("class", my.method_of_class, "method", "is_implemented"))
            .temp_code = format_left("\
                if (!$(my.method_is_implemented:)(c_obj)) {
                    .(c_class_assert_macros_assert)(\"Given C implementation does not implement interface $(my.interface_name:).\");
                }
                char *classFullName = malloc(200);
                strcpy (classFullName, \"$(my.class_path:)/\");
                .(c_class_impl_enum_tag) implTag = .(c_class_impl_method_tag)(c_obj);
                switch(implTag) {
            ")
        endnew

        my.return_method = c_method

    endnew

    new c_method to my.c_module
        . = "\
            /// Wrap C implementation object to the Java object that implements interface $(my.interface_name:).
        "
        .name = my.interface_method_name
        .modifier = "static"
        .is_jni = "0"

        new c_argument to c_method
            .name = "c_obj"
            .type = my.ctx_type
            .is_const = "1"
        endnew

        new c_return to c_method
            .type = "jobject"
        endnew

        new c_code to c_method
            . = format_left("\
                char *classFullName = $(my.class_name_getter:)(jenv, jobj, c_obj);
                jclass cls = (*jenv)->FindClass(jenv, classFullName);
                if (NULL == cls) {
                    free(classFullName);
                    .(c_class_assert_macros_assert)(\"Class not found.\");
                }

                char *methodSig = malloc(200);
                strcpy (methodSig, \"(J)L\");
                strcat (methodSig, classFullName);
                strcat (methodSig, \";\");
                jmethodID methodID = (*jenv)->GetStaticMethodID(jenv, cls, \"getInstance\", methodSig);
                free(classFullName);
                free (methodSig);
                if (NULL == methodID) {
                    .(c_class_assert_macros_assert)(\"Class has no 'getInstance' method.\");
                }

                jlong c_ctx = 0;
                *(const $(my.ctx_type:)*) &c_ctx = c_obj;
                return (*jenv)->CallStaticObjectMethod(jenv, cls, methodID, c_ctx);
            ")
        endnew

    endnew

    return my.return_method
endfunction

# ---------------------------------------------------------------------------
#   Add java_project "case" statement for implementation/interface pair.
# ---------------------------------------------------------------------------
function java_update_c_implementation_helper_module (implementation, java_project, meta)
    check_arguments (my, "implementation, java_project, meta", my)

    my.refs = meta_refs (my.meta)

    for my.implementation.interface

        my.wrap_interface_method = java_get_c_implementation_helper_interface_method (interface, my.java_project)

        my.wrap_interface_method->c_code.temp_code += format_left("\
            case $(my.refs.c_implementation_constant_tag):
                strcat (classFullName, \"$(java_derive_class_name (my.implementation, my.java_project))\");
                break;
        ")
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Add methods ending within implementation helper class.
# ---------------------------------------------------------------------------
function java_finalize_c_implementation_helper_modules (java_project, meta)
    check_arguments (my, "java_project, meta", my)

    my.c_module = java_obtain_c_module(my.java_project)

    for my.c_module.c_method where defined (c_method->c_code.temp_code)
        c_method->c_code.temp_code += format_left ("\
            default:
                free(classFullName);
                .(c_class_assert_macros_assert)(\"Unexpected C implementation cast to the Java implementation.\");
            }
            return classFullName;
        ")

        c_method->c_code. = c_method->c_code.temp_code
        c_method->c_code.temp_code = # undefined
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Add <java_method/> with setter only that proxy dependency to the
#   C context.
# ---------------------------------------------------------------------------
function java_create_c_method_from_dependency (dependency, impl, destination, java_project, meta)
    check_arguments (my, "dependency, impl, destination, java_project, meta", my)

    my.h_module = java_obtain_h_module(my.java_project)
    my.c_module = java_obtain_c_module(my.java_project)

    my.c_method_name = java_derive_c_method_name_str (java_derive_method_name_str (cat ("set", my.dependency.name)), my.impl, my.java_project)
    my.arg_name = "j$(java_derive_argument_name (my.dependency):)"
    my.arg_ctx_type = java_derive_c_type (my.impl)

    if ! defined (my.h_module->c_method(c_method.name = my.c_method_name)?)
        # Define destructor method header
        new c_method to my.h_module
            .name = my.c_method_name
            .declaration = "1"
            .is_jni = "1"

            new c_argument to c_method
                .type = "jlong"
            endnew
            new c_argument to c_method
                .type = java_derive_c_instance_type (my.dependency)
            endnew
        endnew

        new c_method to my.c_module
            .name = my.c_method_name
            .declaration = "1"
            .is_jni = "1"

            new c_argument to c_method
                .name = "c_ctx"
                .type = "jlong"
            endnew

            new c_argument to c_method
                .name = my.arg_name
                .type = java_derive_c_instance_type (my.dependency)
            endnew

            new c_code to c_method
                if my.dependency.has_observers & my.dependency.is_observers_return_status
                    my.status_type = make_ref_c (make_id ("class", "status", "enum", "status"))
                    my.success_constant = make_ref_c (make_id ("class status", "enum status", "constant success"))
                    my.exception = java_derive_default_exception_name (my.java_project)

                    my.result_var = "$(my.status_type:) status = "
                    my.impl_handle_status = format_left("\
                        if (status != $(my.success_constant:)) {
                            throw$(my.exception:)(jenv, jobj, status);
                        }
                        ")
                endif
                my.class_path = my.java_project.package_dir
                my.class_name = java_derive_dependency_type (my.dependency)
                my.class_type = java_derive_c_type (my.dependency)

                . = format_left("\
                    jclass $(my.dependency.name:c)_cls = (*jenv)->GetObjectClass(jenv, $(my.arg_name:));
                    if (NULL == $(my.dependency.name:c)_cls) {
                        .(c_class_assert_macros_assert)(\"Class $(my.class_name:) not found.\");
                    }
                    jfieldID $(my.dependency.name:c)_fidCtx = (*jenv)->GetFieldID(jenv, $(my.dependency.name:c)_cls, \"cCtx\", \"J\");
                    if (NULL == $(my.dependency.name:c)_fidCtx) {
                        .(c_class_assert_macros_assert)(\"Class '$(my.class_name:)' has no field 'cCtx'.\");
                    }
                    jlong $(my.dependency.name:c)_c_ctx = (*jenv)->GetLongField(jenv, j$(my.dependency.name:Camel), $(my.dependency.name:c)_fidCtx);
                    $(my.class_type:) $(my.dependency.name:c) = *($(my.class_type:)*) &$(my.dependency.name:c)_c_ctx;

                    $(class_derive_c_method_release_dependency (my.impl, my.dependency))(($(my.arg_ctx_type:) *) c_ctx);
                    $(my.result_var?:)$(class_derive_c_method_use_dependency (my.impl, my.dependency))(($(my.arg_ctx_type:) *) c_ctx,\
                        $(my.dependency.name:c));
                ")
                . += my.impl_handle_status ? ""
            endnew
        endnew
    endif
endfunction

.endtemplate
