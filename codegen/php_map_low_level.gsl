.template 0
#   Copyright (C) 2015-2019 Virgil Security, Inc.
#
#   All rights reserved.
#
#   Redistribution and use in source and binary forms, with or without
#   modification, are permitted provided that the following conditions are
#   met:
#
#       (1) Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#
#       (2) Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in
#       the documentation and/or other materials provided with the
#       distribution.
#
#       (3) Neither the name of the copyright holder nor the names of its
#       contributors may be used to endorse or promote products derived from
#       this software without specific prior written permission.
#
#   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR
#   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#   DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
#   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
#   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
#   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
#   STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
#   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#   POSSIBILITY OF SUCH DAMAGE.
#
#   Lead Maintainer: Virgil Security Inc. <support@virgilsecurity.com>

# ---------------------------------------------------------------------------
#   Functions for PHP primitives generation: protocol, class, enum, etc.
# ---------------------------------------------------------------------------
#   This is a code generator built using the iMatix GSL code generation
#   language. See https://github.com/imatix/gsl for details.
# ---------------------------------------------------------------------------

gsl from "common.gsl"

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_map_low_level (in_module, in_php_project, out_low_level, in_type)
    check_arguments (my, "in_module, in_php_project, out_low_level, in_type", my)

    my.out_low_level.name = "$(my.in_module.name:c)"
    my.out_low_level.name0 = "$(my.in_module.name:c)"
    my._wot = "$(my.in_php_project.prefix:)_$(my.out_low_level.name0:)"
    my._t = "$(my._wot:)_t"
    my.out_low_level.constant = "$(my._t:)_php_res_name[]"
    my._constant = ""

    if my.in_type <> "single_function"

        new include to my.out_low_level
            . = format_left("#include \"$(my.in_php_project.prefix:)_$(my.out_low_level.name0:).h\"", 0)
        endnew

        new registered_resource to my.out_low_level
            . = format_left("int le_$(my.in_php_project.prefix:)_$(my.out_low_level.name0:)_t;", 0)
        endnew

        new header_registered_resource to my.out_low_level
            . = format_left("extern int le_$(my.in_php_project.prefix:)_$(my.out_low_level.name0:)_t;", 0)
        endnew

        new constant to my.out_low_level
            . = format_left("const char $(my.out_low_level.constant:) = \"$(my._t:)\";", 0)
        endnew

        new header_constant to my.out_low_level
            . = format_left("extern const char $(my.out_low_level.constant:);", 0)
        endnew

        new init_func_def_dtor to my.out_low_level
            . = format_left("\
                static void $(my._wot:)_dtor_php(zend_resource *rsrc) {
                    $(my._wot:)_delete(($(my._t:) *)rsrc->ptr);
                }
                ", 0)
        endnew

        new init_func_def_list_destr to my.out_low_level
            . = format_left("\
                le_$(my._t:) = zend_register_list_destructors_ex($(my._wot:)_dtor_php, NULL, $(my._t:)_php_res_name, module_number);
                ", 0)
        endnew

        if my.in_type <> "interface"
            php_map_low_level_constructor_destructor (my.in_module, my.out_low_level, my.in_type)
        endif

        for my.in_module.dependency as dependency0

            my._dep_name = dependency0.name

            new method to my.in_module
                .name = "use $(my._dep_name:)"
                .visibility = "public"
                .scope = "public"
                .declaration = "public"
                .is_static = 0
                .return_type = "void"
                .is_const = 0
                .c_prefix = my.in_php_project.prefix

                my.argument = item_copy_to(dependency0, method, "argument")
                my.argument.access ?= "readwrite"
                my.argument._c_type = class_derive_c_instance_type(my.argument)
                my.argument.is_dependency = 1

                if dependency0.is_observers_return_status = 1
                    new return to method
                        .enum = "status"
                        .is_reference = 0
                    endnew
                endif
            endnew
        endfor
    else
        new method to my.in_module
            .name = "impl tag"
            .visibility = "public"
            .scope = "public"
            .declaration = "public"
            .is_static = 1
            .return_type = "int"
            .is_const = 0
            .c_prefix = my.in_php_project.prefix

            new argument to method
                .name = "ctx"
                .interface = "ctx"
                .access = "readonly"
                .is_reference = 1
            endnew

            new return to method
                .enum = "tag"
                .access = "readonly"
                .is_reference = 0
            endnew
        endnew
    endif

    for my.in_module.method as method0 where wrapper_should_wrap_method(method0) & method0.name <> "get ctx"
        new function to my.out_low_level

            .is_static = method0.is_static

            .prefix0 = "$(my.in_module.c_prefix:c)"
            .entity0 = "$(my.in_module.name:c)"

            if my.in_type = "interface"
                .name0 = ""
                .name = ""
            elsif my.in_type = "single_function"
                .name0 = "$(0.prefix0:)_$(method0.name:c)"
                .name = "$(0.name0:)_php"
            else 
                .name0 = php_derive_low_level_function_name(0, method0)
                .name = "$(0.name0:)_php"
            endif

            .num_arguments = 0

            my._method_arguments = ""
            my._function_arguments = ""

            new def_func_entry to function
                . = format_left("PHP_FE($(function.name:), arginfo_$(function.name:))", 0)
            endnew

            php_map_low_level_return (method0, my.in_php_project, function)

            for method0.argument as argument0

                my._d = ""
                if ! last()
                    my._d = ", "
                endif

                my._declare_input_arguments = ""

                new argument to function
                    php_map_low_level_argument (argument0, my.in_php_project, argument, function)
                endnew
            endfor

            new wrapper to function

                ### Arg info --->

                new arg_info to wrapper

                    my._num_arguments = 1 # ctx
                    my._zend_arg_type_info = format_left("ZEND_ARG_TYPE_INFO(0, in_ctx, IS_RESOURCE, 0)", 0)

                    if function.is_static = 1
                        my._num_arguments = 0
                        my._zend_arg_type_info = ""
                    endif

                    for function.argument as argument0 where ! string_in (argument0.type0, "error, buffer")
                        my._num_arguments = my._num_arguments + 1
                        #ZEND_ARG_TYPE_INFO(pass_by_ref, name, type_hint, allow_null)
                        my._zend_arg_type_info += format_left("ZEND_ARG_TYPE_INFO(0, in_$(argument0.name:), $(argument0.zend_type:), 0)", 0)
                    endfor

                    my._r = format_left(my._zend_arg_type_info, 7)

                    my._c = php_format_extension_comment("Wrap method: $(function.name0:)")

                    my._h = format_left("\
                        ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(
                            arginfo_$(function.name0:)_php, 
                            0 /*return_reference*/,
                            $(my._num_arguments:) /*required_num_args*/,
                            $(function.return_zend_type:) /*type*/,
                            0 /*allow_null*/)

                            $(my._r:)
                        ZEND_END_ARG_INFO()
                    ", 0)

                    my._res = my._c + my._h
                    . = format_left(my._res, 0)
                endnew

                ### <--- Arg info

                #### Header --->

                new header to wrapper
                    . = format_left("PHP_FUNCTION($(function.name:)) {", 0)
                endnew

                ### <--- Header

                ### Declare input arguments --->

                new declare_input_arguments to wrapper
                    my._c = php_format_extension_comment("Declare input argument")

                    my._h1 = format_left("zval *in_ctx = NULL;")

                    if function.is_static = 1
                        my._h1 = ""
                    endif

                    for function.argument as argument0 where argument0.type <> "vsc_buffer_t"
                        if argument0.type0 <> "error"
                            if argument0.zend_type = "IS_STRING"
                                my._h1 += format_left("\
                                    char *in_$(argument0.name:) = NULL;
                                    size_t in_$(argument0.name:)_len = 0;
                                    ", 0)
                            elsif argument0.zend_type = "IS_LONG"
                                my._h1 += format_left("\
                                    zend_long in_$(argument0.name:) = 0;
                                    ", 0)
                            elsif argument0.zend_type = "IS_RESOURCE"
                                my._h1 += format_left("\
                                    zval *in_$(argument0.name:) = NULL;
                                    ", 0)
                            elsif argument0.zend_type = "_IS_BOOL"
                                my._h1 += format_left("\
                                    zend_bool in_$(argument0.name:);
                                    ", 0)
                            else
                                echo_debug_item(argument0)
                                echo_debug_item(function)
                                echo_fatal("Not implemented (AQ1000)")
                            endif
                        endif
                    endfor

                    my._res = my._c + my._h1

                    . = format_left(my._res, 1)
                endnew

                ### <--- Declare input arguments

                ### Parse arguments --->

                new parse_arguments to wrapper
                    my._c = php_format_extension_comment("Parse arguments")
                    my._h1 = format_left("ZEND_PARSE_PARAMETERS_START_EX(ZEND_PARSE_PARAMS_THROW, $(my._num_arguments:), $(my._num_arguments:))", 0)

                    my._h2 = ""
                    if function.is_static = 0
                        my._h2 = format_left("Z_PARAM_RESOURCE_EX(in_ctx, 1, 0)", 1)
                    endif

                    for function.argument as argument0 where ! string_in (argument0.type0, "buffer, error")
                            if argument0.zend_type = "IS_STRING"
                                my._h2 += format_left("Z_PARAM_STRING_EX(in_$(argument0.name:), in_$(argument0.name:)_len, 1 /*check_null*/, 0 /*separate*/)", 1)
                            elsif argument0.zend_type = "IS_LONG"
                                my._h2 += format_left("Z_PARAM_LONG(in_$(argument0.name:))", 1)
                            elsif argument0.zend_type = "IS_RESOURCE"
                                my._h2 += format_left("Z_PARAM_RESOURCE_EX(in_$(argument0.name:), 1 /*check_null*/, 0 /*separate*/)", 1)
                            elsif argument0.zend_type = "_IS_BOOL"
                                my._h2 += format_left("Z_PARAM_BOOL(in_$(argument0.name:))", 1)
                            else
                                echo_debug_item(argument0)
                                echo_fatal("Not implemented (AL1002)")
                            endif
                    endfor
                    my._h3 = format_left("ZEND_PARSE_PARAMETERS_END();", 0)
                    my._res = my._c + my._h1 + my._h2 + my._h3

                    . = format_left(my._res, 1)
                endnew

                ### <--- Parse arguments

                ### Proxy call --->

                new proxy_call to wrapper
                    my._c = php_format_extension_comment("Proxy call")

                    my._h1 = ""
                    if function.is_static = 0

                        my._res_name = "$(my._t:)_php_res_name"
                        my._le = "le_$(my._t:)"

                        if my.in_type = "implementation"
                            my._res_name = "$(my.in_php_project.prefix:)_impl_t_php_res_name"
                            my._le = "le_$(my.in_php_project.prefix:c)_impl_t"
                        endif

                        my._h1 = format_left("\
                            $(my._t:c) *$(my.out_low_level.name0:c) = zend_fetch_resource_ex(in_ctx, $(my._res_name:), $(my._le:));
                            ", 0)
                    endif

                    for function.argument as argument0 where ! string_in (argument0.type0, "buffer, integer, enum, byte, boolean, unsigned")
                        if argument0.type = "vsc_data_t"
                            my._h1 += format_left("vsc_data_t $(argument0.name:) = vsc_data((const byte*)in_$(argument0.name:), in_$(argument0.name:)_len);", 0)
                        elsif string_in (argument0.type0, "interface, class, impl")
                            if argument0.type = "class"
                                my._h1 += format_left("\
                                    $(argument0.type:c) *$(argument0.name:c) = zend_fetch_resource_ex(in_$(argument0.name:), $(argument0.type_c:)_php_res_name, le_$(argument0.type_c:));
                                    ", 0)
                            else
                                if defined(argument0.is_dependency) & argument0.is_dependency = 1
                                    my._a = argument0.type_c
                                    my._rn = "$(my._a:)"
                                    my._h1 += format_left("\
                                        $(my._a:) *$(argument0.name:c) = zend_fetch_resource_ex(in_$(argument0.name:), $(my._rn:)_php_res_name, le_$(my._a:));
                                        ", 0)
                                else
                                    my._a = function.prefix0
                                    my._h1 += format_left("\
                                        $(argument0.type:c) *$(argument0.name:c) = zend_fetch_resource_ex(in_$(argument0.name:), $(my._a:)_impl_t_php_res_name, le_$(my._a:)_impl_t);
                                        ", 0)
                                endif
                            endif
                        elsif argument0.type0 = "size"
                            my._h1 += format_left("
                                size_t $(argument0.name:) = in_$(argument0.name:);
                                ", 0)
                        elsif argument0.type0 = "error"
                            my._h1 += format_left("
                                $(function.prefix0:)_error_t error;
                                $(function.prefix0:)_error_reset(&error);
                                ", 0)
                        else
                            echo_debug_item(function)
                            echo_debug_item(argument0)
                            echo_fatal("Not implemented (AF1000)")
                        endif
                    endfor
                    my._res = my._c + my._h1

                    . = format_left(my._res, 1)
                endnew

                ### <--- Proxy call

                #### Allocate output buffer --->

                my._res = ""

                for function.return_argument as return_argument0

                        my._n = ""
                        if ! last()
                            my._n = "\n"
                        endif

                        if ! defined (return_argument0.type)
                            echo_debug_item(function)
                            echo_debug_item(return_argument0)
                            echo_fatal("Not implemented (AI1001)", my)
                        endif

                        if return_argument0.type = "buffer"
                            my._c = php_format_extension_comment("Allocate output buffer for output '$(return_argument0.name:)'")

                            if return_argument0.length_type = "constant"
                                my._l = "$(return_argument0.length:)"
                            elsif return_argument0.length_type = "method"
                                my._l = "$(return_argument0.length:)($(function.entity0:))"
                            elsif return_argument0.length_type = "method_proxy"
                                echo_debug_item()
                                my._l = "$(return_argument0.length:)($(function.entity0:), $(return_argument0.proxy:))"
                            elsif return_argument0.length_type = "argument"
                                my._l = "$(return_argument0.length:c)"
                            else 
                                echo_debug_item(function)
                                echo_debug_item(return_argument0)
                                echo_fatal("Not implemented (AP1001)")
                            endif

                            my._h1 = format_left("\
                                zend_string *out_$(return_argument0.name:) = zend_string_alloc($(my._l), 0);
                                vsc_buffer_t *$(return_argument0.name:) = vsc_buffer_new();
                                vsc_buffer_use($(return_argument0.name:), (byte *)ZSTR_VAL(out_$(return_argument0.name:)), ZSTR_LEN(out_$(return_argument0.name:)));
                                ", 0)
                            my._res += my._c + my._h1 + "\n" + my._n
                        endif
                endfor

                if my._res <> ""
                    new allocate_output_buffer to wrapper
                        . = format_left(my._res, 1)
                    endnew
                endif

                ### <--- Allocate output buffer

                ### Argument type mapping --->

                my._mapper = ""

                for function.argument as argument0
                    if argument0.type = "int"
                        if defined(argument0.byte_as_string) & argument0.byte_as_string = 1
                            my._mapper += format_left("byte *$(argument0.name:) = (byte *)in_$(argument0.name:);", 0)
                        else
                            my._mapper += format_left("$(argument0.type_c) $(argument0.name:) = in_$(argument0.name:);", 0)
                        endif
                    endif

                    if argument0.type0 = "enum"
                        my._mapper += format_left("$(argument0.type_c:) $(argument0.name:) = ($(argument0.type:))in_$(argument0.name:);", 0)
                    endif

                    if argument0.type0 = "boolean"
                        my._mapper += format_left("$(argument0.type_c:) $(argument0.name:) = ($(argument0.type_c:))in_$(argument0.name:);", 0)
                    endif

                    if argument0.access = "disown"
                        my._mapper += format_left("\
                            // Shallow copy (.access=\"disown\")
                            $(argument0.type_c:) *$(argument0.name:)_tmp = $(argument0.shallow_copy:)($(argument0.name:));
                            ", 0)
                    endif
                endfor

                if my._mapper <> ""
                    new argument_type_mapping to wrapper
                        my._c = php_format_extension_comment("Argument type mapping")
                        my._res = my._c + my._mapper
                        . = format_left(my._res, 1)
                    endnew
                endif

                ### <--- Argument type mapping

                ### Call main function --->

                new call_main_function to wrapper

                    my._c = php_format_extension_comment("Call main function")

                    my._data_string_proxy = 0

                    my._return = ""
                    my._args = "("

                    my._e = 0
                    my._r = ""

                    if function.is_static = 0
                        my._args += "$(function.entity0)"
                        my._e = 1
                    endif

                    my._access = ""
                    my._access_const = ""
                    my._access_shallow_copy = ""

                    my._rs = ""

                    for function.return_argument as return_argument0 where return_argument0.type <> "buffer"

                        if defined (return_argument0.class_name0) & (return_argument0.class_name0 = my.in_module.name)
                            my._rs = "_rs"
                        endif

                        if defined(return_argument0.access)
                            my._access = return_argument0.access
                        endif

                        if my._access = "readonly"
                            my._access_const = "($(return_argument0.type_t:) *)"
                        endif

                        if my._access = "readwrite" | my._access = "readonly"
                            my._access_const = "($(return_argument0.type_t:) *)"
                            my._access_shallow_copy = format_left("$(return_argument0.name:) = $(return_argument0.shallow_copy:)($(return_argument0.name:));", 0)
                        endif

                        my._pointer = ""
                        if defined(return_argument0.is_reference) & return_argument0.is_reference = 1
                            #echo_debug_item(return_argument0)
                            my._pointer = "*"
                        endif

                        if return_argument0.type = "vsc_data_t"
                            my._data_string_proxy = 1
                            my._data_string_proxy_call = format_left("\
                                zend_string *out_$(return_argument0.name:) = zend_string_init(out_$(return_argument0.name:)_temp.bytes, out_$(return_argument0.name:)_temp.len, 0);
                                ", 0)

                            my._out_name = "out_$(return_argument0.name:)"
                            my._return += format_left("\
                                $(return_argument0.type_t:) $(my._pointer:)out_$(return_argument0.name:)_temp = 
                                ", 0)
                        else 
                            my._return += format_left("\
                                $(return_argument0.type_t:) $(my._pointer:)$(return_argument0.name:)$(my._rs) = 
                                ", 0)
                        endif
                    endfor

                    my._return = format_left(my._return, 0)

                    for function.argument as argument0
                        my._dd = ""
                        if first() & my._e = 1
                            my._dd = ", "
                        endif

                        my._d = ""
                        if ! last()
                            my._d = ", "
                        endif

                        if argument0.name = "error"
                            my._args += my._dd + "&$(argument0.name:)" + my._d
                        else
                            if string_in (argument0.type0, "interface, class, impl") & argument0.access = "disown"
                                my._args += my._dd + "&$(argument0.name:)_tmp" + my._d
                            else
                                my._args += my._dd + "$(argument0.name:)" + my._d
                            endif
                        endif
                    endfor

                    my._args += ");"

                    my._func = "$(function.name0:)"

                    my._res = my._c + my._return + my._access_const + my._func + my._args

                    if my._data_string_proxy = 1
                        my._res = my._res + my._data_string_proxy_call
                    endif

                    if my._access_shallow_copy <> ""
                        my._res = my._res + my._access_shallow_copy
                    endif

                    . = format_left(my._res, 1)
                endnew

                ### <--- Call main function

                ### Handle error --->

                my._res = ""

                if function.throw_exception = 1
                    my._c = php_format_extension_comment("Handle error")

                    my._h1 = ""

                    if defined(function.check_error) & function.check_error = 1
                        my._h1 += format_left("$(function.prefix0:c)_status_t status = $(function.prefix0:c)_error_status(&error);", 0)
                    endif

                    my._h1 += format_left("$(function.prefix0:UPPER)_HANDLE_STATUS(status);", 0)

                    my._res = my._c + my._h1
                endif

                if my._res <> ""
                    new handle_error to wrapper
                        . = format_left(my._res, 1)
                    endnew
                endif

                ### <--- Handle error

                ### Correct string length to the actual --->

                my._res = ""
                
                for function.return_argument as return_argument0 where return_argument0.type = "buffer"
                    my._res += format_left("ZSTR_LEN(out_$(return_argument0.name:)) = vsc_buffer_len($(return_argument0.name:));",)
                endfor

                if my._res <> ""
                    my._c = php_format_extension_comment("Correct string length to the actual")
                    my._res = my._c + my._res

                    new correct_string_length to wrapper
                        . = format_left(my._res, 1)
                    endnew
                endif

                ### <--- Correct string length to the actual

                ### Return type mapping --->

                my._res = ""
            
                for function.return_argument as return_argument0 where return_argument0.type <> "buffer"
                    if return_argument0.type = "byte" & return_argument0.zend_type = "IS_LONG"
                        my._res += format_left("zend_long ret_res = (zend_long)res;", 0)
                    endif
                endfor

                if my._res <> ""
                    my._c = php_format_extension_comment("Return type mapping")
                    my._res = my._c + my._res

                    new return_type_mapping to wrapper
                        . = format_left(my._res, 1)
                    endnew
                endif

                ### <--- Return type mapping

                ### Write returned result --->

                my._res = ""
                my._ret= ""

                if function.return_zend_type = "IS_STRING"
                    for function.return_argument as return_argument0 where return_argument0.name <> "status" & return_argument0.type <> "enum"
                        my._ret += format_left("RETVAL_STR(out_$(return_argument0.name:));", 0)
                    endfor
                elsif function.return_zend_type = "IS_ARRAY"
                    my._ret += format_left("array_init(return_value);", 0)
                    for function.return_argument as return_argument0 where return_argument0.name <> "status" & return_argument0.type <> "enum"
                        if return_argument0.type = "buffer"
                            my._ret += format_left("add_next_index_str(return_value, out_$(return_argument0.name:));", 0)
                        else 
                            echo_debug_item(return_argument0)
                            echo_fatal("Not implemented (AZ1201)", my)
                        endif
                    endfor
                elsif function.return_zend_type = "IS_LONG"
                    for function.return_argument as return_argument0 where return_argument0.name <> "status" & return_argument0.type <> "enum"
                        if return_argument0.type = "byte"
                            my._ret += format_left("RETVAL_LONG(ret_$(return_argument0.name:));", 0)
                        else
                            my._ret += format_left("RETVAL_LONG($(return_argument0.name:));", 0)
                        endif
                    endfor
                elsif function.return_zend_type = "IS_VOID"

                elsif function.return_zend_type = "IS_RESOURCE"
                    for function.return_argument as return_argument0
                        if string_in (return_argument0.type0, "class, interface, implementation")
                            my._ret += format_left("\
                                zend_resource *$(return_argument0.name:)_res = zend_register_resource($(return_argument0.name:)$(my._rs), le_$(my.in_php_project.prefix:)_impl_t);
                                RETVAL_RES($(return_argument0.name:)_res);
                                ", 0)
                        #elsif return_argument0.type0 = "class"
                        #    my._res += format_left("\
                        #        zend_resource *$(return_argument0.name:)_res = zend_register_resource($(return_argument0.name:)$(my._rs), le_$(return_argument0.type:)_t);
                        #        RETVAL_RES($(return_argument0.name:)_res);
                        #        ", 0)
                        else
                            echo_debug_item(function)
                            echo_debug_item(return_argument0)
                            echo_fatal("Not implemented (AK1000)", my)
                        endif
                    endfor
                elsif function.return_zend_type = "_IS_BOOL"
                    for function.return_argument as return_argument0
                        my._ret += format_left("RETVAL_BOOL($(return_argument0.name:));", 0)
                    endfor
                else
                    echo_debug_item(function)
                    echo_fatal("Not implemented (AO1001)", my)
                endif

                my._res = my._ret

                if function.throw_exception = 1 & function.return_zend_type <> "IS_VOID"
                    my._fail = ""
                    my._success = ""

                    #function.return_zend_type: "IS_VOID, IS_LONG, _IS_BOOL, IS_STRING, IS_ARRAY, IS_RESOURCE
                    if  function.return_zend_type = "IS_STRING" | function.return_zend_type = "IS_ARRAY"
                        for function.return_argument where return_argument.type = "buffer"
                            my._fail += format_left("zend_string_free(out_$(return_argument.name:));", 1)
                            my._success += format_left("vsc_buffer_destroy(&$(return_argument.name:));", 0)
                        endfor
                    endif

                    my._ret = my._ret + my._success

                    my._t1 = format_left("if (status == $(function.prefix0:c)_status_SUCCESS) {", 0)
                    my._t2 = format_left("$(my._ret:)", 1)
                    my._t3 = format_left("}", 0)
                    my._t4 = format_left("else {", 0)
                    my._t5 = format_left("$(my._fail:)", 1)
                    my._t6 = format_left("}", 0)

                    if my._fail <> ""
                        my._res = my._t1 + my._t2 + my._t3 + my._t4 + my._t5 + my._t6
                    else
                        my._res = my._t1 + my._t2 + my._t3
                    endif

                endif

                if my._res <> ""
                    my._c = php_format_extension_comment("Write returned result")
                    my._res = my._c + my._res

                    new write_returned_result to wrapper
                        . = format_left(my._res, 1)
                    endnew
                endif

                ### <--- Write returned result
            endnew
        endnew
    endfor
endfunction

# ---------------------------------------------------------------------------
# 
# ---------------------------------------------------------------------------
function php_map_low_level_constructor_destructor (in_module, out_low_level, in_type)
    check_arguments (my, "in_module, out_low_level, in_type", my)

    new function to my.out_low_level
        .name0 = "$(my.in_module.c_prefix:)_$(my.in_module.name:c)_new"
        .name = "$(0.name0:)_php"
        .prefix0 = "$(my.in_module.c_prefix:)"
        .entity0 = "$(my.in_module.name:)"
        .return_type0 = ""
        .return_type = "IS_RESOURCE"
        .instance = 0
        .throw_exception = 0
        .is_static = 0
        .num_arguments = 0

        my._a = "$(0.prefix0:c)_$(0.entity0:c)"

        new def_func_entry to function
            . = format_left("PHP_FE($(function.name0:)_php, arginfo_$(function.name0:)_php)", 0)
        endnew

        new wrapper to function
            new arg_info to wrapper
                my._c = php_format_extension_comment("Wrap method: $(function.name0:)")

                my._h = format_left("\
                    ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(
                            arginfo_$(function.name0:)_php, 
                            0 /*return_reference*/,
                            $(function.num_arguments:) /*required_num_args*/,
                            $(function.return_type:) /*type*/,
                            0 /*allow_null*/)
                    ZEND_END_ARG_INFO()
                    ", 0)

                my._res = my._c + my._h
                . = my._res
            endnew

            my._le = "le_$(my._a:)_t"
            if my.in_type = "implementation"
                my._le = "le_$(my.in_module.c_prefix:)_impl_t"
            endif

            new custom_code to wrapper
                my._custom_code = format_left("\
                    PHP_FUNCTION($(function.name:)) {
                        $(my._a:)_t *$(function.entity0:c) = $(function.name0:)();
                        zend_resource *$(function.entity0:c)_res = zend_register_resource($(function.entity0:c), $(my._le:));
                        RETVAL_RES($(function.entity0:c)_res);
                    }
                    ", 0)
                . = my._custom_code
            endnew
        endnew
    endnew

    new function to my.out_low_level
        .name0 = "$(my.in_module.c_prefix:)_$(my.in_module.name:c)_delete"
        .name = "$(0.name0:)_php"
        .prefix0 = "$(my.in_module.c_prefix:)"
        .entity0 = "$(my.in_module.name:)"
        .return_type0 = ""
        .return_type = "IS_VOID"
        .instance = 0
        .throw_exception = 0
        .num_arguments = 1
        .is_static = 0

        my._a = "$(0.prefix0:)_$(0.entity0)"

        new def_func_entry to function
            . = format_left("PHP_FE($(function.name0:)_php, arginfo_$(function.name0:)_php)", 0)
        endnew

        new wrapper to function
            new arg_info to wrapper
                my._c = php_format_extension_comment("Wrap method: $(function.name0:)")

                my._h = format_left("\
                    ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(
                            arginfo_$(function.name0:)_php, 
                            0 /*return_reference*/,
                            $(function.num_arguments:) /*required_num_args*/,
                            $(function.return_type:) /*type*/,
                            0 /*allow_null*/)

                            ZEND_ARG_TYPE_INFO(0, in_ctx, IS_RESOURCE, 0)
                    ZEND_END_ARG_INFO()
                    ", 0)

                my._res = my._c + my._h
                . = my._res
            endnew

            my._a = "$(my._a:c)"
            if my.in_type = "implementation"
                my._a = "$(my.in_module.c_prefix:)_impl"
            endif

            new custom_code to wrapper
                my._custom_code = format_left("\
                    PHP_FUNCTION($(function.name:)) {
                        //
                        // Declare input arguments
                        //
                        zval *in_ctx = NULL;

                        //
                        // Parse arguments
                        //
                        ZEND_PARSE_PARAMETERS_START_EX(ZEND_PARSE_PARAMS_THROW, 1, 1)
                            Z_PARAM_RESOURCE_EX(in_ctx, 1, 0)
                        ZEND_PARSE_PARAMETERS_END();

                        //
                        // Fetch for type checking and then release
                        //
                        $(my._a:)_t *$(function.entity0:c) = zend_fetch_resource_ex(in_ctx, $(my._a:)_t_php_res_name, le_$(my._a:)_t);
                        zend_list_close(Z_RES_P(in_ctx));
                        RETURN_TRUE;
                    }
                    ", 0)

                . = my._custom_code
            endnew
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_map_low_level_argument (in_argument, in_php_project, out_argument, out_function)
    check_arguments (my, "in_argument, in_php_project, out_argument, out_function", my)

    my._prefix = my.out_function.prefix0

    my.out_argument.is_dependency = 0

    if defined(my.in_argument.is_dependency) & my.in_argument.is_dependency = 1
        my.out_argument.is_dependency = 1
    endif

    my.out_argument.name = "$(my.in_argument.name:c)"
    my.out_argument.access = my.in_argument.access
    
    my._type_c = class_derive_c_instance_type(my.in_argument)

    if defined (my.in_argument.class)
        if string_in(my.in_argument.class, "data, buffer") 
            my._type0 = my.in_argument.class
            my._type = "vsc_$(my.in_argument.class:)_t"
            my._zend_type = "IS_STRING"
        elsif my.in_argument.class = "error"
            my._type0 = "error"
            my._type = "$(my._prefix:)_error_t"
            my._zend_type = ""
            my.out_function.throw_exception = 1
            my.out_function.check_error = 1
        else
            my._type0 = "class"
            my._type = "$(my._prefix:)_$(my.in_argument.class:c)_t"
            my._shallow_type = "$(my._prefix:)_$(my.in_argument.class:c)"
            my._zend_type = "IS_RESOURCE"
        endif
    endif

    if defined (my.in_argument.interface)
        my._type0 = "interface"
        my._type = "$(my._prefix:)_impl_t"
        my._shallow_type = "$(my._prefix:)_impl"
        my._zend_type = "IS_RESOURCE"
    endif

    if defined (my.in_argument.type)
        if my.in_argument.type = "size"
            my._type0 = my.in_argument.type
            my._type = "vsc_size_t"
            my._zend_type = "IS_LONG"
        elsif my.in_argument.type = "integer"
            my._type0 = my.in_argument.type
            my._type = "int"
            my._zend_type = "IS_LONG"
        elsif my.in_argument.type = "unsigned"
            my._type0 = my.in_argument.type
            my._type = "int"
            my._zend_type = "IS_LONG"
        elsif my.in_argument.type = "byte"
            if count(my.in_argument.array) > 0
                my.out_argument.byte_as_string = 1
            endif
            my._type0 = "byte"
            if my.in_argument.is_reference = 1
                my._type = "string"
                my._zend_type = "IS_STRING"
            else 
                my._type = "int"
                my._zend_type = "IS_LONG"
            endif
        elsif my.in_argument.type = "boolean"
            my._type0 = my.in_argument.type
            my._type = "zend_bool"
            my._zend_type = "_IS_BOOL"
        else
            echo_debug_item(my.in_argument)
            echo_fatal("Not implemented (AN1006)", my)
        endif
    endif

    if defined (my.in_argument.enum)
        my._type0 = "enum"
        my._type = "$(my._prefix:)_$(my.in_argument.enum:c)_t"
        my._zend_type = "IS_LONG"
    endif

    if defined (my.in_argument.impl)
        my._type0 = "impl"
        my._type = "$(my._prefix:)_$(my.in_argument.impl:c)_t"
        my._shallow_type = "$(my._prefix:)_$(my.in_argument.impl:c)"
        my._zend_type = "IS_RESOURCE"
    endif

    my.out_argument.type0 = my._type0
    my.out_argument.type = my._type
    my.out_argument.zend_type = my._zend_type
    my.out_argument.type_c = my._type_c

    if defined (my._shallow_type)
        my.out_argument.shallow_copy = "$(my._shallow_type:)_shallow_copy"
    else
        my.out_argument.shallow_copy = "$(0.type:)_shallow_copy"
    endif

endfunction

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_map_low_level_return (in_method, in_php_project, out_function)
    check_arguments (my, "in_method, in_php_project, out_function", my)

    my._prefix = my.out_function.prefix0
    my._return_self = 0

    my._return_type0 = "void"
    my._return_type = ""
    my._return_zend_type = "IS_VOID"
    my._throw_exception = 0

    my._argument_buffer_count = 0

    for my.in_method.argument as argument0 where defined (argument0.class)
        if argument0.class = "buffer"
            my._argument_buffer_count = my._argument_buffer_count + 1
            new return_argument to my.out_function
                .name = "$(argument0.name:c)"
                .type = "buffer"
                .type_t = 0.type

                my._prefix = my.out_function.prefix0
                my._entity = my.out_function.entity0

                if defined (argument0->length->proxy)
                    my._proxy = ""
                    for argument0->length.proxy as proxy0
                        if defined (proxy0.cast) & proxy0.cast = "data_length"
                            my._proxy += "$(proxy0.argument:c).len"
                        elsif defined (proxy0.argument)
                            my._proxy += "$(proxy0.argument:c)"
                        elsif defined (proxy0.constant)
                            my._proxy += "$(proxy0.constant:)"
                        else
                            echo_debug_item(my.in_method)
                            echo_debug_item(proxy0)
                            echo_fatal("Not implemented (AG1000)")
                        endif

                        if ! last()
                            my._proxy += ", "
                        endif
                    endfor
                    my._function = "$(my._prefix:)_$(my._entity:)_$(argument0->length.method:c)"
                    .proxy = my._proxy
                    .length = my._function
                    .length_type = "method_proxy"
                elsif defined (argument0->length.class)
                    my._class = argument0->length.class
                    my._constant = "$(argument0->length.constant:c)"
                    my._constant = "$(my._constant:UPPER)"
                    .length = "$(my._prefix:c)_$(my._class:c)_$(my._constant:)"
                    .length_type = "constant"
                elsif defined (argument0->length.method)
                    my._method = "$(argument0->length.method:c)"
                    my._function = "$(my._prefix:)_$(my._entity:)_$(argument0->length.method:c)"
                    .length = my._function
                    .length_type = "method"

                elsif defined (argument0->length.constant)
                    my._constant = "$(argument0->length.constant:c)"
                    my._constant = "$(my._constant:UPPER)"
                    .length = "$(my._prefix:c)_$(my._entity:)_$(my._constant:)"
                    .length_type = "constant"
                elsif defined (argument0->length.argument)
                    .length = "$(argument0->length.argument:)"
                    .length_type = "argument"
                else 
                    echo_debug_item(argument0)
                    echo_fatal("Not implemented (AA1000)", my)
                endif
            endnew
        endif
    endfor

    if my._argument_buffer_count = 1
        my._return_type = "string"
        my._return_zend_type = "IS_STRING"
    elsif my._argument_buffer_count > 1
        my._return_type = "array"
        my._return_zend_type = "IS_ARRAY"
    endif

    for my.in_method.return as return0

        my._is_reference = return0.is_reference

        if defined (return0.type)
            if return0.type = "size"
                my._return_type0 = return0.type
                my._return_type = "size_t"
                my._return_zend_type = "IS_LONG"
            elsif return0.type = "integer" | return0.type = "unsigned"
                my._return_type0 = return0.type
                my._return_type = "int"
                my._return_zend_type = "IS_LONG"
            elsif return0.type = "byte"
                my._return_type0 = return0.type
                my._return_type = "byte"
                my._return_zend_type = "IS_LONG"
            elsif return0.type = "boolean"
                my._return_type0 = return0.type
                my._return_type = "zend_bool"
                my._return_zend_type = "_IS_BOOL"
            else
                echo_debug_item(my.in_method)
                echo_debug_item(return0)
                echo_fatal("Not implemented (AV1000)", my)
            endif

            new return_argument to my.out_function
                .name = "res"
                .type0 = "$(return0.type:c)"
                .type = my._return_type
                .type_t = 0.type
                .zend_type = my._return_zend_type
                .is_reference = my._is_reference
            endnew
        endif

        my._r = ""

        if defined (return0.class)

            if return0.class = "data"
                my._return_type0 = return0.class
                my._return_type = "vsc_data_t"
                my._return_zend_type = "IS_STRING"

                new return_argument to my.out_function
                    .name = return0.class
                    .type0 = "data"
                    .type = my._return_type
                    .type_t = 0.type
                    .zend_type = my._return_zend_type
                    .is_reference = my._is_reference
                endnew
            else
                my._return_type0 = return0.class
                my._return_type = "class"
                my._return_zend_type = "IS_RESOURCE"

                new return_argument to my.out_function
                    .name = "$(return0.class:c)"
                    .type0 = "class"
                    .type_t = "$(my._prefix:)_$(0.name:)_t"
                    .type = "$(my._prefix:)_$(0.name:)"
                    .zend_type = my._return_zend_type
                    .is_reference = my._is_reference
                    .access = return0.access
                    .shallow_copy = "$(0.type:)_shallow_copy"
                    .class_name0 = "$(return0.class:)"
                endnew
            endif
        elsif defined (return0.interface)
            my._return_type0 = return0.interface
            my._return_type = "interface"
            my._return_zend_type = "IS_RESOURCE"

            new return_argument to my.out_function
                .name = "$(return0.interface:c)"
                .type0 = "interface"
                .type_t = "$(my._prefix:)_impl_t"
                .type = "$(my._prefix:)_impl"
                .zend_type = my._return_zend_type
                .is_reference = my._is_reference
                .access = return0.access
                .shallow_copy = "$(0.type:)_shallow_copy"
                .class_name0 = "$(return0.interface:)"
            endnew
        elsif defined (return0.impl)
            my._return_type0 = return0.impl
            my._return_type = "implementation"
            my._return_zend_type = "IS_RESOURCE"

            new return_argument to my.out_function
                .name = "$(return0.impl:c)"
                .type0 = "implementation"
                .type_t = "$(my._prefix:)_$(0.name:)_t"
                .type = "$(my._prefix:)_$(0.name:)"
                .zend_type = my._return_zend_type
                .is_reference = my._is_reference
                .access = return0.access
                .shallow_copy = "$(0.type:)_shallow_copy"
                .class_name0 = "$(return0.impl:)"
            endnew
        endif

        if defined (return0.enum)
            if return0.enum = "status"
                my._throw_exception = 1

                new return_argument to my.out_function
                    .name = "status"
                    .type0 = "status"
                    .type = "$(my._prefix:)_status_t"
                    .type_t = 0.type
                    .zend_type = "IS_RESOURCE"
                endnew
            else
                my._return_type0 = "enum"
                my._return_type = "int"
                my._return_zend_type = "IS_LONG"

                new return_argument to my.out_function
                    .name = "$(return0.enum:c)"
                    .type0 = "enum"
                    .type = "int"
                    .type_t = 0.type
                    .zend_type = "IS_LONG"
                    .is_reference = my._is_reference
                endnew
            endif
        endif
    endfor

    my.out_function.return_type0 = my._return_type0
    my.out_function.return_type = my._return_type
    my.out_function.return_zend_type = my._return_zend_type
    my.out_function.throw_exception = my._throw_exception
    my.out_function.return_self = my._return_self

endfunction

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_map_low_level_extension (in_php_project, out_php_module)
    check_arguments (my, "in_php_project, out_php_module", my)

    my._include = ""

    my._registered_resources = ""
    my._header_registered_resources = ""
    my._constants = ""
    my._header_constants = ""

    if defined(my.in_php_project->interfaces)
        my._registered_resources = format_left("int le_$(my.in_php_project.prefix)_impl_t;", 0)
        my._header_registered_resources = format_left("extern int le_$(my.in_php_project.prefix)_impl_t;", 0)
        my._constants = format_left("const char $(my.in_php_project.prefix:)_impl_t_php_res_name[] = \"$(my.in_php_project.prefix)_impl_t\";", 0)
        my._header_constants = format_left("extern const char $(my.in_php_project.prefix:)_impl_t_php_res_name[];", 0)
    endif

    my._init_func_def_dtor = ""
    my._init_func_def_list_destr = ""

    if defined(my.in_php_project->interfaces)

        my._p = my.in_php_project.prefix

        my._init_func_def_dtor += format_left("\
            static void $(my._p:)_impl_dtor_php(zend_resource *rsrc) {
                $(my._p:)_impl_delete(($(my._p:)_impl_t *)rsrc->ptr);
            }
            ", 0)


        my._init_func_def_list_destr += format_left("\
            le_$(my._p:)_impl_t = zend_register_list_destructors_ex($(my._p:)_impl_dtor_php, NULL, $(my._p:)_impl_t_php_res_name, module_number);
            ", 0)
    endif

    my._def_func_entries = ""
    my._func_wrapping = ""
    my._extension_status = ""

    for my.in_php_project.php_module as php_module0 where php_module0.name0 = "extension status"
        my._extension_status += php_module0->custom_code.
    endfor

    my._ext_name0 = "$(my.in_php_project.prefix:)_$(my.in_php_project.name:)_php"

    for my.in_php_project.php_module as php_module0 where string_in(php_module0.type, "class, implementation, single_function")
        if ! defined (php_module0->low_level->include) & php_module0.type <> "single_function"
            echo_debug_item(php_module0->low_level)
            echo_fatal("========", my)
        endif

        if php_module0.type <> "single_function"
            my._include += php_module0->low_level->include.

            if php_module0.type <> "implementation"
                my._registered_resources += php_module0->low_level->registered_resource.
                my._header_registered_resources += php_module0->low_level->header_registered_resource.
                my._constants += php_module0->low_level->constant.
                my._header_constants += php_module0->low_level->header_constant.
                my._init_func_def_dtor += php_module0->low_level->init_func_def_dtor.
                my._init_func_def_list_destr += php_module0->low_level->init_func_def_list_destr.
            endif
        endif

        for php_module0->low_level.function as function0
            my._func_wrapping += format_left(function0->wrapper->arg_info., 0)
            my._def_func_entries += function0->def_func_entry.

            if defined(function0->wrapper->custom_code)
                my._func_wrapping += "\n" + format_left(function0->wrapper->custom_code., 0)
            else
                my._1 = "\n" + function0->wrapper->header.
                my._2 = "\n" + function0->wrapper->declare_input_arguments.
                my._3 = "\n" + function0->wrapper->parse_arguments.
                my._4 = "\n" + function0->wrapper->proxy_call.

                my._5 = ""
                if defined(function0->wrapper->allocate_output_buffer)
                    my._5 = "\n" + function0->wrapper->allocate_output_buffer.
                endif

                my._6 = ""
                if defined(function0->wrapper->argument_type_mapping)
                    my._6  = "\n" + function0->wrapper->argument_type_mapping.
                endif

                my._7 = "\n" + function0->wrapper->call_main_function.

                my._8 = ""
                if defined(function0->wrapper->handle_error)
                    my._8 = "\n" + function0->wrapper->handle_error
                endif

                my._9 = ""
                if defined(function0->wrapper->correct_string_length)
                    my._9 = "\n" + function0->wrapper->correct_string_length.
                endif

                my._10 = ""
                if defined(function0->wrapper->return_type_mapping)
                    my._10 = "\n" + function0->wrapper->return_type_mapping.
                endif

                my._11 = ""
                if defined(function0->wrapper->write_returned_result)
                    my._11 = "\n" + function0->wrapper->write_returned_result.
                endif

                my._12 = format_left("}", 0)

                my._func_wrapping += my._1 + my._2 + my._3 + my._4 + my._5 + my._6 + my._7 + my._8 + my._9 + my._10 + my._11 + my._12
            endif

            my._func_wrapping += "\n"
        endfor
    endfor

    new licence to my.out_php_module
        my._res = php_format_extension_comment (my.in_php_project->license)
        . = my._res
    endnew

    new include to my.out_php_module
        my._res = format_left("\
            #include <php.h>
            #include <zend_exceptions.h>
            #include <zend_list.h>
            #include \"$(my.in_php_project.prefix:)_assert.h\"
            #include \"$(my.in_php_project.prefix:)_$(my.in_php_project.name:)_php.h\"
            ", 0)

        my._res = my._res + my._include

        . = my._res
    endnew

    new constants to my.out_php_module

        my._ext_name = "$(my._ext_name0:UPPER)"

        my._c = php_format_extension_comment ("Constants")
        my._h = format_left("\
            const char $(my._ext_name:)_VERSION[] = \"$(my.in_php_project.version:)\";
            const char $(my._ext_name:)_EXTNAME[] = \"$(my._ext_name0:)\"; 
            ", 0)
        my._res = my._c + my._h + my._constants
        . = my._res
    endnew

    new header_constants to my.out_php_module
        my._c = php_format_extension_comment ("Constants")
        my._res = my._c + my._header_constants
        . = my._res
    endnew

    new registered_resources to my.out_php_module
        my._c = php_format_extension_comment ("Registered resources")
        my._res = my._c + my._registered_resources
        . = my._res
    endnew

    new header_registered_resources to my.out_php_module
        my._c = php_format_extension_comment ("Registered resources")
        my._res = my._c + my._header_registered_resources
        . = my._res
    endnew

    new init_func_declaration to my.out_php_module

        my._c = php_format_extension_comment ("Extension init functions declaration")
        my._h = format_left("\
            PHP_MINIT_FUNCTION($(my._ext_name0:));
            PHP_MSHUTDOWN_FUNCTION($(my._ext_name0:));
            ", 0)
        my._res = my._c + my._h
        . = my._res
    endnew

    new func_wrapping to my.out_php_module
        my._c = php_format_extension_comment ("Functions wrapping")
        my._h = my._func_wrapping
        my._res = my._c + my._h
        . = my._res
    endnew

    new define_all_func_entries to my.out_php_module
        my._c = php_format_extension_comment ("Define all function entries")

        my._h1 = format_left("static zend_function_entry $(my._ext_name0:)_functions[] = {", 0)
        my._h2 = format_left("$(my._def_func_entries:)", 1)
        my._h3 = format_left("\
                PHP_FE_END
            };
            ", 0)

        my._res = my._c + my._h1 + my._h2 + my._h3

        . = my._res
    endnew

    new module_definitions to my.out_php_module
        my._c = php_format_extension_comment ("Extension module definition")
        my._h = format_left("\
            zend_module_entry $(my._ext_name0:)_module_entry = {
            #if ZEND_MODULE_API_NO >= 20010901
                STANDARD_MODULE_HEADER,
            #endif
                $(my._ext_name0:UPPER)_EXTNAME,
                $(my._ext_name0:)_functions,
                PHP_MINIT($(my._ext_name0:)),
                PHP_MSHUTDOWN($(my._ext_name0:)),
                NULL,
                NULL,
                NULL,
            #if ZEND_MODULE_API_NO >= 20010901
                $(my._ext_name0:UPPER)_VERSION,
            #endif
                STANDARD_MODULE_PROPERTIES
            };

            ZEND_GET_MODULE($(my._ext_name0:))
            ", 0)

        my._res = my._c + my._h
        . = my._res
    endnew

    new init_func_definitions to my.out_php_module
        my._c = php_format_extension_comment ("Extension init functions definition")

        my._h1 = format_left("$(my._init_func_def_dtor:)", 0)
        my._h2 = format_left("PHP_MINIT_FUNCTION($(my._ext_name0:)) {", 0)
        my._h3 = format_left("$(my._init_func_def_list_destr:)", 1)

        my._h4 = format_left("\
                return SUCCESS;
            }
            ", 0)

        my._h5 = format_left("\
            PHP_MSHUTDOWN_FUNCTION($(my._ext_name0:)) {
                return SUCCESS;
            }
            ", 0)

        my._res = my._c + my._h1 + my._h2 + my._h3 + my._h4 + my._h5

        . = my._res
    endnew

    new extension_status to my.out_php_module
        . = my._extension_status
    endnew

endfunction
.endtemplate
