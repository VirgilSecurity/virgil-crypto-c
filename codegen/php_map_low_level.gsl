.template 0
#   Copyright (C) 2015-2020 Virgil Security, Inc.
#
#   All rights reserved.
#
#   Redistribution and use in source and binary forms, with or without
#   modification, are permitted provided that the following conditions are
#   met:
#
#       (1) Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#
#       (2) Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in
#       the documentation and/or other materials provided with the
#       distribution.
#
#       (3) Neither the name of the copyright holder nor the names of its
#       contributors may be used to endorse or promote products derived from
#       this software without specific prior written permission.
#
#   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR
#   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#   DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
#   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
#   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
#   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
#   STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
#   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#   POSSIBILITY OF SUCH DAMAGE.
#
#   Lead Maintainer: Virgil Security Inc. <support@virgilsecurity.com>

# ---------------------------------------------------------------------------
#   Functions for PHP primitives generation: protocol, class, enum, etc.
# ---------------------------------------------------------------------------
#   This is a code generator built using the iMatix GSL code generation
#   language. See https://github.com/imatix/gsl for details.
# ---------------------------------------------------------------------------

gsl from "common.gsl"

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_map_low_level (in_module, in_php_project, out_low_level, in_type)
    check_arguments (my, "in_module, in_php_project, out_low_level, in_type", my)

    my.out_low_level.name = "$(my.in_module.name:c)"
    my.out_low_level.name0 = "$(my.in_module.name:c)"
    my._wot = "$(my.in_php_project.prefix:)_$(my.out_low_level.name0:)"
    my._t = "$(my._wot:)_t"
    my.out_low_level.constant = "$(my._t:)_php_res_name"
    my._constant = ""

    if my.in_type <> "single_function"

        new [include] to my.out_low_level
            . = format_left("#include \"$(my.in_php_project.prefix:)_$(my.out_low_level.name0:).h\"", 0)
        endnew

        new registered_resource to my.out_low_level
            . = format_left("int LE_$(my.in_php_project.prefix:UPPER)_$(my.out_low_level.name0:UPPER)_T;", 0)
        endnew

        new registered_resource_func_wrapp to my.out_low_level
            . = php_format_low_level_wrapp_func_rr("le_$(my.in_php_project.prefix:)_$(my.out_low_level.name0:)_t", "$(my.in_php_project.prefix:)", 0)
        endnew

        new header_registered_resource to my.out_low_level
            . = php_format_low_level_wrapp_func_rr("le_$(my.in_php_project.prefix:)_$(my.out_low_level.name0:)_t", "$(my.in_php_project.prefix:)", 1)
        endnew

        new constant to my.out_low_level
            . = format_left("static const char $(my.out_low_level.constant:UPPER)[] = \"$(my._t:)\";", 0)
        endnew

        new constant_func_wrapp to my.out_low_level
            . = php_format_low_level_wrapp_func_const("$(my.in_php_project.prefix:UPPER)_$(my.out_low_level.name0:UPPER)_T_PHP_RES_NAME", "$(my.in_php_project.prefix:)", 0)
        endnew

        new header_constant to my.out_low_level
            . = php_format_low_level_wrapp_func_const("$(my.in_php_project.prefix:UPPER)_$(my.out_low_level.name0:UPPER)_T_PHP_RES_NAME", "$(my.in_php_project.prefix:)", 1)
        endnew

        new init_func_def_dtor to my.out_low_level
            . = format_left("\
                static void $(my._wot:)_dtor_php(zend_resource *rsrc) {
                    $(my._wot:)_delete(($(my._t:) *)rsrc->ptr);
                }
                ", 0)
        endnew

        new init_func_def_list_destr to my.out_low_level

            my.__f1 = php_derive_low_level_wrapp_func_full_name("$(my._t:)_php_res_name")
            . = format_left("\
                LE_$(my._t:UPPER) = zend_register_list_destructors_ex($(my._wot:)_dtor_php, NULL, $(my.__f1:)(), module_number);
                ", 0)
        endnew

        if my.in_type <> "interface" & my.in_module.context <> "none"
            php_map_low_level_constructor_destructor (my.in_module, my.out_low_level, my.in_type)
        endif

        for my.in_module.dependency as dependency0

            my._dep_name = dependency0.name

            new method to my.in_module
                .name = "use $(my._dep_name:)"
                .visibility = "public"
                .[scope] = "public"
                .declaration = "public"
                .is_static = "0"
                .return_type = "void"
                .is_const = "0"
                .c_prefix = my.in_php_project.prefix

                my.argument = item_copy_to(dependency0, method, "argument")
                my.argument.access ?= "readwrite"
                my.argument._c_type = class_derive_c_instance_type(my.argument)
                my.argument.is_dependency = "1"

                if is_true(dependency0.is_observers_return_status)
                    new [return] to method
                        .enum = "status"
                        .is_reference = "0"
                    endnew
                endif
            endnew
        endfor
    else
        new method to my.in_module
            .name = "impl tag"
            .visibility = "public"
            .[scope] = "public"
            .declaration = "public"
            .is_static = "1"
            .return_type = "int"
            .is_const = "0"
            .c_prefix = my.in_php_project.prefix

            new argument to method
                .name = "ctx"
                .interface = "ctx"
                .access = "readonly"
                .is_reference = "1"
            endnew

            new [return] to method
                .enum = "tag"
                .access = "readonly"
                .is_reference = "0"
            endnew
        endnew
    endif

    for my.in_module.method as method0 where wrapper_should_wrap_method(method0) & method0.name <> "get ctx"
        new [function] to my.out_low_level

            .is_static = method0.is_static

            .prefix0 = "$(my.in_module.c_prefix:c)"
            .entity0 = "$(my.in_module.name:c)"

            if my.in_type = "interface"
                .name0 = ""
                .name = ""
            elsif my.in_type = "single_function"
                .name0 = "$(0.prefix0:)_$(method0.name:c)"
                .name = "$(0.name0:)_php"
            else 
                .name0 = php_derive_low_level_function_name(0, method0)
                .name = "$(0.name0:)_php"
            endif

            .num_arguments = 0

            my._method_arguments = ""
            my._function_arguments = ""

            new def_func_entry to [function]
                . = format_left("PHP_FE($([function].name:), arginfo_$([function].name:))", 0)
            endnew

            php_map_low_level_return (method0, my.in_php_project, [function])

            for method0.argument as argument0

                my._d = ""
                if ! last()
                    my._d = ", "
                endif

                my._declare_input_arguments = ""

                new argument to [function]
                    php_map_low_level_argument (argument0, my.in_php_project, argument, [function])
                endnew
            endfor

            new wrapper to [function]

                ### Arg info --->

                new arg_info to wrapper

                    my._num_arguments = 1 # ctx
                    my._zend_arg_type_info = format_left("ZEND_ARG_TYPE_INFO(0, in_ctx, IS_RESOURCE, 0)", 0)

                    if is_true([function].is_static)
                        my._num_arguments = 0
                        my._zend_arg_type_info = ""
                    endif

                    for [function].argument as argument0 where ! string_in2 (argument0.type0, "error, buffer, str buffer")
                        my._num_arguments = my._num_arguments + 1
                        #ZEND_ARG_TYPE_INFO(pass_by_ref, name, type_hint, allow_null)
                        my._zend_arg_type_info += format_left("ZEND_ARG_TYPE_INFO(0, in_$(argument0.name:), $(argument0.zend_type:), 0)", 0)
                    endfor

                    my._r = format_left(my._zend_arg_type_info, 7)

                    my._c = php_format_extension_comment("Wrap method: $([function].name0:)")

                    my._h = format_left("\
                        ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(
                            arginfo_$([function].name0:)_php, 
                            0 /*return_reference*/,
                            $(my._num_arguments:) /*required_num_args*/,
                            $([function].return_zend_type:) /*type*/,
                            0 /*allow_null*/)

                            $(my._r:)
                        ZEND_END_ARG_INFO()
                    ", 0)

                    my._res = my._c + my._h
                    . = format_left(my._res, 0)
                endnew

                ### <--- Arg info

                #### Header --->

                new header to wrapper
                    . = format_left("PHP_FUNCTION($([function].name:)) {", 0)
                endnew

                ### <--- Header

                ### Declare input arguments --->

                new declare_input_arguments to wrapper
                    my._c = php_format_extension_comment("Declare input argument")

                    my._h1 = format_left("zval *in_ctx = NULL;")

                    if is_true([function].is_static)
                        my._h1 = ""
                    endif

                    for [function].argument as argument0 where ! string_in(argument0.type, "vsc_buffer_t, vsc_str_buffer_t")
                        if argument0.type0 <> "error"
                            if argument0.zend_type = "IS_STRING"
                                my._h1 += format_left("\
                                    char *in_$(argument0.name:) = NULL;
                                    size_t in_$(argument0.name:)_len = 0;
                                    ", 0)
                            elsif argument0.zend_type = "IS_LONG"
                                my._h1 += format_left("\
                                    zend_long in_$(argument0.name:) = 0;
                                    ", 0)
                            elsif argument0.zend_type = "IS_RESOURCE"
                                my._h1 += format_left("\
                                    zval *in_$(argument0.name:) = NULL;
                                    ", 0)
                            elsif argument0.zend_type = "_IS_BOOL"
                                my._h1 += format_left("\
                                    zend_bool in_$(argument0.name:);
                                    ", 0)
                            else
                                echo_debug_item(argument0)
                                echo_debug_item(function)
                                echo_fatal("Not implemented (AQ1000)")
                            endif
                        endif
                    endfor

                    my._res = my._c + my._h1

                    . = format_left(my._res, 1)
                endnew

                ### <--- Declare input arguments

                ### Parse arguments --->

                new parse_arguments to wrapper
                    my._c = php_format_extension_comment("Parse arguments")
                    my._h1 = format_left("ZEND_PARSE_PARAMETERS_START_EX(ZEND_PARSE_PARAMS_THROW, $(my._num_arguments:), $(my._num_arguments:))", 0)

                    my._h2 = ""
                    if is_false([function].is_static)
                        my._h2 = format_left("Z_PARAM_RESOURCE_EX(in_ctx, 1, 0)", 1)
                    endif

                    for [function].argument as argument0 where ! string_in2 (argument0.type0, "buffer, error, str buffer")
                            if argument0.zend_type = "IS_STRING"
                                my._h2 += format_left("Z_PARAM_STRING_EX(in_$(argument0.name:), in_$(argument0.name:)_len, 1 /*check_null*/, 0 /*separate*/)", 1)
                            elsif argument0.zend_type = "IS_LONG"
                                my._h2 += format_left("Z_PARAM_LONG(in_$(argument0.name:))", 1)
                            elsif argument0.zend_type = "IS_RESOURCE"
                                my._h2 += format_left("Z_PARAM_RESOURCE_EX(in_$(argument0.name:), 1 /*check_null*/, 0 /*separate*/)", 1)
                            elsif argument0.zend_type = "_IS_BOOL"
                                my._h2 += format_left("Z_PARAM_BOOL(in_$(argument0.name:))", 1)
                            else
                                echo_debug_item(argument0)
                                echo_fatal("Not implemented (AL1002)")
                            endif
                    endfor
                    my._h3 = format_left("ZEND_PARSE_PARAMETERS_END();", 0)
                    my._res = my._c + my._h1 + my._h2 + my._h3

                    . = format_left(my._res, 1)
                endnew

                ### <--- Parse arguments

                ### Proxy call --->

                my._proxy_call = ""

                if is_false([function].is_static)

                    my._res_name = "$(my._t:UPPER)_PHP_RES_NAME"
                    my._le = "LE_$(my._t:UPPER)"

                    if my.in_type = "implementation"
                        my._res_name = "$(my.in_php_project.prefix:UPPER)_IMPL_T_PHP_RES_NAME"
                        my._le = "LE_$(my.in_php_project.prefix:c)_IMPL_T"
                    endif

                    my.__f1 = php_derive_low_level_wrapp_func_full_name("$(my._res_name:)")
                    my.__f2 = php_derive_low_level_wrapp_func_full_name("$(my._le:)")

                    my._proxy_call = format_left("\
                        $(my._t:c) *$(my.out_low_level.name0:c) = zend_fetch_resource_ex(in_ctx, $(my.__f1:)(), $(my.__f2:)());
                        ", 0)
                endif

                for [function].argument as argument0 where ! string_in2 (argument0.type0, "buffer, integer, enum, byte, boolean, unsigned, char, str buffer")
                    if argument0.type = "vsc_data_t"
                        my._proxy_call += format_left("vsc_data_t $(argument0.name:) = vsc_data((const byte*)in_$(argument0.name:), in_$(argument0.name:)_len);", 0)
                    elsif argument0.type = "vsc_str_t"
                        my._proxy_call += format_left("vsc_str_t $(argument0.name:) = vsc_str_from_str(in_$(argument0.name:));", 0)
                    elsif string_in (argument0.type0, "interface, class, impl")
                        if string_in(argument0.type0, "class, interface")

                            my.__f1 = php_derive_low_level_wrapp_func_full_name ("$(argument0.type_c:)_php_res_name")
                            my.__f2 = php_derive_low_level_wrapp_func_full_name ("le_$(argument0.type_c:)")
                            my._proxy_call += format_left("\
                                $(argument0.type_c:) *$(argument0.name:c) = zend_fetch_resource_ex(in_$(argument0.name:), $(my.__f1:)(), $(my.__f2)());
                                ", 0)
                        else
                            my._a = [function].prefix0

                            my.__f1 = php_derive_low_level_wrapp_func_full_name ("$(my._a:)_impl_t_php_res_name")
                            my.__f2 = php_derive_low_level_wrapp_func_full_name ("le_$(my._a:)_impl_t")
                            my._proxy_call += format_left("\
                                $(argument0.type_c:) *$(argument0.name:c) = zend_fetch_resource_ex(in_$(argument0.name:), $(my.__f1:)(), $(my.__f2:)());
                                ", 0)
                        endif
                    elsif argument0.type0 = "size"
                        my._proxy_call += format_left("
                            size_t $(argument0.name:) = in_$(argument0.name:);
                            ", 0)
                    elsif argument0.type0 = "error"
                        my._proxy_call += format_left("
                            $([function].prefix0:)_error_t error;
                            $([function].prefix0:)_error_reset(&error);
                            ", 0)
                    else
                        echo_debug_item(function)
                        echo_debug_item(argument0)
                        echo_fatal("Not implemented (AF1000)")
                    endif
                endfor

                if my._proxy_call <> ""
                    new proxy_call to wrapper
                        my._c = php_format_extension_comment("Proxy call")
                        my._res = my._c + my._proxy_call
                        . = format_left(my._res, 1)
                    endnew
                endif

                ### <--- Proxy call

                ### Argument type mapping --->

                my._mapper = ""

                for [function].argument as argument0
                    if argument0.type = "int"
                        if is_true(argument0.byte_as_string)
                            my._mapper += format_left("byte *$(argument0.name:) = (byte *)in_$(argument0.name:);", 0)
                        else
                            my._mapper += format_left("$(argument0.type_c) $(argument0.name:) = in_$(argument0.name:);", 0)
                        endif
                    endif

                    if argument0.type0 = "char"
                        my._mapper += format_left("char *$(argument0.name:) = in_$(argument0.name:);", 0)
                    endif

                    if argument0.type0 = "enum"
                        my._mapper += format_left("$(argument0.type_c:) $(argument0.name:) = ($(argument0.type:))in_$(argument0.name:);", 0)
                    endif

                    if argument0.type0 = "boolean"
                        my._mapper += format_left("$(argument0.type_c:) $(argument0.name:) = ($(argument0.type_c:))in_$(argument0.name:);", 0)
                    endif

                    if argument0.access = "disown"
                        my._mapper += format_left("\
                            // Shallow copy (.access=\"disown\")
                            $(argument0.type_c:) *$(argument0.name:)_tmp = $(argument0.shallow_copy:)($(argument0.name:));
                            ", 0)
                    endif
                endfor

                if my._mapper <> ""
                    new argument_type_mapping to wrapper
                        my._c = php_format_extension_comment("Argument type mapping")
                        my._res = my._c + my._mapper
                        . = format_left(my._res, 1)
                    endnew
                endif

                ### <--- Argument type mapping

                #### Allocate output buffer --->

                my._res = ""

                for [function].return_argument as return_argument0

                        my._n = ""
                        if ! last()
                            my._n = "\n"
                        endif

                        if ! defined (return_argument0.type)
                            echo_debug_item(function)
                            echo_debug_item(return_argument0)
                            echo_fatal("Not implemented (AI1001)", my)
                        endif

                        if string_in2(return_argument0.type, "buffer, str buffer")
                            my._c = php_format_extension_comment("Allocate output buffer for output '$(return_argument0.name:)'")

                            if return_argument0.length_type = "constant"
                                my._l = "$(return_argument0.length:)"
                            elsif return_argument0.length_type = "method"
                                if my.in_module.context = "none"
                                    my._l = "$(return_argument0.length:)()"
                                else
                                    my._l = "$(return_argument0.length:)($([function].entity0:))"
                                endif
                            elsif return_argument0.length_type = "method_proxy"
                                if string_equal(my.in_module.context, "none")
                                    my._l = "$(return_argument0.length:)($(return_argument0.proxy:))"
                                else
                                    if my.in_module.context = "none"
                                        my._l = "$(return_argument0.length:)($(return_argument0.proxy:))"
                                    else
                                        my._l = "$(return_argument0.length:)($([function].entity0:), $(return_argument0.proxy:))"
                                    endif
                                endif
                            elsif return_argument0.length_type = "argument"
                                my._l = return_argument0.length
                            else 
                                echo_debug_item(function)
                                echo_debug_item(return_argument0)
                                echo_fatal("Not implemented (AP1001)")
                            endif

                            if string_equal(return_argument0.type, "str buffer")
                                my._h1 = format_left("\
                                    zend_string *out_$(return_argument0.name:) = zend_string_alloc($(my._l), 0);
                                    vsc_str_buffer_t *$(return_argument0.name:) = vsc_str_buffer_new();
                                    vsc_str_buffer_use($(return_argument0.name:), (byte *)ZSTR_VAL(out_$(return_argument0.name:)), ZSTR_LEN(out_$(return_argument0.name:)));
                                    ", 0)
                            else
                                my._h1 = format_left("\
                                    zend_string *out_$(return_argument0.name:) = zend_string_alloc($(my._l), 0);
                                    vsc_buffer_t *$(return_argument0.name:) = vsc_buffer_new();
                                    vsc_buffer_use($(return_argument0.name:), (byte *)ZSTR_VAL(out_$(return_argument0.name:)), ZSTR_LEN(out_$(return_argument0.name:)));
                                    ", 0)
                            endif
                            my._res += my._c + my._h1 + "\n" + my._n
                        endif
                endfor

                if my._res <> ""
                    new allocate_output_buffer to wrapper
                        . = format_left(my._res, 1)
                    endnew
                endif

                ### <--- Allocate output buffer

                ### Call main function --->

                new call_main_function to wrapper

                    my._c = php_format_extension_comment("Call main function")

                    my._data_string_proxy = 0

                    my._return = ""
                    my._args = "("

                    my._e = 0
                    my._r = ""

                    if is_false([function].is_static)
                        my._args += "$([function].entity0)"
                        my._e = 1
                    endif

                    my._access = ""
                    my._access_const = ""
                    my._access_shallow_copy = ""

                    my._rs = ""

                    for [function].return_argument as return_argument0 where ! string_in2(return_argument0.type, "buffer, str buffer")

                        if defined (return_argument0.class_name0) & (return_argument0.class_name0 = my.in_module.name)
                            my._rs = "_rs"
                        endif

                        if defined(return_argument0.access)
                            my._access = return_argument0.access
                        endif

                        if my._access = "readonly"
                            my._access_const = "($(return_argument0.type_t:) *)"
                        endif

                        if my._access = "readwrite" | my._access = "readonly"
                            my._access_const = "($(return_argument0.type_t:) *)"
                            my._access_shallow_copy = format_left("$(return_argument0.name:) = $(return_argument0.shallow_copy:)($(return_argument0.name:));", 0)
                        endif

                        my._pointer = ""
                        if is_true(return_argument0.is_reference)
                            my._pointer = "*"
                        endif

                        if return_argument0.type = "vsc_data_t"
                            my._data_string_proxy = "1"
                            my._data_string_proxy_call = format_left("\
                                zend_string *out_$(return_argument0.name:) = zend_string_init(out_$(return_argument0.name:)_temp.bytes, out_$(return_argument0.name:)_temp.len, 0);
                                ", 0)

                            my._out_name = "out_$(return_argument0.name:)"
                            my._return += format_left("\
                                $(return_argument0.type_t:) $(my._pointer:)out_$(return_argument0.name:)_temp = 
                                ", 0)
                        elsif string_in(return_argument0.type, "vsc_buffer_t, vsc_str_buffer_t")
                            my._data_string_proxy = "1"
                            my._data_string_proxy_call = format_left("\
                                vsc_data_t out_data_temp = vsc_buffer_data(out_$(return_argument0.name:)_temp);
                                zend_string *out_buffer = zend_string_init(out_data_temp.bytes, out_data_temp.len, 0);
                                ", 0)

                            if return_argument0.access = "disown"
                                my._data_string_proxy_call += format_left("\
                                    vsc_buffer_destroy(&out_$(return_argument0.name:)_temp);
                                    ", 0)
                            endif

                            my._out_name = "out_$(return_argument0.name:)"
                            my._return += format_left("\
                                $(return_argument0.type_t:) $(my._pointer:)out_$(return_argument0.name:)_temp = 
                                ", 0)
                        else 
                            my._return += format_left("\
                                $(return_argument0.type_t:) $(my._pointer:)$(return_argument0.name:)$(my._rs) = 
                                ", 0)
                        endif
                    endfor

                    my._return = format_left(my._return, 0)

                    for [function].argument as argument0
                        my._dd = ""
                        if first() & my._e = 1
                            my._dd = ", "
                        endif

                        my._d = ""
                        if ! last()
                            my._d = ", "
                        endif

                        if argument0.name = "error"
                            my._args += my._dd + "&$(argument0.name:)" + my._d
                        else
                            if string_in (argument0.type0, "interface, class, impl") & argument0.access = "disown"
                                my._args += my._dd + "&$(argument0.name:)_tmp" + my._d
                            else
                                my._args += my._dd + "$(argument0.name:)" + my._d
                            endif
                        endif
                    endfor

                    my._args += ");"

                    my._func = "$([function].name0:)"

                    my._res = my._c + my._return + my._access_const + my._func + my._args

                    if is_true(my._data_string_proxy)
                        my._res = my._res + my._data_string_proxy_call
                    endif

                    if my._access_shallow_copy <> ""
                        my._res = my._res + my._access_shallow_copy
                    endif

                    . = format_left(my._res, 1)
                endnew

                ### <--- Call main function

                ### Handle error --->

                my._res = ""

                if is_true([function].throw_exception)
                    my._c = php_format_extension_comment("Handle error")

                    my._h1 = ""

                    if is_true([function].check_error)
                        my._h1 += format_left("$([function].prefix0:c)_status_t status = $([function].prefix0:c)_error_status(&error);", 0)
                    endif

                    my._h1 += format_left("$([function].prefix0:UPPER)_HANDLE_STATUS(status);", 0)

                    my._res = my._c + my._h1
                endif

                if my._res <> ""
                    new handle_error to wrapper
                        . = format_left(my._res, 1)
                    endnew
                endif

                ### <--- Handle error

                ### Correct string length to the actual --->

                my._res = ""
                
                for [function].return_argument as return_argument0 where return_argument0.type = "buffer"
                    my._res += format_left("ZSTR_LEN(out_$(return_argument0.name:)) = vsc_buffer_len($(return_argument0.name:));",)
                endfor

                for [function].return_argument as return_argument0 where return_argument0.type = "str buffer"
                    my._res += format_left("ZSTR_LEN(out_$(return_argument0.name:)) = vsc_str_buffer_len($(return_argument0.name:));",)
                endfor

                if my._res <> ""
                    my._c = php_format_extension_comment("Correct string length to the actual")
                    my._res = my._c + my._res

                    new correct_string_length to wrapper
                        . = format_left(my._res, 1)
                    endnew
                endif

                ### <--- Correct string length to the actual

                ### Return type mapping --->

                my._res = ""
            
                for [function].return_argument as return_argument0 where ! string_in2(return_argument0.type, "buffer, str buffer")
                    if return_argument0.type = "byte" & return_argument0.zend_type = "IS_LONG"
                        my._res += format_left("zend_long ret_res = (zend_long)res;", 0)
                    endif
                endfor

                if my._res <> ""
                    my._c = php_format_extension_comment("Return type mapping")
                    my._res = my._c + my._res

                    new return_type_mapping to wrapper
                        . = format_left(my._res, 1)
                    endnew
                endif

                ### <--- Return type mapping

                ### Write returned result --->

                my._res = ""
                my._ret= ""

                if [function].return_zend_type = "IS_STRING"
                    for [function].return_argument as return_argument0 where return_argument0.name <> "status" & return_argument0.type <> "enum"
                        my._ret += format_left("RETVAL_STR(out_$(return_argument0.name:));", 0)
                    endfor
                elsif [function].return_zend_type = "IS_ARRAY"
                    my._ret += format_left("array_init(return_value);", 0)
                    for [function].return_argument as return_argument0 where return_argument0.name <> "status" & return_argument0.type <> "enum"
                        if return_argument0.type = "buffer"
                            my._ret += format_left("add_next_index_str(return_value, out_$(return_argument0.name:));", 0)
                        elsif return_argument0.type = "str buffer"
                            my._ret += format_left("add_next_index_str(return_value, out_$(return_argument0.name:)); /*sb1*/", 0)
                        else 
                            echo_debug_item(return_argument0)
                            echo_fatal("Not implemented (AZ1201)", my)
                        endif
                    endfor
                elsif [function].return_zend_type = "IS_LONG"
                    for [function].return_argument as return_argument0 where return_argument0.name <> "status" & return_argument0.type <> "enum"
                        if return_argument0.type = "byte"
                            my._ret += format_left("RETVAL_LONG(ret_$(return_argument0.name:));", 0)
                        else
                            my._ret += format_left("RETVAL_LONG($(return_argument0.name:));", 0)
                        endif
                    endfor
                elsif [function].return_zend_type = "IS_VOID"

                elsif [function].return_zend_type = "IS_RESOURCE"
                    for [function].return_argument as return_argument0
                        if string_in (return_argument0.type0, "class, interface, implementation")
                            if return_argument0.type0 = "class"

                                my.__f1 = php_derive_low_level_wrapp_func_full_name("le_$(return_argument0.type_t:)")

                                my._ret += format_left("\
                                    zend_resource *$(return_argument0.name:)_res = zend_register_resource($(return_argument0.name:)$(my._rs), $(my.__f1:)());
                                    RETVAL_RES($(return_argument0.name:)_res);
                                    ", 0)
                            else

                                my.__f1 = php_derive_low_level_wrapp_func_full_name("le_$(my.in_php_project.prefix:)_impl_t")
                                my._ret += format_left("\
                                    zend_resource *$(return_argument0.name:)_res = zend_register_resource($(return_argument0.name:)$(my._rs), $(my.__f1:)());
                                    RETVAL_RES($(return_argument0.name:)_res);
                                    ", 0)
                            endif
                        else
                            echo_debug_item(function)
                            echo_debug_item(return_argument0)
                            echo_fatal("Not implemented (AK1000)", my)
                        endif
                    endfor
                elsif [function].return_zend_type = "_IS_BOOL"
                    for [function].return_argument as return_argument0
                        my._ret += format_left("RETVAL_BOOL($(return_argument0.name:));", 0)
                    endfor
                else
                    echo_debug_item(function)
                    echo_fatal("Not implemented (AO1001)", my)
                endif

                my._res = my._ret

                if is_true([function].throw_exception) & [function].return_zend_type <> "IS_VOID"
                    my._fail = ""
                    my._success = ""

                    #[function].return_zend_type: "IS_VOID, IS_LONG, _IS_BOOL, IS_STRING, IS_ARRAY, IS_RESOURCE
                    if  [function].return_zend_type = "IS_STRING" | [function].return_zend_type = "IS_ARRAY"
                        for [function].return_argument where string_in2(return_argument.type, "buffer, str buffer")
                            my._fail += format_left("zend_string_free(out_$(return_argument.name:));", 1)
                            if return_argument.type = "buffer"
                                my._success += format_left("vsc_buffer_destroy(&$(return_argument.name:));", 0)
                            else
                                my._success += format_left("vsc_str_buffer_destroy(&$(return_argument.name:));", 0)
                            endif
                        endfor
                    endif

                    my._ret = my._ret + my._success

                    my._t1 = format_left("if (status == $([function].prefix0:c)_status_SUCCESS) {", 0)
                    my._t2 = format_left("$(my._ret:)", 1)
                    my._t3 = format_left("}", 0)
                    my._t4 = format_left("else {", 0)
                    my._t5 = format_left("$(my._fail:)", 1)
                    my._t6 = format_left("}", 0)

                    if my._fail <> ""
                        my._res = my._t1 + my._t2 + my._t3 + my._t4 + my._t5 + my._t6
                    else
                        my._res = my._t1 + my._t2 + my._t3
                    endif

                endif

                if my._res <> ""
                    my._c = php_format_extension_comment("Write returned result")
                    my._res = my._c + my._res

                    new write_returned_result to wrapper
                        . = format_left(my._res, 1)
                    endnew
                endif

                ### <--- Write returned result
            endnew
        endnew
    endfor
endfunction

# ---------------------------------------------------------------------------
# 
# ---------------------------------------------------------------------------
function php_map_low_level_constructor_destructor (in_module, out_low_level, in_type)
    check_arguments (my, "in_module, out_low_level, in_type", my)

    new [function] to my.out_low_level
        .name0 = "$(my.in_module.c_prefix:)_$(my.in_module.name:c)_new"
        .name = "$(0.name0:)_php"
        .prefix0 = "$(my.in_module.c_prefix:)"
        .entity0 = "$(my.in_module.name:)"
        .return_type0 = ""
        .return_type = "IS_RESOURCE"
        .instance = "0"
        .throw_exception = "0"
        .is_static = "0"
        .num_arguments = "0"

        my._a = "$(0.prefix0:c)_$(0.entity0:c)"

        new def_func_entry to [function]
            . = format_left("PHP_FE($([function].name0:)_php, arginfo_$([function].name0:)_php)", 0)
        endnew

        new wrapper to [function]
            new arg_info to wrapper
                my._c = php_format_extension_comment("Wrap method: $([function].name0:)")

                my._h = format_left("\
                    ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(
                            arginfo_$([function].name0:)_php,
                            0 /*return_reference*/,
                            $([function].num_arguments:) /*required_num_args*/,
                            $([function].return_type:) /*type*/,
                            0 /*allow_null*/)
                    ZEND_END_ARG_INFO()
                    ", 0)

                my._res = my._c + my._h
                . = my._res
            endnew

            my._le = "le_$(my._a:)_t"
            if my.in_type = "implementation"
                my._le = "le_$(my.in_module.c_prefix:)_impl_t"
            endif

            new custom_code to wrapper

                my.__f1 = php_derive_low_level_wrapp_func_full_name("$(my._le:)")
                my._custom_code = format_left("\
                    PHP_FUNCTION($([function].name:)) {
                        $(my._a:)_t *$([function].entity0:c) = $([function].name0:)();
                        zend_resource *$([function].entity0:c)_res = zend_register_resource($([function].entity0:c), $(my.__f1:)());
                        RETVAL_RES($([function].entity0:c)_res);
                    }
                    ", 0)
                . = my._custom_code
            endnew
        endnew
    endnew

    new [function] to my.out_low_level
        .name0 = "$(my.in_module.c_prefix:)_$(my.in_module.name:c)_delete"
        .name = "$(0.name0:)_php"
        .prefix0 = "$(my.in_module.c_prefix:)"
        .entity0 = "$(my.in_module.name:)"
        .return_type0 = ""
        .return_type = "IS_VOID"
        .instance = "0"
        .throw_exception = "0"
        .num_arguments = "1"
        .is_static = "0"

        my._a = "$(0.prefix0:)_$(0.entity0)"

        new def_func_entry to [function]
            . = format_left("PHP_FE($([function].name0:)_php, arginfo_$([function].name0:)_php)", 0)
        endnew

        new wrapper to [function]
            new arg_info to wrapper
                my._c = php_format_extension_comment("Wrap method: $([function].name0:)")

                my._h = format_left("\
                    ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(
                            arginfo_$([function].name0:)_php,
                            0 /*return_reference*/,
                            $([function].num_arguments:) /*required_num_args*/,
                            $([function].return_type:) /*type*/,
                            0 /*allow_null*/)

                            ZEND_ARG_TYPE_INFO(0, in_ctx, IS_RESOURCE, 0)
                    ZEND_END_ARG_INFO()
                    ", 0)

                my._res = my._c + my._h
                . = my._res
            endnew

            my._a = "$(my._a:c)"
            if my.in_type = "implementation"
                my._a = "$(my.in_module.c_prefix:)_impl"
            endif

            new custom_code to wrapper

                my.__f1 = php_derive_low_level_wrapp_func_full_name("$(my._a:)_t_php_res_name")
                my.__f2 = php_derive_low_level_wrapp_func_full_name("le_$(my._a:)_t")

                my._custom_code = format_left("\
                    PHP_FUNCTION($([function].name:)) {
                        //
                        // Declare input arguments
                        //
                        zval *in_ctx = NULL;

                        //
                        // Parse arguments
                        //
                        ZEND_PARSE_PARAMETERS_START_EX(ZEND_PARSE_PARAMS_THROW, 1, 1)
                            Z_PARAM_RESOURCE_EX(in_ctx, 1, 0)
                        ZEND_PARSE_PARAMETERS_END();

                        //
                        // Fetch for type checking and then release
                        //
                        $(my._a:)_t *$([function].entity0:c) = zend_fetch_resource_ex(in_ctx, $(my.__f1:)(), $(my.__f2:)());
                        zend_list_close(Z_RES_P(in_ctx));
                        RETURN_TRUE;
                    }
                    ", 0)

                . = my._custom_code
            endnew
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_map_low_level_argument (in_argument, in_php_project, out_argument, out_function)
    check_arguments (my, "in_argument, in_php_project, out_argument, out_function", my)

    my._prefix = my.out_function.prefix0

    my.out_argument.is_dependency = "0"

    if is_true(my.in_argument.is_dependency)
        my.out_argument.is_dependency = "1"
    endif

    my.out_argument.name = "$(my.in_argument.name:c)"
    my.out_argument.access = my.in_argument.access
    
    my._type_c = class_derive_c_instance_type(my.in_argument)

    if defined (my.in_argument.class)
        if string_in2(my.in_argument.class, "data, buffer, str, str buffer") 
            my._type0 = my.in_argument.class
            my._type = "vsc_$(my.in_argument.class:C)_t"
            my._zend_type = "IS_STRING"
        elsif my.in_argument.class = "error"
            my._type0 = "error"
            my._type = "$(my._prefix:)_error_t"
            my._zend_type = ""
            my.out_function.throw_exception = "1"
            my.out_function.check_error = "1"
        else
            my._type0 = "class"
            my._type = "$(my._prefix:)_$(my.in_argument.class:c)_t"
            my._shallow_type = "$(my._prefix:)_$(my.in_argument.class:c)"
            my._zend_type = "IS_RESOURCE"
        endif
    endif

    if defined (my.in_argument.interface)
        my._type0 = "interface"
        my._type = my._type_c
        my._shallow_type = "$(my._prefix:)_impl"
        my._zend_type = "IS_RESOURCE"
    endif

    if defined (my.in_argument.type)
        if my.in_argument.type = "size"
            my._type0 = my.in_argument.type
            my._type = "vsc_size_t"
            my._zend_type = "IS_LONG"
        elsif string_in(my.in_argument.type, "integer, unsigned")
            my._type0 = my.in_argument.type
            my._type = "int"
            my._zend_type = "IS_LONG"
        elsif my.in_argument.type = "byte"
            if count(my.in_argument.array) > 0
                my.out_argument.byte_as_string = "1"
            endif
            my._type0 = "byte"
            if my.in_argument.is_reference = "1"
                my._type = "string"
                my._zend_type = "IS_STRING"
            else 
                my._type = "int"
                my._zend_type = "IS_LONG"
            endif
        elsif my.in_argument.type = "char"
            my._type0 = my.in_argument.type
            my._type = "string"
            my._zend_type = "IS_STRING"
        elsif my.in_argument.type = "boolean"
            my._type0 = my.in_argument.type
            my._type = "zend_bool"
            my._zend_type = "_IS_BOOL"
        else
            echo_debug_item(my.in_argument)
            echo_fatal("Not implemented (AN1006)", my)
        endif
    endif

    if defined (my.in_argument.enum)
        my._type0 = "enum"
        my._type = "$(my._prefix:)_$(my.in_argument.enum:c)_t"
        my._zend_type = "IS_LONG"
    endif

    if defined (my.in_argument.impl)
        my._type0 = "impl"
        my._type = "$(my._prefix:)_$(my.in_argument.impl:c)_t"
        my._shallow_type = "$(my._prefix:)_$(my.in_argument.impl:c)"
        my._zend_type = "IS_RESOURCE"
    endif

    my.out_argument.type0 = my._type0
    my.out_argument.type = my._type
    my.out_argument.zend_type = my._zend_type
    my.out_argument.type_c = my._type_c

    if defined (my._shallow_type)
        my.out_argument.shallow_copy = "$(my._shallow_type:)_shallow_copy"
    else
        my.out_argument.shallow_copy = "$(0.type:)_shallow_copy"
    endif

endfunction

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_map_low_level_return (in_method, in_php_project, out_function)
    check_arguments (my, "in_method, in_php_project, out_function", my)

    my._prefix = my.out_function.prefix0
    my._return_self = "0"

    my._return_type0 = "void"
    my._return_type = ""
    my._return_zend_type = "IS_VOID"
    my._throw_exception = "0"

    my._argument_buffer_count = 0

    for my.in_method.argument as argument0 where string_in2(argument0.class, "buffer, str buffer")
        my._argument_buffer_count = my._argument_buffer_count + 1
        new return_argument to my.out_function
            .name = "$(argument0.name:c)"
            .type = argument0.class
            .type_t = "$(0.type:c)"

            my._prefix = my.out_function.prefix0
            my._entity = my.out_function.entity0

            if count (argument0.length)
                my._proxy = ""
                for argument0->length.proxy as proxy0
                    if defined (proxy0.argument)
                        my._proxy += "$(proxy0.argument:c)"
                        if defined (proxy0.cast) & string_in(proxy0.cast, "data_length, str_length")
                            my._proxy += ".len"
                        endif
                    elsif defined (proxy0.constant)
                        my._proxy += php_lang_ref (proxy0.constant)
                    else
                        echo_debug_item(my.in_method)
                        echo_debug_item(proxy0)
                        echo_fatal("Not implemented (AG1000)")
                    endif

                    if ! last()
                        my._proxy += ", "
                    else
                        return_argument.proxy = my._proxy
                    endif
                endfor

                if defined (argument0->length.method)
                    return_argument.length = "$(my._prefix:)_$(my._entity:)_$(argument0->length.method:c)"
                    return_argument.length_type = "method"
                elsif defined (argument0->length.constant)

                    if defined (argument0->length.class)
                        my._e = argument0->length.class
                    else
                        my._e = my._entity
                    endif

                    return_argument.length = "$(my._prefix:c)_$(my._e:c)_$(argument0->length.constant:c,UPPER)"
                    return_argument.length_type = "constant"
                elsif defined (argument0->length.argument)

                    return_argument.length = "$(argument0->length.argument:c)"
                    if defined (argument0->length.cast) & argument0->length.cast = "data_length"
                        return_argument.length += ".len"
                    endif
                    return_argument.length_type = "argument"

                else
                    echo_debug_item(argument0)
                    echo_fatal("Not implemented (AA1000)", my)
                endif

                if return_argument.length_type = "method" & defined(return_argument.proxy)
                    return_argument.length_type = "method_proxy"
                endif
            endif
        endnew
    endfor

    if my._argument_buffer_count = 1
        my._return_type = "string"
        my._return_zend_type = "IS_STRING"
    elsif my._argument_buffer_count > 1
        my._return_type = "array"
        my._return_zend_type = "IS_ARRAY"
    endif

    for my.in_method.return as return0

        my._is_reference = return0.is_reference

        if defined (return0.type)
            if return0.type = "size"
                my._return_type0 = return0.type
                my._return_type = "size_t"
                my._return_zend_type = "IS_LONG"
            elsif string_in(return0.type, "integer, unsigned")
                my._return_type0 = return0.type
                my._return_type = "int"
                my._return_zend_type = "IS_LONG"
            elsif return0.type = "byte"
                my._return_type0 = return0.type
                my._return_type = "byte"
                my._return_zend_type = "IS_LONG"
            elsif return0.type = "boolean"
                my._return_type0 = return0.type
                my._return_type = "zend_bool"
                my._return_zend_type = "_IS_BOOL"
            else
                echo_debug_item(my.in_method)
                echo_debug_item(return0)
                echo_fatal("Not implemented (AV1000)", my)
            endif

            new return_argument to my.out_function
                .name = "res"
                .type0 = "$(return0.type:c)"
                .type = my._return_type
                .type_t = 0.type
                .zend_type = my._return_zend_type
                .is_reference = my._is_reference
            endnew
        endif

        my._r = ""

        if defined (return0.class)

            if return0.class = "data"
                my._return_type0 = return0.class
                my._return_type = "vsc_data_t"
                my._return_zend_type = "IS_STRING"

                new return_argument to my.out_function
                    .name = return0.class
                    .type0 = "data"
                    .type = my._return_type
                    .type_t = 0.type
                    .zend_type = my._return_zend_type
                    .is_reference = my._is_reference
                endnew

            elsif return0.class = "buffer"
                my._return_type0 = return0.class
                my._return_type = "vsc_buffer_t"
                my._return_zend_type = "IS_STRING"

                new return_argument to my.out_function
                    .name = return0.class
                    .type0 = "buffer"
                    .type = my._return_type
                    .type_t = 0.type
                    .zend_type = my._return_zend_type
                    .is_reference = my._is_reference
                    .access = return0.access
                endnew

            elsif return0.class = "str"
                my._return_type0 = return0.class
                my._return_type = "vsc_str_t"
                my._return_zend_type = "IS_STRING"

                new return_argument to my.out_function
                    .name = return0.class
                    .type0 = "str"
                    .type = my._return_type
                    .type_t = 0.type
                    .zend_type = my._return_zend_type
                    .is_reference = my._is_reference
                endnew

            elsif return0.class = "str buffer"
                my._return_type0 = return0.class
                my._return_type = "vsc_str_buffer_t"
                my._return_zend_type = "IS_STRING"

                new return_argument to my.out_function
                    .name = return0.class
                    .type0 = "buffer"
                    .type = my._return_type
                    .type_t = 0.type
                    .zend_type = my._return_zend_type
                    .is_reference = my._is_reference
                    .access = return0.access
                endnew
            else
                my._return_type0 = return0.class
                my._return_type = "class"
                my._return_zend_type = "IS_RESOURCE"

                new return_argument to my.out_function
                    .name = "$(return0.class:c)"
                    .type0 = "class"
                    .type_t = "$(my._prefix:)_$(0.name:)_t"
                    .type = "$(my._prefix:)_$(0.name:)"
                    .zend_type = my._return_zend_type
                    .is_reference = my._is_reference
                    .access = return0.access
                    .shallow_copy = "$(0.type:)_shallow_copy"
                    .class_name0 = "$(return0.class:)"
                endnew
            endif
        elsif defined (return0.interface)
            my._return_type0 = return0.interface
            my._return_type = "interface"
            my._return_zend_type = "IS_RESOURCE"

            new return_argument to my.out_function
                .name = "$(return0.interface:c)"
                .type0 = "interface"
                .type_t = "$(my._prefix:)_impl_t"
                .type = "$(my._prefix:)_impl"
                .zend_type = my._return_zend_type
                .is_reference = my._is_reference
                .access = return0.access
                .shallow_copy = "$(0.type:)_shallow_copy"
                .class_name0 = "$(return0.interface:)"
            endnew
        elsif defined (return0.impl)
            my._return_type0 = return0.impl
            my._return_type = "implementation"
            my._return_zend_type = "IS_RESOURCE"

            new return_argument to my.out_function
                .name = "$(return0.impl:c)"
                .type0 = "implementation"
                .type_t = "$(my._prefix:)_$(0.name:)_t"
                .type = "$(my._prefix:)_$(0.name:)"
                .zend_type = my._return_zend_type
                .is_reference = my._is_reference
                .access = return0.access
                .shallow_copy = "$(0.type:)_shallow_copy"
                .class_name0 = "$(return0.impl:)"
            endnew
        endif

        if defined (return0.enum)
            if return0.enum = "status"
                my._throw_exception = "1"

                new return_argument to my.out_function
                    .name = "status"
                    .type0 = "status"
                    .type = "$(my._prefix:)_status_t"
                    .type_t = 0.type
                    .zend_type = "IS_RESOURCE"
                endnew
            else
                my._return_type0 = "enum"
                my._return_type = "int"
                my._return_zend_type = "IS_LONG"

                new return_argument to my.out_function
                    .name = "$(return0.enum:c)"
                    .type0 = "enum"
                    .type = "int"
                    .type_t = 0.type
                    .zend_type = "IS_LONG"
                    .is_reference = my._is_reference
                endnew
            endif
        endif
    endfor

    my.out_function.return_type0 = my._return_type0
    my.out_function.return_type = my._return_type
    my.out_function.return_zend_type = my._return_zend_type
    my.out_function.throw_exception = my._throw_exception
    my.out_function.return_self = my._return_self

endfunction

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_map_low_level_extension (in_php_project, out_php_module)
    check_arguments (my, "in_php_project, out_php_module", my)

    my._include = ""
    my._registered_resources = ""
    my._registered_resources_func_wrapp = ""
    my._header_registered_resources = ""
    my._constants = ""
    my._constants_func_wrapp = ""
    my._header_constants = ""
    my._init_func_def_dtor = ""
    my._init_func_def_list_destr = ""

    my._prefix = my.in_php_project.prefix
    my._project = my.in_php_project.project

    my._init_func_def_exception = format_left("\
        zend_class_entry $(my._prefix:)_ce;
        INIT_CLASS_ENTRY($(my._prefix:)_ce, \"$(my._project:)Exception\", NULL);
        $(my._prefix:)_exception_ce = zend_register_internal_class_ex(&$(my._prefix:)_ce, zend_exception_get_default());
        ", 0)

    if count(my.in_php_project.interfaces)
        my._registered_resources = format_left("int LE_$(my.in_php_project.prefix:UPPER)_IMPL_T;", 0)
        my._registered_resources_func_wrapp = php_format_low_level_wrapp_func_rr("LE_$(my.in_php_project.prefix:UPPER)_IMPL_T", "$(my.in_php_project.prefix:)", 0) + "\n"
        my._header_registered_resources = php_format_low_level_wrapp_func_rr("LE_$(my.in_php_project.prefix:UPPER)_IMPL_T", "$(my.in_php_project.prefix:)", 1) + "\n"

        my._constants = format_left("static const char $(my.in_php_project.prefix:UPPER)_IMPL_T_PHP_RES_NAME[] = \"$(my.in_php_project.prefix)_impl_t\";", 0)
        my._constants_func_wrapp = php_format_low_level_wrapp_func_const("$(my.in_php_project.prefix:UPPER)_IMPL_T_PHP_RES_NAME", "$(my.in_php_project.prefix:)", 0) + "\n"
        my._header_constants = php_format_low_level_wrapp_func_const("$(my.in_php_project.prefix:UPPER)_IMPL_T_PHP_RES_NAME", "$(my.in_php_project.prefix:)", 1) + "\n"

        my._p = my.in_php_project.prefix

        my._init_func_def_dtor += format_left("\
            static void $(my._p:)_impl_dtor_php(zend_resource *rsrc) {
                $(my._p:)_impl_delete(($(my._p:)_impl_t *)rsrc->ptr);
            }
            ", 0)

        my.__f1 = php_derive_low_level_wrapp_func_full_name("$(my._p:)_impl_t_php_res_name")

        my._init_func_def_list_destr += format_left("\
            LE_$(my._p:UPPER)_IMPL_T = zend_register_list_destructors_ex($(my._p:)_impl_dtor_php, NULL, $(my.__f1:)(), module_number);
            ", 0)
    endif

    my._def_func_entries = ""
    my._func_wrapping = ""
    my._extension_status = ""

    for my.in_php_project.php_module as php_module0 where php_module0.name0 = "extension status"
        my._extension_status += php_module0->custom_code.
    endfor

    my._ext_name0 = "$(my.in_php_project.prefix:)_$(my.in_php_project.name:)_php"

    for my.in_php_project.php_module as php_module0 where string_in(php_module0.type, "class, implementation, single_function")
        if ! defined (php_module0->low_level->[include]) & php_module0.type <> "single_function"
            echo_debug_item(php_module0->low_level)
            echo_fatal("Not implemented (AQ2000)", my)
        endif

        if php_module0.type <> "single_function"
            my._include += php_module0->low_level->[include].

            if (php_module0.type <> "implementation") & is_true(php_module0.context)
                my._registered_resources += php_module0->low_level->registered_resource.
                my._registered_resources_func_wrapp += php_module0->low_level->registered_resource_func_wrapp. + "\n"
                my._header_registered_resources += php_module0->low_level->header_registered_resource. + "\n"
                my._constants += php_module0->low_level->constant.
                my._constants_func_wrapp += php_module0->low_level->constant_func_wrapp. + "\n"
                my._header_constants += php_module0->low_level->header_constant. + "\n"
                my._init_func_def_dtor += php_module0->low_level->init_func_def_dtor.
                my._init_func_def_list_destr += php_module0->low_level->init_func_def_list_destr.
            endif
        endif

        for php_module0->low_level.[function] as function0
            my._func_wrapping += format_left(function0->wrapper->arg_info., 0)
            my._def_func_entries += function0->def_func_entry.

            if count(function0->wrapper.custom_code)
                my._func_wrapping += "\n" + format_left(function0->wrapper->custom_code., 0)
            else
                my._1 = "\n" + function0->wrapper->header.
                my._2 = "\n" + function0->wrapper->declare_input_arguments.
                my._3 = "\n" + function0->wrapper->parse_arguments.

                my._4 = ""
                if count(function0->wrapper.proxy_call)
                    my._4  = "\n" + function0->wrapper->proxy_call.
                endif

                my._5 = ""
                if count(function0->wrapper.argument_type_mapping)
                    my._5  = "\n" + function0->wrapper->argument_type_mapping.
                endif

                my._6 = ""
                if count(function0->wrapper.allocate_output_buffer)
                    my._6 = "\n" + function0->wrapper->allocate_output_buffer.
                endif

                my._7 = "\n" + function0->wrapper->call_main_function.

                my._8 = ""
                if count(function0->wrapper.handle_error)
                    my._8 = "\n" + function0->wrapper->handle_error
                endif

                my._9 = ""
                if count(function0->wrapper.correct_string_length)
                    my._9 = "\n" + function0->wrapper->correct_string_length.
                endif

                my._10 = ""
                if count(function0->wrapper.return_type_mapping)
                    my._10 = "\n" + function0->wrapper->return_type_mapping.
                endif

                my._11 = ""
                if count(function0->wrapper.write_returned_result)
                    my._11 = "\n" + function0->wrapper->write_returned_result.
                endif

                my._12 = format_left("}", 0)

                my._func_wrapping += my._1 + my._2 + my._3 + my._4 + my._5 + my._6 + my._7 + my._8 + my._9 + my._10 + my._11 + my._12
            endif

            my._func_wrapping += "\n"
        endfor
    endfor

    new licence to my.out_php_module
        . = php_format_extension_comment (my.in_php_project->license)
    endnew

    new [include] to my.out_php_module

        my._req = ""

        for my.in_php_project->require_projects.require_project as require_project0
            my._req += format_left("#include \"$(require_project0.prefix0:)_$(require_project0.name0:)_php.h\"",0)
        endfor

        my._res = format_left("\
            #include <php.h>
            #include <zend_exceptions.h>
            #include <zend_list.h>
            #include \"$(my.in_php_project.prefix:)_assert.h\"
            #include \"$(my.in_php_project.prefix:)_$(my.in_php_project.name:)_php.h\"
            ", 0)

        . = my._res + my._req + my._include
    endnew

    new constants to my.out_php_module

        my._ext_name = "$(my._ext_name0:UPPER)"

        my._c = php_format_extension_comment ("Constants")
        my._h = format_left("\
            const char $(my._ext_name:UPPER)_VERSION[] = \"$(my.in_php_project.version:)\";
            const char $(my._ext_name:UPPER)_EXTNAME[] = \"$(my._ext_name0:)\"; 
            ", 0)

        . = my._c + my._h + "\n" + my._constants
    endnew

    new constants_func_wrapp to my.out_php_module
        my._c = php_format_extension_comment ("Constants func wrapping")
        . = my._c + my._constants_func_wrapp
    endnew

    new header_top to my.out_php_module
        . = format_left("\
            #ifndef $(my.in_php_project.prefix:UPPER)_$(my.in_php_project.project0:UPPER)_PHP_H_INCLUDED
            #define $(my.in_php_project.prefix:UPPER)_$(my.in_php_project.project0:UPPER)_PHP_H_INCLUDED

            #ifdef __cplusplus
            extern \"C\" {
            #endif


            #if defined(_WIN32) || defined(__CYGWIN__)
            #   if $(my.in_php_project.prefix:UPPER)_PHP_SHARED_LIBRARY
            #       if defined($(my.in_php_project.prefix:UPPER)_PHP_INTERNAL_BUILD)
            #           ifdef __GNUC__
            #               define $(my.in_php_project.prefix:UPPER)_PHP_PUBLIC __attribute__ ((dllexport))
            #           else
            #               define $(my.in_php_project.prefix:UPPER)_PHP_PUBLIC __declspec(dllexport)
            #           endif
            #       else
            #           ifdef __GNUC__
            #               define $(my.in_php_project.prefix:UPPER)_PHP_PUBLIC __attribute__ ((dllimport))
            #           else
            #               define $(my.in_php_project.prefix:UPPER)_PHP_PUBLIC __declspec(dllimport)
            #           endif
            #       endif
            #   else
            #       define $(my.in_php_project.prefix:UPPER)_PHP_PUBLIC
            #   endif
            #   define $(my.in_php_project.prefix:UPPER)_PHP_PRIVATE
            #else
            #   if (defined(__GNUC__) && __GNUC__ >= 4) || defined(__INTEL_COMPILER) || defined(__clang__)
            #       define $(my.in_php_project.prefix:UPPER)_PHP_PUBLIC __attribute__ ((visibility (\"default\")))
            #       define $(my.in_php_project.prefix:UPPER)_PHP_PRIVATE __attribute__ ((visibility (\"hidden\")))
            #   else
            #       define $(my.in_php_project.prefix:UPPER)_PHP_PRIVATE
            #   endif
            #endif
            ", 0)
    endnew

    new header_bottom to my.out_php_module
        . = format_left("\
            #ifdef __cplusplus
            }
            #endif

            #endif // $(my.in_php_project.prefix:UPPER)_$(my.in_php_project.project0:UPPER)_PHP_H_INCLUDED
            ", 0)
    endnew

    new header_constants to my.out_php_module
        my._c = php_format_extension_comment ("Constants")
        . = my._c + my._header_constants
    endnew

    new registered_resources to my.out_php_module
        my._c = php_format_extension_comment ("Registered resources")
        . = my._c + my._registered_resources
    endnew

    new registered_resources_func_wrapp to my.out_php_module
        my._c = php_format_extension_comment ("Registered resources func wrapping")
        . = my._c + my._registered_resources_func_wrapp
    endnew

    new header_registered_resources to my.out_php_module
        my._c = php_format_extension_comment ("Registered resources")
        . = my._c + my._header_registered_resources
    endnew

    new init_func_declaration to my.out_php_module

        my._c = php_format_extension_comment ("Extension init functions declaration")
        my._h = format_left("\
            PHP_MINIT_FUNCTION($(my._ext_name0:));
            PHP_MSHUTDOWN_FUNCTION($(my._ext_name0:));
            ", 0)

        . = my._c + my._h
    endnew

    new func_wrapping to my.out_php_module
        my._c = php_format_extension_comment ("Functions wrapping")
        my._h = my._func_wrapping

        . = my._c + my._h
    endnew

    new define_all_func_entries to my.out_php_module
        my._c = php_format_extension_comment ("Define all function entries")

        my._h1 = format_left("static zend_function_entry $(my._ext_name0:)_functions[] = {", 0)
        my._h2 = format_left("$(my._def_func_entries:)", 1)
        my._h3 = format_left("\
                PHP_FE_END
            };
            ", 0)

        . = my._c + my._h1 + my._h2 + my._h3
    endnew

    new module_definitions to my.out_php_module
        my._c = php_format_extension_comment ("Extension module definition")
        my._h = format_left("\
            zend_module_entry $(my._ext_name0:)_module_entry = {
            #if ZEND_MODULE_API_NO >= 20010901
                STANDARD_MODULE_HEADER,
            #endif
                $(my._ext_name0:UPPER)_EXTNAME,
                $(my._ext_name0:)_functions,
                PHP_MINIT($(my._ext_name0:)),
                PHP_MSHUTDOWN($(my._ext_name0:)),
                NULL,
                NULL,
                NULL,
            #if ZEND_MODULE_API_NO >= 20010901
                $(my._ext_name0:UPPER)_VERSION,
            #endif
                STANDARD_MODULE_PROPERTIES
            };

            ZEND_GET_MODULE($(my._ext_name0:))
            ", 0)

        . = my._c + my._h
    endnew

    new init_func_definitions to my.out_php_module
        my._c = php_format_extension_comment ("Extension init functions definition")

        my._h1 = format_left("$(my._init_func_def_dtor:)", 0)
        my._h2 = format_left("PHP_MINIT_FUNCTION($(my._ext_name0:)) {", 0)
        my._h3 = format_left("$(my._init_func_def_exception:)", 1)
        my._h4 = format_left("$(my._init_func_def_list_destr:)", 1)

        my._h5 = format_left("\
                return SUCCESS;
            }
            ", 0)

        my._h6 = format_left("\
            PHP_MSHUTDOWN_FUNCTION($(my._ext_name0:)) {
                return SUCCESS;
            }
            ", 0)

        . = my._c + my._h1 + my._h2 + my._h3 + my._h4 + my._h5 + my._h6
    endnew

    new extension_status to my.out_php_module
        . = my._extension_status
    endnew

endfunction
.endtemplate
